Оглавление

	Что это

	Установка и настройка

	Команды

	Основные понятия

	Общая схема работы

	Producer (поставщик)

	Exchange (точка обмена)

	Queue (очередь)

	Consumer (подписчик)

	Bindings (переплёты)

	Паттерны

	Очереди задач

	Подтверждение выполнения сообщений

	Устойчивость сообщений и очередей

	Равномерное распределение сообщений

	Размер очереди

	Временные очереди

Что это

	RabbitMQ ‒ это брокер сообщений

	Его основная цель принимать и отдавать сообщения

	Используется если нужно доставить задачу от одного приложения в другое

	RabbitMQ является одновременно и почтовым ящиком, и почтовым отделением, и почтальоном

	Для использования RabbitMQ необходима библиотека.

	Для python бывают следующие библиотеки: py-amqplib, txAMQP, pika

Установка и настройка

	wget https://packages.erlang-solutions.com/erlang-solutions_1.0_all.deb

	sudo dpkg -i erlang-solutions_1.0_all.deb

	sudo apt-get update

	sudo apt-get install erlang erlang-nox

	echo 'deb http://www.rabbitmq.com/debian/ testing main' | sudo tee /etc/apt/sources.list.d/rabbitmq.list

	wget -O- https://www.rabbitmq.com/rabbitmq-release-signing-key.asc | sudo apt-key add -

	sudo apt-get update

	sudo apt-get install rabbitmq-server

	sudo systemctl enable rabbitmq-server
	sudo systemctl start rabbitmq-server
	sudo systemctl stop rabbitmq-server

	sudo rabbitmqctl add_user admin password 
	sudo rabbitmqctl set_user_tags admin administrator
	sudo rabbitmqctl set_permissions -p / admin ".*" ".*" ".*"

	sudo rabbitmq-plugins enable rabbitmq_management

	start rabbit manage panel on http://localhost:15672

	pip install pika

Команды

	rabbitmqctl list_queues - выводит список очередей

	rabbitmqctl name messages_ready - выводит список выполненных задач

	rabbitmqctl name messages_ready messages_unacknowledged - выводит список невыполненных задач

	rabbitmqctl list_exchanges - выводит список точек обмена

	rabbitmqctl list_bindings - выводит список связанных точек обмена с очередями

Основные понятия

	Поставщик, очередь, подписчик, брокер

	Поставщик, подписчик и брокер обычно находяться на разных машинах

Общая схема работы

	Подключаем библиотеку для работы с брокером. В моём случае pika.

	Есть 2 файла. В 1 код для поставщика, во втором для подписчика.

	В каждом из файлов:

		Подключаемся к брокеру.

		Создаём очередь. В двух файлах, потому что неизвестно какой из них запустится первым, а если очередь не будет существовать, то rabbit проигнорирует сообщение от поставщика.

		В файле поставщике отправляем сообщение в очередь и закрываем соединение с брокером.

		В файле подписчике принимаем сообщение из очереди и запускаем бесконечный процесс, который слушает очередь и если там появляются сообщения, извлекает их из неё.

Producer (поставщик)

	Программа, которая отправляет сообщения. Обозначается буквой P.

Exchange (точка обмена)

	Основная идея в модели отправки сообщений Rabbit в том, что поставщик никогда не отправляет сообщения на прямую в очередь.

	Как правила поставщик отправляет сообщения в точку обмена.

	Точка обмена в свою очередь отправляет сообщение в очередь.

	Точка обмена точно знает, что делать с поступившими сообщениями. Отправить сообщение в конкретную очередь, либо в несколько очередей, либо не отправлять никому и удалить его.

	Что делать с сообщением указывается в типе точки обмена.

	Существуют несколько типов: direct, topic, headers и fanout.

	direct - 

	topic -

	headers -

	fanout - копирует все сообщения во все очереди, channel.exchange_declare('logs', 'fanout', False, False, False) - logs это имя точки обмена

Queue (очередь)

	Находится внутри обменника, то есть находится внтури RabbitMQ

	Сообщения хранятся в очередях

	Любое кол-во поставщиков могут отправлять сообщения в очередь

	Любое кол-во подписчиков могут получать сообщения из одной очереди

	Очереди создаются и в файлах поставщиках и в файлах подписчиках. Это нужно потому что мы не знаем какой файл сработает раньше. При этом каждая очередь с одинаковым названием будет созданна только единожды

Consumer (подписчик)

	Программа принимающая сообщения

	Находится в состоянии ожидания сообщений

Bindings (переплёты)

	Нужны для того чтобы точка обмена отправляла сообщение в очередь

	channel.queue_bind('one', 'logs') - связывает точку обмена с очередью, one - это имя очереди, logs - это имя точки доступа

Паттерны

	round-robin (поставщик отправляет сообщения по очереди каждому поставщику, смотреть очереди задач)

	publish-subscribe (поставщик отправляет одно сообщение нескольким подписчикам)

Очереди задач

	Основная цель не выполнять задачу сразу и не ждать пока уже начатая задача завершится.

	Программа-обработчик (worker.py), работающая в фоновом режиме, примет задачу на обработку, и через какое-то время выполнит её.

	Запускаем 3 консоли. Две из них будут вызывать worker.py, который является подписчиком и одна консоль запустит поставщика.

	Таким образом 2 подписчика будут ждать задачи из очереди.

	Преимущество очереди задач в том, что можно выполнять работу паралельно несколькими программами.

	Когда поставщик отправляет например пять сообщений подряд, то два воркера будут получать эти сообщения по очереди, то есть первое сообщение попадёт в первый воркер, второе сообщение попадёт во второй воркер, третье сообщение попадёт снова в первый воркер и т.д.

	Такой подход к распределению задач называется round-robin

Подтверждение выполнения сообщений

	Может возникнуть ситуация, когда поставщик отправил сообщение, подписчик начал его выполнять, но произошла ошибка и задача не выполнилась до конца.

	В таких случаях нужно подтверждение, что сообщение не только доставленно, но и выполненно.

	RabbitMQ поддерживает подтверждение сообщений. Подтверждение (ack) отправляется подписчиком для информирования RabbitMQ о том, что полученное сообщение было обработано и RabbitMQ может его удалить.

	Если подписчик прекратил работу и не отправил подтверждение, RabbitMQ поймет, что сообщение не было обработано, и передаст его другому подписчику.

Устойчивость сообщений и очередей

	По умолчанию при остановке или падении сервера RabbitMQ все очереди и сообщения теряются, но это поведение можно изменить.

	Для того чтобы сообщения оставались в очереди после перезапуска сервера, необходимо сделать как очереди, так и сообщения устойчивыми.

	channel.queue_declare(queue='hello', durable=True) - позволяет сделать очереди устойчивыми (эта команда не отработает если очередь уже созданна, поэтому лучше создать новую)

	channel.basic_publish(exchange='',
		routing_key="task_queue",
		body=message,
		properties=pika.BasicProperties(
			delivery_mode = 2, - этот параметр позволяет сделать сообщения устойчивыми
		)
    )

    Устойчивость сообщения не гарантирует, что оно не будет потеряно, потому что есть небольшой промежуток времени, когда RabbitMQ подтвердил принятие сообщения, но еще не записал его на диск.

    Если нужна более высокая надёжность, можно оборачивать сообщения в транзакции.

Равномерное распределение сообщений

	Если первый подписчик имеет более простые задачи, чем второй, то большую часть времени он будет свободен.

	Чтобы изменить такое поведение, мы можем использовать метод basic_qos с опцией prefetch_count=1. 

	После установки данной опции подписчик не получит новое сообщение, до тех пор пока не обработает и не подтвердит предыдущее. 

	И RabbitMQ передаст сообщение первому освободившемуся подписчику.

	channel.basic_qos(prefetch_count=1)

Размер очереди

	Если все подписчики заняты, то размер очереди может увеличиваться. Следует обращать на это внимание и, возможно, увеличить количество подписчиков.

Временные очереди

	Актуальны если нужно чтобы в очередь поступали все сообщения и эти сообщения были не устаревшими.

	Для этого нужно каждый раз при соединении с Rabbit создавать новую очередь без имени (оно сгенерируется автоматом) и каждый раз, когда подписчик отключается от Rabbit удалять очередь.

	channel.queue_declare('') - создаёт очередь без имени и когда подписчик отключается, автоматически удаляет её.