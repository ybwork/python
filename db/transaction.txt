Оглавление

	Транзакции

	Проблемы паралельных транзакций

	Уровни изоляции

	Блокировки

	Проверка на практике

Транзакции

	Это операция состоящая из определённого набора действий, которые либо выполняется полностью, либо не выполняются вообще.

	Автокоммит работает автоматически по завершению запроса.

	Если мы явно начинаем транзакцию с помощью begin, то автокоммит выключается и его нужно сделать яано.

	Пока первая транзакция не снимет блок, вторая будет в режиме ожидания.

	Когда транзакция с явным уровнем изоляции завершена, то уровень изоляции возвращается в режим по умолчанию.

	У каждой транзакции есть точка сохранения (save point).

Проблемы паралельных транзакций

	Потерянное обновление

		Обе транзации делают обновление. 

		Первая читает текущее значение поля, которое нужно обновить. 

		Вторая читает это же значение поля до завершения первой. 

		Получается обе при чтении получают одинаковое значение.

		В итоге первая транзакция завершается и записывает новое значение, а вторая при своём завершении перезаписывает значение первой.

	Грязное чтение

		Первая изменила данные, пошла дальше. 

		Вторая увидела изменения первой. Первая не доработала и откатилась. 

		Вторая продолжила работать с неактуальными данными и завершилась.

	Неповторяющееся чтение

		В первой транзакции происходит две одинаковые операции выбора значения поля.

		После первой операции выбора (первой транзакцией), вторая транзакция изменяет значение выбираемого поля.

		При второй операции выбора первой транзакцией мы получаем совсем другое значение поля.

	Чтение фантомов

		В первой транзакции происходит две одинаковые операции выбора значения поля.

		После первой операции выбора (первой транзакцией), вторая транзакция добавляет новую запись в таблицу.

		При второй операции выбора первой транзакцией мы получаем совсем другое значение поля.

		Отличие чтения фантомов от неповторяющегося чтения в том, что при фантомном создаётся новая запись, а при неповторяющемся запись удаляется или изменяется.

Уровни изоляции

	Уровни изоляции - это механизм субд, который позволяет избавиться от проблем паралельных транзакций.

	В процессе рассуждения помнить о блокировках.

	Read committed

		Позволяет читать другим транзакциям только закомиченные данные.

		В postgresql выбран по умолчанию.

		Решает проблему грязного чтения.

		В процессе работы одной транзакции другая может быть успешно завершена и сделанные ею изменения зафиксированы.

	Read uncommited

		Позволяет читать другим транзакциям незакомиченные данные.

		Решает проблему потерянного обновления, потому что после изменения данных первой транзакцией, вторая транзакция может получить новые данные до их фиксации.

		В процессе работы одной транзакции другая может быть успешно завершена и сделанные ею изменения зафиксированы.

	Repeatable read

		Повторяемое чтение.

		Позволяет получить доступ только к закоммиченным данным.

		Решает проблему неповторяющегося чтения. Как?

	Serializable

		Каждая транзакция срабатывает последовательно и не имеет доступа к данным, которые изменяются в другой.

		При изоляции такого уровня все транзакции обрабатываются так, как будто они все запущены последовательно.

Блокировки

	Блокировка (lock) - механизм, который позволяет транзакции захватить доступ к объекту бд.

	Бывают явные (если указали сами в рамках транзакции) и неявные (postgres накладывает автоматические)

	Если обращаемся к разным строкам таблицы, то каждая противоположная транзакция получит доступ к противоположной строке и блокировки не будет.

	SELECT FOR UPDATE берёт строки и блокирует их на обновление. При этом накладываются 2 блокировки (shared, exclusive)

	Типы:

		Исключительная (exclusive lock) - накладывается если транзакция изменяет данные и запрещает другим транзакциям блокировать этот же объект
 
		Совместная (shared lock) - накладывается если транзакция только читает данные и разрещает другим транзакциям блокировть этот же объект

	Виды:

		На уровне строки 

			Действует только на одну строку таблицы, не ограничивая манипуляции над другими строками  

		На уровне таблицы

	Две транзакции не могут одновременно владеть блокировками конфликтующих режимов для одной и той же таблицы.

	Одна транзакция никогда не кофликтует с собой и может сначала запросить блокировку exclusive, а share для той же таблицы.

Проверка на практике

	SELECT blocked_locks.pid     AS blocked_pid,
	       blocked_activity.usename  AS blocked_user,
	       blocking_locks.pid     AS blocking_pid,
	       blocking_activity.usename AS blocking_user,
	       blocked_activity.query    AS blocked_statement,
	       blocking_activity.query   AS current_statement_in_blocking_process
	 FROM  pg_catalog.pg_locks         blocked_locks
	  JOIN pg_catalog.pg_stat_activity blocked_activity  ON blocked_activity.pid = blocked_locks.pid
	  JOIN pg_catalog.pg_locks         blocking_locks
	      ON blocking_locks.locktype = blocked_locks.locktype
	      AND blocking_locks.DATABASE IS NOT DISTINCT FROM blocked_locks.DATABASE
	      AND blocking_locks.relation IS NOT DISTINCT FROM blocked_locks.relation
	      AND blocking_locks.page IS NOT DISTINCT FROM blocked_locks.page
	      AND blocking_locks.tuple IS NOT DISTINCT FROM blocked_locks.tuple
	      AND blocking_locks.virtualxid IS NOT DISTINCT FROM blocked_locks.virtualxid
	      AND blocking_locks.transactionid IS NOT DISTINCT FROM blocked_locks.transactionid
	      AND blocking_locks.classid IS NOT DISTINCT FROM blocked_locks.classid
	      AND blocking_locks.objid IS NOT DISTINCT FROM blocked_locks.objid
	      AND blocking_locks.objsubid IS NOT DISTINCT FROM blocked_locks.objsubid
	      AND blocking_locks.pid != blocked_locks.pid    JOIN pg_catalog.pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
	 WHERE NOT blocked_locks.GRANTED;