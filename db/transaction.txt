Оглавление

	Транзакции

	Проблемы паралельных транзакций

	Уровни изоляции

	Блокировки

	Решения боевых проблем

	Подход к анализу проблемы

	Проверка на практике

Транзакции

	Это операция состоящая из определённого набора действий, которые либо выполняется полностью, либо не выполняются вообще.

	Автокоммит работает автоматически по завершению запроса.

	Если мы явно начинаем транзакцию с помощью begin, то автокоммит выключается и его нужно сделать яано.

	Пока первая транзакция не снимет блок, вторая будет в режиме ожидания.

	Когда транзакция с явным уровнем изоляции завершена, то уровень изоляции возвращается в режим по умолчанию.

	У каждой транзакции есть точка сохранения (save point).

Проблемы паралельных транзакций

	Потерянное обновление

		Обе транзации делают обновление.

		Первая читает текущее значение поля, которое нужно обновить. 

		Вторая читает это же значение поля до завершения первой. 

		Получается обе при чтении получают одинаковое значение.

		В итоге первая транзакция завершается и записывает новое значение, а вторая при своём завершении перезаписывает значение первой.

		Данную проблему решает уровень изоляции Read uncommited.

	Грязное чтение

		Первая изменила данные. 

		Вторая сделала SELECT и увидела изменения первой. 

		Первая не доработала и откатилась. 

		Вторая продолжила работать с неактуальными данными и завершилась.

		Данную проблему решает уровень изоляции Read commited.

	Неповторяющееся чтение

		Первая делает SELECT и продолжает рабатать.

		Вторая делает UPDATE и завершается.

		Первая опять делает SELECT и видит совершенно другие данные.

	Фантомное чтение

		Первая делает SELECT, где считает кол-во строк и продолжает рабатать.

		Вторая делает INSERT и завершается.

		Первая опять делает SELECT, где считает кол-во строк и видит совершенно другие данные.	

Уровни изоляции

	Уровни изоляции - это механизм субд, который позволяет избавиться от проблем паралельных транзакций.

	В процессе рассуждения помнить о блокировках.

	Read uncommited

		Позволяет читать другим транзакциям незакомиченные данные.

		Решает проблему потерянного обновления, потому что после изменения данных первой транзакцией, вторая транзакция может получить новые данные до их фиксации.

		В процессе работы одной транзакции другая может быть успешно завершена и сделанные ею изменения будут валидны.

	Read committed

		Позволяет читать другим транзакциям только закомиченные данные.

		В postgresql выбран по умолчанию.

		Решает проблему грязного чтения.

	Repeatable read

		Повторяемое чтение.

		Позволяет получить доступ только к закоммиченным данным.

		Решает проблему неповторяющегося чтения.

	Serializable

		Каждая транзакция срабатывает последовательно и не имеет доступа к данным, которые изменяются в другой.

		При изоляции такого уровня все транзакции обрабатываются так, как будто они все запущены последовательно.

Блокировки

	Блокировка (lock) - механизм, который позволяет транзакции захватить доступ к объекту бд.

	Бывают явные (если указали сами в рамках транзакции) и неявные (postgres накладывает автоматические)

	Типы:

		Исключительная (exclusive lock) - накладывается если транзакция изменяет данные и запрещает другим транзакциям блокировать этот же объект
 
		Совместная (shared lock) - накладывается если транзакция только читает данные и разрещает другим транзакциям блокировть этот же объект

	Виды:

		На уровне строки 

			Действует только на одну строку таблицы, не ограничивая манипуляции над другими строками  

		На уровне таблицы

	Если обращаемся к разным строкам таблицы, то каждая противоположная транзакция получит доступ к противоположной строке и блокировки не будет.

	SELECT FOR UPDATE берёт строки и блокирует их на обновление. При этом накладываются 2 блокировки (shared, exclusive)

	Две транзакции не могут одновременно владеть блокировками конфликтующих режимов для одной и той же таблицы.

	Одна транзакция никогда не кофликтует с собой и может сначала запросить блокировку exclusive, а share для той же таблицы.

Решения боевых проблем

	

Подход к анализу проблемы

	Выясняем уровень изоляции.

	Понимаем возможности доступа этого уровня.

	Придумываем решение.

Проверка на практике

	SELECT blocked_locks.pid     AS blocked_pid,
	       blocked_activity.usename  AS blocked_user,
	       blocking_locks.pid     AS blocking_pid,
	       blocking_activity.usename AS blocking_user,
	       blocked_activity.query    AS blocked_statement,
	       blocking_activity.query   AS current_statement_in_blocking_process
	 FROM  pg_catalog.pg_locks         blocked_locks
	  JOIN pg_catalog.pg_stat_activity blocked_activity  ON blocked_activity.pid = blocked_locks.pid
	  JOIN pg_catalog.pg_locks         blocking_locks
	      ON blocking_locks.locktype = blocked_locks.locktype
	      AND blocking_locks.DATABASE IS NOT DISTINCT FROM blocked_locks.DATABASE
	      AND blocking_locks.relation IS NOT DISTINCT FROM blocked_locks.relation
	      AND blocking_locks.page IS NOT DISTINCT FROM blocked_locks.page
	      AND blocking_locks.tuple IS NOT DISTINCT FROM blocked_locks.tuple
	      AND blocking_locks.virtualxid IS NOT DISTINCT FROM blocked_locks.virtualxid
	      AND blocking_locks.transactionid IS NOT DISTINCT FROM blocked_locks.transactionid
	      AND blocking_locks.classid IS NOT DISTINCT FROM blocked_locks.classid
	      AND blocking_locks.objid IS NOT DISTINCT FROM blocked_locks.objid
	      AND blocking_locks.objsubid IS NOT DISTINCT FROM blocked_locks.objsubid
	      AND blocking_locks.pid != blocked_locks.pid    JOIN pg_catalog.pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
	 WHERE NOT blocked_locks.GRANTED;