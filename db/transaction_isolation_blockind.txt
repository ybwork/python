Оглавление

	Транзакции

	Проблемы паралельных транзакций

	Уровни изоляции

	Блокировки

	Deadlock

	Подход к анализу проблемы

	Проверка на практике

Транзакции

	Это операция состоящая из определённого набора действий, которые либо выполняется полностью, либо не выполняются вообще.

	Автокоммит работает автоматически по завершению запроса.

	Если мы явно начинаем транзакцию с помощью begin, то автокоммит выключается и его нужно сделать яано.

	Пока первая транзакция не снимет блок, вторая будет в режиме ожидания.

	Когда транзакция с явным уровнем изоляции завершена, то уровень изоляции возвращается в режим по умолчанию.

	У каждой транзакции есть точка сохранения (save point).

Проблемы паралельных транзакций

	Потерянное обновление

		Обе транзации делают обновление.

		Первая читает текущее значение поля, которое нужно обновить. 

		Вторая читает это же значение поля до завершения первой. 

		Получается обе при чтении получают одинаковое значение.

		В итоге первая транзакция завершается и записывает новое значение, а вторая при своём завершении перезаписывает значение первой.

		Данную проблему решает уровень изоляции Read uncommited.

	Грязное чтение

		Первая изменила данные. 

		Вторая сделала SELECT и увидела изменения первой. 

		Первая не доработала и откатилась. 

		Вторая продолжила работать с неактуальными данными и завершилась.

		Данную проблему решает уровень изоляции Read commited.

	Неповторяющееся чтение

		Первая делает SELECT и продолжает рабатать.

		Вторая делает UPDATE и завершается.

		Первая опять делает SELECT и видит совершенно другие данные.

		Данную проблему решает уровень изоляции Repeatable read.

	Фантомное чтение

		Первая делает SELECT, где считает кол-во строк и продолжает рабатать.

		Вторая делает INSERT и завершается.

		Первая опять делает SELECT, где считает кол-во строк и видит совершенно другие данные.

		Данную проблему решает уровень изоляции Serializable.

Уровни изоляции

	Уровни изоляции - это механизм субд, который позволяет избавиться от проблем паралельных транзакций.

	Уровни изоляции используют блокировки, поэтому это связанные вещи.

	Первый из них является самым слабым, последний — самым сильным, каждый последующий включает в себя все предыдущие.

	Read uncommited

		Позволяет читать другим транзакциям незакомиченные данные.

		Решает проблему потерянного обновления, потому что после изменения данных первой транзакцией, вторая транзакция может получить новые данные до их фиксации.

		В процессе работы одной транзакции другая может быть успешно завершена и сделанные ею изменения будут валидны.

	Read committed

		Позволяет читать другим транзакциям только закомиченные данные.

		В postgresql выбран по умолчанию.

		Решает проблему грязного чтения.

	Repeatable read

		Если первая транзакция читает данные и не завершилась, то вторая не может обновить эти данные.

		Решает проблему неповторяющегося чтения.

	Serializable

		Каждая транзакция срабатывает последовательно и не имеет доступа к данным, которые изменяются в другой.

		При изоляции такого уровня все транзакции обрабатываются так, как будто они все запущены последовательно.

		Решает проблему фантомного чтения.

Блокировки

	Блокировка (lock) - механизм, который позволяет транзакции захватить доступ к объекту бд.

	Понимание того как работают блокировки является ключом к написанию правильных запросов способных выполняться параллельно.

	Бывают явные (если указали сами в рамках транзакции) и неявные (postgres накладывает автоматические)

	Типы:

		Исключительная (exclusive lock) - накладывается если транзакция изменяет данные и запрещает другим транзакциям блокировать этот же объект, при этом если уже наложена совместная блокировка, то исключительную не получиться наложить.
 
		Совместная (shared lock) - накладывается если транзакция только читает данные и разрещает другим транзакциям блокировть этот же объект.

	Виды:

		На уровне строки 

			Действует только на одну строку таблицы, не ограничивая манипуляции над другими строками.

		На уровне таблицы

	SELECT FOR UPDATE берёт строки и блокирует их на обновление. При этом накладываются 2 блокировки (shared, exclusive).

	Две транзакции не могут одновременно владеть блокировками конфликтующих режимов для одной и той же таблицы.

	Одна транзакция никогда не кофликтует с собой и может сначала запросить блокировку exclusive, а share для той же таблицы.

	Если наложенная на строку блокировка не позволяет выполнить операцию, то транзакция просто ждет снятия мешающей блокировки. В случае перекрестных блокировок ждать можно долго, это deadlock.

Deadlock

	Примерно такие ошибки вываливается если происходит deadlock:

		ERROR: deadlock detected
		DETAIL: Process 18293 waits for ShareLock on transaction 639; blocked by process 18254.
	      Process 18293: update users set balance = balance + 10 where id = 2;
	      Process 18254: update users set balance = balance + 10 where id = 3;
		Process 18254 waits for ShareLock on transaction 640; blocked by process 18293.
		HINT: See server log for query details.
		CONTEXT: while updating tuple (0,9) in relation "users"
		STATEMENT: update users set balance = balance + 10 where id = 2;

		вторую взять на работе

	Частое применение явных блокировок может увеличить вероятность взаимоблокировок, то есть ситуаций, когда две (или более) транзакций держат блокировки так, что взаимно блокируют друг друга. Например, если транзакция 1 получает исключительную блокировку таблицы A, а затем пытается получить исключительную блокировку таблицы B, которую до этого получила транзакция 2, в данный момент требующая исключительную блокировку таблицы A, ни одна из транзакций не сможет продолжить работу. PostgreSQL автоматически выявляет такие ситуации и разрешает их, прерывая одну из сцепившихся транзакций и тем самым позволяя другой (другим) продолжить работу. (Какая именно транзакция будет прервана, обычно сложно предсказать, так что рассчитывать на определённое поведение не следует.)

	Заметьте, что взаимоблокировки могут вызываться и блокировками на уровне строк (таким образом, они возможны, даже если не применяются явные блокировки). Рассмотрим случай, когда две параллельных транзакции изменяют таблицу. Первая транзакция выполняет:

	UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 11111;
	При этом она получает блокировку строки с указанным номером счёта. Затем вторая транзакция выполняет:

	UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 22222;
	UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 11111;
	Первый оператор UPDATE успешно получает блокировку указанной строки и изменяет данные в ней. Однако второй оператор UPDATE обнаруживает, что строка, которую он пытается изменить, уже заблокирована, так что он ждёт завершения транзакции, получившей блокировку. Таким образом, вторая транзакция сможет продолжиться только после завершения первой. Теперь первая транзакция выполняет:

	UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 22222;
	Первая транзакция пытается получить блокировку заданной строки, но ей это не удаётся: эта блокировка уже принадлежит второй транзакции. Поэтому первой транзакции остаётся только ждать завершения второй. В результате первая транзакция блокируется второй, а вторая — первой: происходит взаимоблокировка. PostgreSQL выявляет эту ситуацию и прерывает одну из транзакций.

	Обычно лучший способ предотвращения взаимоблокировок — добиться, чтобы все приложения, обращающиеся к базе данных, запрашивали блокировки нескольких объектов единообразно. В данном примере, если бы обе транзакции изменяли строки в одном порядке, взаимоблокировка бы не произошла. Блокировки в транзакции следует упорядочивать так, чтобы первой для какого-либо объекта запрашивалась наиболее ограничивающая из тех, которые для него потребуются. Если заранее обеспечить такой порядок нельзя, взаимоблокировки можно обработать по факту, повторяя прерванные транзакции.

	Если ситуация взаимоблокировки не будет выявлена, транзакция, ожидающая блокировки на уровне таблицы или строки, будет ждать её освобождения неограниченное время. Это означает, что приложения не должны оставлять транзакции открытыми долгое время (например, ожидая ввода пользователя).

Подход к анализу проблемы

	Выясняем уровень изоляции.

	Анализируем блокировки и возможные взаимоблокировки (deadlock).

	Придумываем решение.

Проверка на практике

	Здесь записать команды для демонстрации в консоли.