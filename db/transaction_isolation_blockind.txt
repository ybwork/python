Оглавление

	Транзакции

	Точки сохранения

	Проблемы паралельных транзакций

	Уровни изоляции

	Блокировки

	Deadlock (взаимоблокировки)

	Подход к анализу проблемы

	Проверка на практике

Транзакции

	Это операция состоящая из определённого набора действий, которые либо выполняется полностью, либо не выполняются вообще.

	Автокоммит работает автоматически по завершению запроса.

	Если мы явно начинаем транзакцию с помощью begin, то автокоммит выключается и его нужно сделать явно.

	Пока первая транзакция не снимет блок, вторая будет в режиме ожидания.

	Когда транзакция с явным уровнем изоляции завершена, то уровень изоляции возвращается в режим по умолчанию.

Точки сохранения

	У каждой транзакции есть точка сохранения (save point).

	Точка сохранения - это специальная отметка внутри транзакции, которая позволяет откатить все команды, выполненные после неё, и восстановить таким образом состояние на момент установки этой точки.

	В одной транзакции можно определить несколько точек сохранения.

	Точку сохранения делает postgres автоматом (временной промежуток можно настроить).

	Для отката к установленной точке сохранения предназначена команда ROLLBACK TO SAVEPOINT. Чтобы уничтожить точку сохранения, сохраняя изменения, произведённые после того, как она была установлена, применяется команда RELEASE SAVEPOINT.

	Стандарт SQL требует, чтобы точка сохранения уничтожалась автоматически, когда устанавливается другая точка сохранения с тем же именем.

	Если транзакция шла, потом прошла точка сохранения, а потом вырубили свет и транзакция не завершилась, то postgres автоматом перевыполнит транзакцию (важно понимать, что именно перевыполнится, а не откатится).
	
Проблемы паралельных транзакций

	Потерянное обновление

		Обе транзации делают обновление.

		Первая читает текущее значение поля, которое нужно обновить. 

		Вторая читает это же значение поля до завершения первой. 

		Получается обе при чтении получают одинаковое значение.

		В итоге первая транзакция завершается и записывает новое значение, а вторая при своём завершении перезаписывает значение первой.

		Данную проблему решает уровень изоляции Read uncommited.

	Грязное чтение

		Первая изменила данные. 

		Вторая сделала SELECT и увидела изменения первой. 

		Первая не доработала и откатилась. 

		Вторая продолжила работать с неактуальными данными и завершилась.

		Данную проблему решает уровень изоляции Read commited.

	Неповторяющееся чтение

		Первая делает SELECT и продолжает рабатать.

		Вторая делает UPDATE и завершается.

		Первая опять делает SELECT и видит совершенно другие данные.

		Данную проблему решает уровень изоляции Repeatable read.

	Фантомное чтение

		Первая делает SELECT, где считает кол-во строк и продолжает рабатать.

		Вторая делает INSERT и завершается.

		Первая опять делает SELECT, где считает кол-во строк и видит совершенно другие данные.

		Данную проблему решает уровень изоляции Serializable.

Уровни изоляции

	Уровни изоляции - это механизм субд, который позволяет избавиться от проблем паралельных транзакций.

	Уровни изоляции используют блокировки, поэтому это связанные вещи.

	Первый из них является самым слабым, последний — самым сильным, каждый последующий включает в себя все предыдущие.

	Read uncommited

		Позволяет читать другим транзакциям незакомиченные данные.

		Решает проблему потерянного обновления, потому что после изменения данных первой транзакцией, вторая транзакция может получить новые данные до их фиксации.

		В процессе работы одной транзакции другая может быть успешно завершена и сделанные ею изменения будут валидны.

	Read committed

		Позволяет читать другим транзакциям только закомиченные данные.

		В postgresql выбран по умолчанию.

		Решает проблему грязного чтения.

	Repeatable read

		Если первая транзакция читает данные и не завершилась, то вторая не может обновить эти данные.

		Решает проблему неповторяющегося чтения.

	Serializable

		Каждая транзакция срабатывает последовательно и не имеет доступа к данным, которые изменяются в другой.

		При изоляции такого уровня все транзакции обрабатываются так, как будто они все запущены последовательно.

		Решает проблему фантомного чтения.

Блокировки

	Блокировка (lock) - механизм, который позволяет транзакции захватить доступ к объекту бд.

	Понимание того как работают блокировки является ключом к написанию правильных запросов способных выполняться параллельно.

	Бывают явные (если указали сами в рамках транзакции) и неявные (postgres накладывает автоматические)

	Типы:

		Исключительная (exclusive lock) - накладывается если транзакция изменяет данные и запрещает другим транзакциям блокировать этот же объект, при этом если уже наложена совместная блокировка, то исключительную не получиться наложить.
 
		Совместная (shared lock) - накладывается если транзакция только читает данные и разрещает другим транзакциям блокировть этот же объект.

	Виды:

		На уровне строки 

			Действует только на одну строку таблицы, не ограничивая манипуляции над другими строками.

		На уровне таблицы

	SELECT FOR UPDATE берёт строки и блокирует их на обновление. При этом накладываются 2 блокировки (shared, exclusive).

	Две транзакции не могут одновременно владеть блокировками конфликтующих режимов для одной и той же таблицы.

	Одна транзакция никогда не кофликтует с собой и может сначала запросить блокировку exclusive, а share для той же таблицы.

	Если наложенная на строку блокировка не позволяет выполнить операцию, то транзакция просто ждет снятия мешающей блокировки. В случае перекрестных блокировок ждать можно долго, это deadlock.

Deadlock (взаимоблокировки)

	Deadlock (взаимоблокировка) - это ситуация, когда 2 транзакции блокируют друг друга.

	Обычно это происходит, когда мы часто используем явные блокировки.

	Например 2 транзакции делают обновление. Первая обновляет строку с id = 7 и блокирует её, вторая обновляет строку с id = 6 и следом с id = 7. Получается, что вторая транзакция будет ждать завершения первой, чтобы обновить запись с id = 7. Но в этом момент первая транзакция пытается выполнить обновления строки с id = 6 и сталкивается с тем, что ей тоже нужно ждать пока не завершиться вторая транзакция. В итоге обе транзакции ждут друг друга и получается взаимоблокировка.

	PostgreSQL самостоятельно выявляет такие ситуации и прерывает одну из транзакций. 

	Какая именно транзакция будет прервана, обычно сложно предсказать, так что рассчитывать на определённое поведение не следует.)

	Если ситуация взаимоблокировки не будет выявлена, транзакция, ожидающая блокировки на уровне таблицы или строки, будет ждать её освобождения неограниченное время. 

	Но это не нормально, потому что приложения не должны оставлять транзакции открытыми долгое время.

	Обычно лучший способ предотвращения взаимоблокировок - добиться, чтобы все приложения, обращающиеся к базе данных, запрашивали блокировки нескольких объектов в одном запросе. 

	Если заранее обеспечить такой порядок нельзя, то можно попробовать повторить прерванные транзакции.

	Примерно такие ошибки вываливается если происходит deadlock:

		ERROR: deadlock detected
		DETAIL: Process 18293 waits for ShareLock on transaction 639; blocked by process 18254.
	      Process 18293: update users set balance = balance + 10 where id = 2;
	      Process 18254: update users set balance = balance + 10 where id = 3;
		Process 18254 waits for ShareLock on transaction 640; blocked by process 18293.
		HINT: See server log for query details.
		CONTEXT: while updating tuple (0,9) in relation "users"
		STATEMENT: update users set balance = balance + 10 where id = 2;

		вторую взять на работе

Подход к анализу проблемы

	Выясняем уровень изоляции.

	Анализируем блокировки и возможные взаимоблокировки (deadlock).

	Придумываем решение.

Проверка на практике

	Отрываем 2 терминала.

	В каждом из них подключаемся к нужно базе.

		sudo -i -u postgres

		\c db_name

	В первом терминале открываем транзакцию и делаем запрос на обновление.

		begin;

		UPDATE public.accounts SET balance = balance + 100.00 WHERE acctnum = 11111;

	Во втором терминале открываем транзакцию и делаем два запроса на обновление.

		begin;

		UPDATE public.accounts SET balance = balance + 100.00 WHERE acctnum = 22222;

		UPDATE public.accounts SET balance = balance - 100.00 WHERE acctnum = 11111;

		Транзакция должна зависнуть и ждать пока выполниться первая.

	Возвращаемся в первый терминал и делаем еще один запрос на обновление.

		UPDATE public.accounts SET balance = balance - 100.00 WHERE acctnum = 22222;

		Транзакция должна зависнуть и ждать пока выполниться вторая.

	Таким образом получаем взаимоблокировку и оба терминала висят.