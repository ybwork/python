Оглавление

	Что это

	Установка

	Основы архитектуры

	Создание базы данных

	Запись

	Обновление

	Удаление

	SELECT и подзапросы

	JOIN

	UNION, INTERSECT, EXCEPT

	LIKE

	CASE

	Агрегатные функции

	EXPLAIN

	Индексы

	Транзакции

	Проблемы паралельных транзакций

	Уровни изоляции

	Блокировка

	Оптимизация

	Удаление базы данных

	DQL

	DML

	DDL

	Кластер

	Аутентификация клиентского приложения (порты)

	Логирование

	VACUUM

	Развёртывание

	Репликация

	Нюансы

	Команды

	Шпора по возможностям

	Шпора по запросам

Что это

	PostgreSQL - это объектно-реляционная система управления базами данных.

	Реляционная бд - это бд, которая позволяет обеспечить целостность данных.

	Целостность данных достигается с помощью связей таблиц.

Установка и настройка

	sudo apt-get update

	sudo apt-get install postgresql postgresql-contrib

	sudo -u postgres psql

	\password

Основы архитектуры

	PostgreSQL реализован в архитектуре клиент-сервер.

	Postgres - главный серверный процесс, который управляет файлами бд, подключениями клиентских приложений и запросами клиентов к бд.

	Клиентским приложением может быть консоль, веб сервер, графическое приложение и т.д.

	Клиент и сервер могут располагаться на разных компьютерах. В этом случае они взаимодействуют по сети TCP/IP.

	Сервер PostgreSQL может обслуживать одновременно несколько подключений клиентов. Для этого он запускает отдельный процесс для каждого подключения. При этом клиент и серверный процесс не затрагивает postgres.

Создание базы данных

	Первое, как можно проверить, есть ли у вас доступ к серверу баз данных, — это попытаться создать базу данных. 

	createdb mydb

	Создавать базы данных разрешено не всем пользователям. Если PostgreSQL отказывается создавать базы данных для вас, значит вам необходимо соответствующее разрешение.

Запись

	INSERT INTO products VALUES ('Cheese', 9.99);
	
	Лучше всегда явно указывать имена столбцов, потому что это убирает путаницу:

		INSERT INTO products (name, price) VALUES ('Cheese', 9.99);

	Для ясности можно также явно указать значения по умолчанию для отдельных столбцов или всей строки.

		INSERT INTO products (product_no, name, price) VALUES (1, 'Cheese', DEFAULT);

		INSERT INTO products DEFAULT VALUES;

	Множественная запись

		INSERT INTO products (name, price) VALUES ('Cheese', 9.99), ('Bread', 1.99), ('Milk', 2.99);

		INSERT INTO products (name, price) SELECT name, price FROM new_products

		Когда нужно добавить сразу множество строк, возможно будет лучше использовать команду COPY. Она не такая гибкая, как INSERT, но гораздо эффективнее.

	INSERT INTO products VALUES ('Cheese', 9.99) RETURNING id; - возвращает id только что добавленной строки

Обновление

	UPDATE products SET price = 10 WHERE price = 5;

	UPDATE products SET price = price * 1.10;

	UPDATE mytable SET a = 5, b = 3, c = 1 WHERE a > 0;

	UPDATE products SET price = 10 WHERE price = 5 RETURNING price; - возвращает price только что обновленной строки

Удаление

	DELETE FROM products WHERE price = 10;

	DELETE FROM products WHERE price = 10 RETURNING price; - возвращает price только что удалённой строки

	DELETE FROM products;

SELECT и подзапросы
	
	SELECT * FROM table1;

	SELECT a, b + c FROM table1;

	Псевдонимы обязательно нужно назначать подзапросам

	SELECT * FROM (my_table AS a CROSS JOIN my_table) AS b

	Подзапросы, образующие таблицы, должны заключаться в скобки

	SELECT name FROM users WHERE invoice_num = (SELECT num FROM invoices WHERE year = 2001)

	Табличные функции - это функции, выдающие набор строк. Они применяются в запросах как таблицы, представления или подзапросы в предложении FROM. Столбцы, возвращённые табличными функциями, можно включить в выражения SELECT, JOIN или WHERE

	CREATE FUNCTION getfoo(int) RETURNS SETOF foo AS $$
	    SELECT * FROM foo WHERE fooid = $1;
	$$ LANGUAGE SQL;

	SELECT * FROM getfoo(1) AS t1;

	Перед подзапросами в предложении FROM можно добавить ключевое слово LATERAL. Это позволит ссылаться в них на столбцы главного FROM.

	SELECT * FROM foo, LATERAL (SELECT * FROM bar WHERE bar.id = foo.bar_id) ss;

	Оператор EXISTS используется в предложении WHERE с подзапросом. 

	Он проверяет, возвращает ли подзапрос строки в результате. 

	Если да, EXISTS вернёт true, если нет, то false.

	SELECT col1 FROM tab1 WHERE EXISTS (SELECT 1 FROM tab2 WHERE col2 = tab1.col2);

	Этот пример выдаёт максимум одну строку для каждой строки в tab1, даже если в tab2 ей соответствуют несколько строк.

	Оператор IN сравнивает каждое значение, которое вернул подзапрос со значением в условии WHERE.

	SELECT col1 FROM tab1 WHERE name IN (SELECT 1 FROM tab2 WHERE col2 = tab1.col2);

	Оператор NOT IN говорит, что значение в условии WHERE не должно соответствовать значения из подзапроса.

	SELECT col1 FROM tab1 WHERE name NOT IN (SELECT 1 FROM tab2 WHERE col2 = tab1.col2);

	Оператор ALL сначала выбрать все значения из подзапроса, а потом сравнить каждое из них с условие заданным в WHERE главного запроса.

	SELECT name FROM customers WHERE rating > ALL (SELECT rating FROM customers WHERE city = Rome)

GROUP BY и HAVING

	GROUP BY позволяет группировать строки.

	GROUP BY объединяет значения в одну группу при совпадении значений в столбцах.

	id symbol

	1  a

	2  b

	3  b

	SELECT * FROM test GROUP BY symbol;

	id symbol

	1  a

	2  b

	В таблице с группировкой столбцы, не включённые в список GROUP BY, можно использовать только в агрегатных выражениях.

	SELECT x, sum(y) FROM test1 GROUP BY x;

	GROUP BY является неотъемлемой часть запросов с использованием array_agg.

	Если в запросе есть вызовы агрегатных функций, но нет предложения GROUP BY, строки всё равно будут группироваться.

	HAVING позволяет оставить только нужные строки после группировки.

	В предложении HAVING могут использоваться и группирующие выражения, и выражения, не участвующие в группировке (в этом случае это должны быть агрегирующие функции).

	SELECT x, sum(y) FROM test1 GROUP BY x HAVING sum(y) > 3;

	SELECT x, sum(y) FROM test1 GROUP BY x HAVING x < 'c';

JOIN

	Позволяет соединять таблицы.

	При использовании JOIN использование слова лова INNER и OUTER необязательны.

	По умолчанию подразумевается INNER - внутреннее соединение, а при указании LEFT, RIGHT и FULL - внешнее соединение.

	CROSS JOIN - образует все возможные сочетания строк из T1 и T2.

	INNER JOIN - в результате будут только строки чьи значения чётко соответствуют условию.

	LEFT JOIN - сначала выполняется внутреннее соединение, затем в результат добавляются все строки из T1, которым не соответствуют никакие строки в T2, а вместо значений столбцов T2 вставляются NULL.

	RIGHT JOIN - сначала выполняется внутреннее соединение, затем в результат добавляются все строки из T2, которым не соответствуют никакие строки в T1, а вместо значений столбцов T1 вставляются NULL.

	FULL JOIN - сначала выполняется внутреннее соединение, затем в результат добавляются все строки из T1, которым не соответствуют никакие строки в T2, а вместо значений столбцов T2 вставляются NULL, затем в результат включаются все строки из T2, которым не соответствуют никакие строки в T1, а вместо значений столбцов T1 вставляются NULL.

	USING — это сокращённая запись условия ON, полезная, когда с обеих сторон соединения столбцы имеют одинаковые имена. USING (a, b) формирует условие ON T1.a = T2.a AND T1.b = T2.b.

	SELECT * FROM t1 JOIN t2 ON t1.num = t2.num;

	SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num;

DISTINCT

	Исключает дублирующиеся строки.

	Две строки считаются разными, если они содержат различные значения минимум в одном столбце. При этом значения NULL полагаются равными.

	SELECT DISTINCT * FROM t1

UNION, INTERSECT, EXCEPT

	Позволяют делать объединение, пересечение и вычитание запросов.

	Для удачного выполнения каждый запрос должен иметь одинаковое число столбцов и эти столбцы должны быть совместимых типов.

	запрос1 UNION [ALL] запрос2

	запрос1 INTERSECT [ALL] запрос2

	запрос1 EXCEPT [ALL] запрос2

	UNION - добавляет результаты второго запроса к результатам первого, при этом порядок возвращаемых строк не гарантируется.

	INTERSECT - возвращает все строки из первого и второго запроса.

	EXCEPT - возвращает все строки, которые есть в результате первого запроса, но отсутствуют в результате второго.

	Если не указать параметр ALL во всех трёх типах, то будут убраны все дублирующиеся строки.

LIKE

	Позволяет искать текст по заданному шаблону.

	Поиск с LIKE безопаснее использовать с недоверенными источниками шаблонов поиска.

	При проверке по шаблону LIKE всегда рассматривается вся строка. 

	Поэтому, если нужно найти последовательность символов где-то в середине строки, шаблон должен начинаться и заканчиваться знаками процента.

	Чтобы найти в строке буквальное вхождение знака процента или подчёркивания, перед соответствующим символом в шаблоне нужно добавить спецсимвол. 

	По умолчанию в качестве спецсимвола выбрана обратная косая черта.

	Чтобы включить спецсимвол в шаблон поиска, продублируйте его.

	Так же есть оператор NOT LIKE.

	SELECT * FROM users LIKE 'Mike'

	SELECT * FROM users LIKE '%Mike%'

CASE

	Позволяет исползовать условия в запросах. (эквивалент if/else)

	SELECT a,
       CASE WHEN a=1 THEN 'one'
            WHEN a=2 THEN 'two'
            ELSE 'other'
       END
    FROM test;

Агрегатные функции

	Позволяют вычислить одно значение для группы значений для одного столбца (минимальное значение столбца num).

	array_agg - значения, включая NULL, объединяются в массив

	avg - среднее значение из всех

	bool_and - true, если все значения равны true, и false в противном случае

	bool_or - true, если хотя бы одно значение равно true, и false в противном случае

	count - количество строк

	json_agg - значения объединяются в массив формата JSON

	json_object_agg - агрегирует пары имя/значение в виде объекта JSON

	max - максимальное значение среди всех значений

	min - минимальное значение среди всех значений

	string_agg - данные складываются в строку через заданный разделитель (аналог GROUP_CONCAT)

	sum - общая сумма всех значений стоблца

	Следует заметить, что за исключением count, все эти функции возвращают NULL, если для них не была выбрана ни одна строка.

EXPLAIN

	Выполняя запрос, PostgreSQL разрабатывает для него план запроса.

	Выбор правильного плана запроса крайне важен для хорошей производительности, поэтому в системе работает сложный планировщик, задача которого подобрать хороший план.

	Узнать, какой план был выбран для какого-либо запроса, можно с помощью команды EXPLAIN.

	EXPLAIN SELECT * FROM tenk1;	

		Seq Scan on tenk1  (cost=0.00..458.00 rows=10000 width=244)

		0.00 - приблизительная стоимость запуска (время, которое проходит, прежде чем начнётся вывод данных, например для сортирующего узла это время сортировки)

		458.00 - приблизительная общая стоимость операции

	EXPLAIN SELECT * FROM tenk1 WHERE unique1 < 7000;

		Seq Scan on tenk1  (cost=0.00..483.00 rows=7001 width=244)

	EXPLAIN SELECT * FROM tenk1 WHERE unique1 < 100 AND stringu1 = 'xxx';

		Bitmap Heap Scan on tenk1  (cost=5.01..229.40 rows=1 width=244)

			...

			Bitmap Index Scan on tenk1_unique1 (cost=0.00..5.04 rows=101 width=0)

		Общие стоимости складываются?

	Точность оценок планировщика можно проверить, используя команду EXPLAIN с параметром ANALYZE. С этим параметром EXPLAIN на самом деле выполняет запрос, а затем выводит фактическое число строк и время выполнения.

		EXPLAIN ANALYZE SELECT * FROM tenk1 t1, tenk2 t2 WHERE t1.unique1 < 10 AND t1.unique2 = t2.unique2;

			Planning time: 0.181 ms 

			Execution time: 0.501 ms

	Не забывайте, что EXPLAIN ANALYZE действительно выполняет запрос, хотя его результаты могут не показываться. 

	Если вы хотите проанализировать запрос, изменяющий данные, но при этом сохранить прежние данные таблицы, вы можете откатить транзакцию после запроса.

		BEGIN;

			EXPLAIN ANALYZE UPDATE tenk1 SET hundred = hundred + 1 WHERE unique1 < 100;

		ROLLBACK;

	Время выполнения, измеренное командой EXPLAIN ANALYZE, может значительно отличаться от времени выполнения того же запроса в обычном режиме. Тому есть две основных причины. Во-первых, так как при анализе никакие строки результата не передаются клиенту, время ввода/вывода и передачи по сети не учитывается. Во-вторых, может быть существенной дополнительная нагрузка, связанная с функциями измерений EXPLAIN ANALYZE.

	Не следует полагать, что выводы, полученные для игрушечной таблицы, будут применимы и для настоящих больших таблиц.

Индексы

	Индекс - это объект базы данных, который позволяет увеличить производительность при работе с ней.

	Предположим что мы хотим из таблицы заказчиков найти заказчика с номером 999. 

	Так как строки бд не упорядочены, субд будет просматривать всю таблицу, строку за строкой, проверяя каждый раз значение поля num на равенство значению 999.

	Однако, если бы имелся индекс в поле num, то программа могла бы выйти на номер 999 прямо по индексу.

	Использование индекса несколько замедляет операции модификации DML (такие как INSERT и DELETE), а сам индекс занимает объем памяти.

	По умолчанию команда CREATE INDEX создаёт индексы типа B-дерево, эффективные в большинстве случаев.

	B-деревья могут работать в условиях на равенство, проверке диапазонов и сортировки.  

	Хеш-индексы работают только с простыми условиями равенства.

	GiST-индексы могут применяться в работе с геометрическими данными.

	SP-GiST позволяют работать с данными для точек в двумерном пространстве.

	GIN-индексы могут помочь в работе с массивами.

	Индексы можно создавать и по нескольким столбцам таблицы. Такие индексы называются составными. Используются, когда например нужно часто делать выборку типа: 

		...major = константа AND minor = константа;

		В таком случае составной индекс можно повесить на поля major и minor.

Транзакции

	Это операция состоящая из определённого набора действий, которые либо выполняется полностью, либо не выполняются вообще.

	Автокоммит работает автоматически по завершению запроса.

	Если мы явно начинаем транзакцию с помощью begin, то автокоммит выключается и его нужно сделать яано.

	Пока первая транзакция не снимет блок, вторая будет в режиме ожидания.

	Когда транзакция с явным уровнем изоляции завершена, то уровень изоляции возвращается в режим по умолчанию.

	У каждой транзакции есть точка сохранения (save point).

Проблемы паралельных транзакций

	Потерянное обновление

		Обе транзации делают обновление. 

		Первая читает текущее значение поля, которое нужно обновить. 

		Вторая читает это же значение поля до завершения первой. 

		Получается обе при чтении получают одинаковое значение.

		В итоге первая транзакция завершается и записывает новое значение, а вторая при своём завершении перезаписывает значение первой.

	Грязное чтение

		Первая изменила данные, пошла дальше. 

		Вторая увидела изменения первой. Первая не доработала и откатилась. 

		Вторая продолжила работать с неактуальными данными и завершилась.

	Неповторяющееся чтение

		В первой транзакции происходит две одинаковые операции выбора значения поля.

		После первой операции выбора (первой транзакцией), вторая транзакция изменяет значение выбираемого поля.

		При второй операции выбора первой транзакцией мы получаем совсем другое значение поля.

	Чтение фантомов

		В первой транзакции происходит две одинаковые операции выбора значения поля.

		После первой операции выбора (первой транзакцией), вторая транзакция добавляет новую запись в таблицу.

		При второй операции выбора первой транзакцией мы получаем совсем другое значение поля.

		Отличие чтения фантомов от неповторяющегося чтения в том, что при фантомном создаётся новая запись, а при неповторяющемся запись удаляется или изменяется.

Уровни изоляции

	Уровни изоляции - это механизм субд, который позволяет избавиться от проблем паралельных транзакций.

	В процессе рассуждения помнить о блокировках.

	Read committed

		Позволяет читать другим транзакциям только закомиченные данные.

		В postgresql выбран по умолчанию.

		Решает проблему грязного чтения.

		В процессе работы одной транзакции другая может быть успешно завершена и сделанные ею изменения зафиксированы.

	Read uncommited

		Позволяет читать другим транзакциям незакомиченные данные.

		Решает проблему потерянного обновления, потому что после изменения данных первой транзакцией, вторая транзакция может получить новые данные до их фиксации.

		В процессе работы одной транзакции другая может быть успешно завершена и сделанные ею изменения зафиксированы.

	Repeatable read

		Повторяемое чтение.

		Позволяет получить доступ только к закоммиченным данным.

		Решает проблему неповторяющегося чтения. Как?

	Serializable

		Каждая транзакция срабатывает последовательно и не имеет доступа к данным, которые изменяются в другой.

		При изоляции такого уровня все транзакции обрабатываются так, как будто они все запущены последовательно.

Блокировки.

	Блокировка (lock) - механизм, который позволяет транзакции захватить доступ к объекту бд.

	Бывают явные (если указали сами в рамках транзакции) и неявные (postgres накладывает автоматические)

	Если обращаемся к разным строкам таблицы, то каждая противоположная транзакция получит доступ к противоположной строке и блокировки не будет.

	SELECT FOR UPDATE берёт строки и блокирует их на обновление. При этом накладываются 2 блокировки (shared, exclusive)

	Типы:

		Исключительная (exclusive lock) - накладывается если транзакция изменяет данные и запрещает другим транзакциям блокировать этот же объект
 
		Совместная (shared lock) - накладывается если транзакция только читает данные и разрещает другим транзакциям блокировть этот же объект

	Виды:

		На уровне строки 

			Действует только на одну строку таблицы, не ограничивая манипуляции над другими строками  

		На уровне таблицы

	Две транзакции не могут одновременно владеть блокировками конфликтующих режимов для одной и той же таблицы.

	Одна транзакция никогда не кофликтует с собой и может сначала запросить блокировку exclusive, а share для той же таблицы.

Оптимизация

	Выносить сервер базы данных на отдельную машину, где будет только база данных.

	Сначала обновляться до новой версии и смотреть на производительность.

	Пользуемся утилитой pg_tune, которая собирает файл конфига для postgres под конкретную машину.

Удаление базы данных

	dropdb mydb

DQL

	Data Query Language - язык запросов, составная часть SQL. Состоит из единственной команды SELECT.

	Команда SELECT позволяет получить данные из бд.

	С командой SELECT можно использовать следующие команды:

	FROM - из какой таблице берём данные

	WHERE - условие по которому выбираются данные

	JOIN - присоединение таблиц

	ON - условие для JOIN

	USING - условие JOIN если имена полей разных таблиц одинаковы (USING (a, b) формирует условие ON T1.a = T2.a AND T1.b = T2.b)

	GROUP BY - группирует строки таблицы, объединяя их в одну группу при совпадении значений (например в таблице есть product_id и их значения совпадают)

	HAVING - позволяет задать условие после группировки и оставить только нужные группы строк

	ORDER BY - позволяет задать порядок выбора данных (по убыванию DESC или по возрастанию ASC)

	UNION - обьединяет вывод двух или более SQL запросов в единый набор строк и столбцов. Все запросы выполняются независимо друг от друга, а уже вывод их — обьединяется. Столбцы вывода должны быть совместимы для объединения.

	Subqueries - позволяют сделать один запрос внутри другого.

DML

	Data Manipulation Language - язык запросов для манипулирования данными, составная часть SQL. 

	Включает в себя такие команды, как: 

	INSERT - добавляет данные в таблицу 

	UPDATE - обновляет данные в таблице 

	DELETE - удаляет данные из таблицы

DDL

	Data Definition Language - язык описания данных.

	У базы данных есть таблицы.

	У таблиц есть столбцы.

	Каждый имеет свой тип данных.

	Для каждого типа данных можно задать свою длинну.

	В каждой таблице есть записи, они же строки.

	Уникальность каждой строки гарантирует первичный ключ, который имеет уникальное, не повторяющееся значение

	Целостность данных гарантируют внешние ключи, которые связывают одну таблицу с другой.

	С помощью DDL можно описать, создать и модифицировать структуру БД.

Кластер

	Это набор баз данных, которые управляются одним экземпляром сервера.

	С точки зрения файловой системы, кластер баз данных представляет собой один каталог, в котором будут храниться все данные.

	Находится в etc/postgresql/10/main

Аутентификация клиентского приложения

	Клиентское приложение - это наша программа, которая подключается к серверу баз данных.

	Аутентификация управляется конфигурационным файлом pg_hba.conf (host-based authentication)

	Файл pg_hba.conf расположен в каталоге с данными кластера.

	В файле pg_hba.conf прописываются настройки аутентификации.

	local база  пользователь  метод-аутентификации  [параметры-аутентификации]

	host база пользователь IP-адрес IP-маска метод-аутентификации [параметры-аутентификации]

	Позволяет любому пользователю локальной системы подключаться ко всем базам данных
	TYPE  DATABASE  USER  ADDRESS  METHOD
	local all       all            rust

	Позволяет любому пользователю компьютера 192.168.12.10 подключаться к базе данных postgres, если он передаёт правильный пароль.
	TYPE  DATABASE  USER  ADDRESS           METHOD
	host  postgres  all   192.168.12.10/32  scram-sha-256

Логирование

	Позволяет делать мониторинг состояния сервера бд.

	Здесь и возможность мониторить выполнение отдельно взятых запросов и общей нагрузки на бд и отслеживание ошибок.

	PostgreSQL поддерживает несколько методов протоколирования сообщений сервера: stderr, csvlog и syslog.

	По умолчанию используется stderr.

	В качестве значения log_destination указывается один или несколько методов протоколирования, разделённых запятыми.

	Если в log_destination включено значение csvlog, то протоколирование ведётся в формате CSV.

	Slow log - мониторинг медленных запросов.

	Настройка log_min_duration_statement задается в миллисекундах, и логирует все запросы к базе, которые исполнялись дольше заданного значения. Данную настройку можно установить в файле конфигурации postgresql.conf

VACUUM

	VACUUM высвобождает пространство, занимаемое «мёртвыми» кортежами. 

	При обычных операциях PostgreSQL кортежи, удалённые или устаревшие в результате обновления, физически не удаляются из таблицы. Они сохраняются в ней, пока не будет выполнена команда VACUUM. 

	Таким образом, периодически необходимо выполнять VACUUM, особенно для часто изменяемых таблиц.

Развёртывание

	Обратить внимание на локаль. Если на машине не стоит нужной локали и мы установили postgres, где она есть, то может возникнуть конфликт.

	Поэтому сначала уставливаем локаль на машину, а потом postgres.

Репликация
	
	Один из лучших вариантов master slawe.

	...

Нюансы

	Не забывать при запросе писать к какой базе обращаемся.

Команды

	\dt - показывает список таблиц внутри базы

	createdb mydb - создаёт бд

	sudo -i -u postgres - переключение на аккаунт (в нём создаются пользователи и выполняются другие действия)

		dropdb events;

		dropuser yetbetter;

		createuser -P -s -e yetbetter - создаёт суперпользователя с предустановленным паролем

		createuser --interactive joe

	sudo /etc/init.d/postgresql restart - перезапуск postgresql

	psql - доступ к командной строке

	exit - выход из командной строки

	\q - выход из аккаунта

	ALTER USER postgres PASSWORD ''; - сменить пароль для пользователя

	CREATE USER yetbetter WITH PASSWORD 'asdf1234'; - создаёт пользователя

	CREATE USER davide WITH PASSWORD 'jw8s0F4';

	CREATE DATABASE ctw_development OWNER yetbetter;

	DROP USER yetbetter; - удаляет пользователя

	\du - показыввает таблицу с пользователями

	pg_dump dbname > outfile

	\list - показывает все базы

	psql -> \c db_name (коннект с базой) -> \dt (показывает таблицы) -> SELECT id FROM organizers;

	psql ctw_development < map-db-3008.dump; - делает дамп

	cat /var/lib/postgresql/map-db-3008.dump | psql -d ctw_development - делает дамп

	dropdb ctw_development

	createdb ctw_development (CREATE DATABASE dbname;)

	\d table_name - показывает все колонки в таблице
	
Шпора по возможностям

	Условия

	Подзапросы

	Соединения

	Группировка

	Агрегация

Шпора по запросам

	SELECT name FROM users

	SELECT name FROM users WHERE city = London

	SELECT DISTINCT num FROM orders

	SELECT name FROM users WHERE city = San Jose AND/OR rating > 200


	SELECT name FROM users WHERE NOT (city = San Jose)

	SELECT name FROM users WHERE name IN (SELECT name FROM customers WHERE id = users.id)

	SELECT name FROM users WHERE name NOT IN (SELECT name FROM customers WHERE rating < 100)


	SELECT name FROM users WHERE num BETWEEN 10 AND 12

	SELECT name FROM users WHERE name LIKE '%Mike%'

	SELECT name FROM customers WHERE rating > ALL (SELECT rating FROM customers WHERE city = Rome)


	SELECT name FROM customers GROUP BY rating

	SELECT name FROM customers GROUP BY rating HAVING SUM(money) > 1000


	SELECT u.name, c.mark FROM users u JOIN cars c ON u.car_id = c.id

	SELECT u.name, c.mark FROM users u LEFT JOIN cars c ON u.car_id = c.id

	SELECT u.name, c.mark FROM users u RIGHT JOIN cars c ON u.car_id = c.id

	SELECT u.name, c.mark FROM users u FULL JOIN cars c ON u.car_id = c.id


	SELECT num, name, price FROM customers WHERE EXISTS (SELECT id FROM customers WHERE city = San Jose)

	SELECT num, name, price FROM customers WHERE NOT EXISTS (SELECT id FROM customers WHERE city = San Jose)


	SELECT name FROM salespeople WHERE city = Rome UNION SELECT name FROM customers WHERE city = Rome


	SELECT a,
       CASE WHEN a=1 THEN 'one'
            WHEN a=2 THEN 'two'
            ELSE 'other'
       END
    FROM test













	

		