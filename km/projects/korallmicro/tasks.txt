Оглавление

	На сайте отображается товар, который для него не предназначен #19161

На сайте отображается товар, который для него не предназначен #19161

	Раньше был товар 26491

	На 19 августа товара 1987

	Галочка "Не для интернет магазина" пишется в поле "НеДляРозницы"

	НеДляРозницы == не для кораллмикро

	Галочка "Не для интернет магазина" == не для кораллмикро

    is_not_for_retail == не для кораллмикро

    'is_for_retail': not ones_nomenclature['is_not_for_retail']

    from raw_processing.models import *

    	Nomenclature.objects.get(code=1987).is_not_for_retail

		products = Nomenclature.objects.filter(is_not_for_retail=True)

		product_code_list = products.values_list('code', flat=True)

		from korallmicro.models import *

		korall_products = Products.objects.filter(id__in=list(product_code_list))

    Можно ли добавить один и тот же продукт в каталоги snr и korallmicro?

        Да, можно.

    Как товар попадает в таблицу product в базе korallmicro?

		from korallmicro.tasks import *

        def sync_catalogs_and_products(

    Как выполнить задачу, которая пишет товар в таблицу product в базе korallmicro?

    	from catalog.tasks import *

    	sync_korallmicro.delay()

    Как выполнить задачу, которая пишет товар в таблицу product в базе snr?

        from snr.tasks import *

    	sync.delay(site_models='sales_base_models.models', shop_type='snr_new')

   	Какой код берет товар, которого не должно быть?

	    new_products_codes = set([i for i, in Products.objects.filter(
	        distributions__catalog__type=shop_type,
	        distributions__catalog__is_available=True
	    ).distinct().values_list('code')])

	    SELECT DISTINCT `catalog_products`.`uid`, `catalog_products`.`code`, `catalog_products`.`art`, `catalog_products`.`name`, `catalog_products`.`translit`, `catalog_products`.`new`, `catalog_products`.`create_date` FROM `catalog_products` INNER JOIN `catalog_distributions` ON (`catalog_products`.`code` = `catalog_distributions`.`product_id`) INNER JOIN `catalog_catalog` ON (`catalog_distributions`.`catalog_id` = `catalog_catalog`.`id`) WHERE (`catalog_catalog`.`type` = korallmicro AND `catalog_catalog`.`is_available` = True)

	    Он берет продукты через связь каталога и продукта, которая находиться в таблице catalog_distributions.

	    На 22 августа 2019 в этой таблице есть 2 записи. Первая связывает данный продукт с магазином кораллмикро, а вторая с снр.

	    В этом и есть ошибка, поэтому нужно смотреть в сторону синхронизации magic - 1с, а именно создание связи catalog_distributions.

	Какой код выгружает данные в таблицы catalog_products, catalog_catalog, catalog_distributions?

		catalog/tasks.py

			def sync(

		Для запуска

			from catalog.tasks import *

			sync_shop.delay(shop_type='korallmicro')

	Откуда код выгружает данные  таблицы catalog_products, catalog_catalog, catalog_distributions?

		Из таблицы ones_products

	Как данные попадают в таблицу ones_products?

		После выполнения таска sync_db

	Как запустить таск sync_db?

		sync_db

	Разбор метода sync

		В таблице ones_products действительно нет данного продукта.

			ones_products = dict([
		        (i['uid'], i) for i in OProducts.objects.get_for_sale_and_retail(
		            shop_type=shop_type
		        ).values('code', 'uid', 'name','is_new', 'create_date')
		    ])

		Синхронизация каталога

			Здесь нас интересует только обновление, потому uid каталога нет для других операций.

			Обновления прошли успешно.

		Синхронизация продукта

			В таблице catalog_products этот продукт есть

				products = dict([
			        (i['uid'], i) for i in Products.objects.all().values('code', 'uid',
			                                                             'name', 'new')
			    ])
			    products_uuids = set(products.keys())

			Таким образом данный продукт помечен на удаление из таблицы catalog_products

				'636b3a53-b1fd-11e2-93f1-002655df3ac1' in delete_products = True

			Удаление продукта из таблицы catalog_products проходит успешно.

			Добавление и изменение продукта нас не интересуют, потому что его uid нет для этих операция

				'636b3a53-b1fd-11e2-93f1-002655df3ac1' in add_products = False

				'636b3a53-b1fd-11e2-93f1-002655df3ac1' in change_products = False

		Синхронизация distributions

			Удаление работает неверно, потому что из таблицы catalog_distributions не удаляется связь catalog_id - product_id, и получается что товар привязан к каталогу коралла и снр, хотя должен быть привязан только к снр.

			Соответсвенно при синхронизации magic - korall, когда выполняется таск sync_korallmicro, товар попадает в бд korallmicro.

			Запрос, который удаляет связи из catalog_distributions:

				Distributions.objects.filter(catalog__uid__in=delete_distributions_catalog_uuids).delete()

				Искать, как catalog__uid__in=delete_distributions_catalog_uuids).delete()

	Где посмотреть текущеее состояние товара в 1с?

		В бд 1_c_8_raw, таблица "Номенклатура".

		SELECT * FROM 1C_8_RAW.Номенклатура where Код = 1987;

	Как поменять галочку без 1с?

		Подключить локально базу 1_c_8_raw.

		from raw_processing.models import *

		Nomenclature.objects.using('1c_8_raw').filter(code=1987, is_not_for_retail=True, is_not_for_snr=False).update(is_not_for_retail=False)

	Как проверить изменения галочки в 1с?

		Запустить полную синхронизацию 1c - magic.

		Должен быть запущен наш локальный брокер и magic.

		Из magic посылаем сигнал - bin/celery call -A app_celery full_ones_sync_send_signal --queue=system

	Как удалить и вернуть лишнюю связь из catalog_distributions?

		from catalog.models import *

		Distributions.objects.filter(product_id=1987, catalog_id=281904).delete()

		Distributions.objects.filter(catalog_id=281904).delete()

		Distributions.objects.create(product_id=1987, catalog_id=281904, manual=True)

	Как удалить все связи по продуктам и поиграться с галочками в 1с?

		from catalog.models import *

		Distributions.objects.filter(product_id=1987, catalog_id__in=[281904, 318326]).delete()

		Catalog.objects.filter(pk__in=[281904, 318326]).delete()

		Products.objects.filter(code=1987).delete()


		from ones.models import *
		Products.objects.filter(code=1987).delete()


		from korallmicro.models import *

		Products.objects.filter(id=1987).delete()


		from sales_base_models.models import *

		Products.objects.filter(id=1987).delete()

	Как добавить нужную связь категории с продуктом в бд 1C_8_RAW?

		from raw_processing.models import *

		DistributionOnlineStore.objects.using('1c_8_raw').create(
			group_online_store_uid='658915e3-f8c6-11e1-908d-002655df3ac1',
			nomenclature_uid='636b3a53-b1fd-11e2-93f1-002655df3ac1'
		)

	Как в бд 1C_8_RAW найти товары без категорий?

		SELECT 

			Код 

		FROM 

			1C_8_RAW.Номенклатура 

		WHERE 

			uid 

		NOT IN (
			SELECT 
				distinct Номенклатура
			FROM 1C_8_RAW.СвязиКаталоговИнтернетМагазина
		) 
		AND 
			НеДляПродажи = 0
		AND 
			СнятаСПродажи = 0 
		AND
			НеДляРозницы = 1
		AND 
			НеДляСНР = 0;

	На 21 августа

		В catalog_distributions две связанные записи по продукту с кодом 1987.

		Одна запись для коралла, вторая для снр.

		Поэтому, когда в таске sync_shop для коралла идет выборка продуктов на добавление, не нужный продукт выгружается в базу коралла.

	На 23 августа

		При смене галочки НеДляРозницы (не для коралла), после таска sync_db у продукта не обновляется поле is_for_retail (не для коралла) в таблице ones_products, то есть одно должно стать 0, а стоит 1.

		Причина пока не найдена.

	На 26 августа

		При смене галочки НеДляРозницы (не для коралла), после таска sync_db у продукта обновляется поле is_for_retail (не для коралла) в таблице ones_products, но продукт всеравно попадает в базу коралла.

		Это происходит потому что в бд magic в таблице catalog_distributions не удаляется одна из связанных записей по продукту с кодом 1987, которая принадлежит каталогу коралла.

	На 28 августа

		Группы и каталоги это одно и тоже.

		GroupsOnlineStore == КаталогиИнтернетМагазина

	На 29 августа

		Каталога ('658915e3-f8c6-11e1-908d-002655df3ac1') светильники для кораллмикро нет в синхронизации если в ones_products стоит is_for_retail = 0, потому что он уже есть в catalog_distributions

		Если удалить все связанные записи по каталогу ('658915e3-f8c6-11e1-908d-002655df3ac1') светильники, то католог появится в синхронизации

		Продукта с uid '636b3a53-b1fd-11e2-93f1-002655df3ac1' нет в:

			ones_distributions[group_uuid]

			product_uuids = get_product_uuids_for_sale(
	            ones_distributions[group_uuid],
	            shop_type=shop_type,
	            vtb_pks=rules.get(group_uuid, None)
	        )

	    В бд 1C_8_RAW нет связи категории с продуктом.

			SELECT 

				* 

			FROM 

				1C_8_RAW.СвязиКаталоговИнтернетМагазина 

			WHERE 

				КаталогИнтернетМагазина = '658915e3-f8c6-11e1-908d-002655df3ac1' 

			AND 

				Номенклатура = '636b3a53-b1fd-11e2-93f1-002655df3ac1';

		В связи с этим после синхронизации в magic остается связь категория - продукт и он попадает на коралл. При этом не срабатывает функционал с галочкой.

	Причина возникновения

		Это происходит потому что данный товар отвязан от категории в 1c.

		Если говорить в терминах 1с, то номеклатура не имеет связи с каталогом.

			SELECT 

				* 

			FROM 

				1C_8_RAW.СвязиКаталоговИнтернетМагазина 

			WHERE 

				КаталогИнтернетМагазина = '658915e3-f8c6-11e1-908d-002655df3ac1' 

			AND 

				Номенклатура = '636b3a53-b1fd-11e2-93f1-002655df3ac1';

		В связи с этим после синхронизации в magic остается связь категория - продукт и он попадает на коралл. При этом не срабатывает функционал с галочкой.

	Варианты решения

		Руками

			- привязать номенклатуру к каталогу в 1с

			- сообщить о проблеме в web сектор, передав артикулы продуктов

			- в бд magic удалить из таблицы catalog_distributions связь catalog_id/product_id, где product_id == артикул продукта

			- подождать пока пройдет полная синхронизаци magic с 1с

		Валидация

			Нет смысла

				Валидировать привязку, отвязку товара к каталогу в magic и 1с, потому что на этапе создания товар может быть без каталога.

			Есть синхронизация категорий, продуктов и связи категория - продукт

			Если продукт есть в magic, но он не привязан к каталогу в 1с, то это неправильно.
			
			Есть смысл

				В ходе синхронизации проверять привязан ли товар к категории. Если нет, то собирать все такие товары и информировать всех ответственных.