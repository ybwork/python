Оглавление

	Общая инфа

	Смена шаблона у Вид/Подвид

    Проблема с обновлением слепков

    Товары без фото #18127

    Ошибка при синхронизации фильтров

    Валидация карточки товара

    Ошибочные карточки при формировнии кеша ЯМ

    Необходимо получить фото товаров с нашего СДН, по следующим критериям

    После подтверждения карточек товара они не появились на боевом

    Пересекающийся товар в неактивных акциях

    Integrity Error в синхронизации между magic и 1c

    Проблема с обработкой изображений с помощью PIL

    Когда карточка становится актуальной

    Выгодные предложения

    Не приходят письма если возникает ошибки при проведении карточек товара

    Проблема с выгодными предложениями magic

    Проблема с синхронизацией

    Проблема с офферами и сегментом

    Доработать функционал выгодных предложений на предмет отвязывния акции #19972

Общая инфа

	В magic хранится дополнительная информация по товару, которая не должна храниться в 1С (в т.ч. карточки товаров)

Смена шаблона у Вид/Подвид

	На 28.02.2019 работает так

		Есть карточка товара, модель ProductCard.

		В карточке товара находится полное описание товара.

		У карточки товара есть вид-тип (ноутбук-ультрабук), модель Kind.

		У вида-типа есть шаблон, модель Template. Для связи шаблона с видом-типом используется модель Property.

		У шаблона есть атрибуты, модель TemplateEntry. Этот набор атрибутов нужен для того, чтобы было понятно, какие атрибуты имеет карточка товара.

		Карточка товара имеет значения атрибутов. Смотреть модели Attribute, AttributeOptions, AttributeOptionValue.

		Значения атрибутов для карточки добавляет пользователь после создания карточки товара, при её редактировании.

		Пользователь может изменить шаблон для вида-типа в 1С и в magic (раздел "Свойства").

		Когда пользователь меняет шаблон у вида-типа в magic (раздел "Свойства"), то весь набор атрибутов у карточки товара тоже меняется. Потому что вид-тип привязан к карточке товара. Соответсвенно это приводит к тому, что все значения атрибутов карточки товара теряются.

	Варианты работы от Глубокова

		1. Когда в 1С заведен новый вид-тип в данном случае ничего не надо делать, т.к. у нового вида-типа, нет никакого шаблона.

		2. Смена шаблона в magic

			пример: http://magic.km-union.ru/cards/property/56/change/?_changelist_filters=q%3D%25D0%25BD%25D0%25BE%25D1%2583%25D1%2582

			Случай, когда я меняю привязку шаблона, к определенному виду-типу.

			В данном случае, должно пройти сравнение нового и старого шаблона, проверка всех совпадающих значений атрибутов, а по не совпадающим, приходило бы уведомление, по каким не прошла проверка.

		3. Переименовывание вид/подвид в 1С

			Тут надо ответ от вас, что произойдет в данному случае?

			Появится в magic, новая связка вид-тип или поменяется уже существующая, с сохранением привязки шаблона и карточек товара!

				Судя по коду появится новая связка вид-тип - (modules/cards/tasks.py/def sync_kinds)

			Если это второй случай, то должны пройти все те же процедуры, что описаны во втором пункте.

			Для 2 и 3 пункта, если поменялся шаблон, то карточки товаром, которые переподтвердились автоматически, им так же должен быть обновлен слепок на обоих сайтах.

	Шаблон и его атрибуты

		TemplateAdmin -> add_to_group_json -> template.groups.create(position=position, parent=group, options=attribute) - привязка атрибута к шаблону, пишется TemplateEntry

	Задача

		При смене шаблона у вида-типа в magic и/или 1С нужно:

			значения совпадающих атрибутов сохранялись 

			карточки товара у которых изменился шаблон помечались, как не актуальные

			администратор получал уведомление о смене шаблонов у карточек товара

				текст письма при смене шаблона, должен содержать: код карточки товара (должны быть кликабельным), имя карточки товара, смена шаблона "с/на" какой (должны быть кликабельными), несовпавщие атрибуты

		Когда шаблон меняется в 1С magic узнает об этом в момент синхронизации. Смотреть задачу check_kind_id_in_cards в modules/cards/tasks.py 

	Отображение атрибутов карточки товара

		Все поля формы берутся через метод get_preview_template_fields модели Kind и добавляются в методе get_form класса ProductCardAdmin.

		    try:
                template = obj.kind.template
            except Template.DoesNotExist:
                return form

            if template:
                form.base_fields.update(template.get_fields(obj))

    Тесты

        Для работы тестов нужно закоментировать в модели Profile поля user и content_type.

    Таски

    	Для запуска таска, который отрабатывает каждый день в 7-мь с чем то и переносит атрибуты карточки товара, выполнять 

    		bin/celery -A app_celery call sync_brands_kinds_in_actual_cards --queue system

Проблема с обновлением слепков refs #18150

    У некоторых карточек товара нет бренда.

    Бренды хранятся в отдельной таблице.

    После того, как карточка товара проверена, создается слепок. Модель ProductCardDescription, сигнал update_description_and_previews_signal, таск update_description_via_change_card.

    Общая схема такая: обновляется карточка товара, отправляется сигнал, обработчик сигнала запускает задачу на создания слепка карточки товара.

    Поле description модели ProductCardDescription - это общие характеристики товара на сайте korallmicro, это поле формата json и в нем есть бренд.

    Создал карточку товара, бренда у нее сначала нет. Через время бренд берется из 1с. Когда бренд подтянулся, зашел в карточку, выбрал "проверена" и нажал сохранить. После этого создался слепок и в нем есть бренд.

    Скорее всего бренд не подтянулся из 1с, а кура нажала "проверена" и сохранила.

    Скрипт обновления слепков карточек у которых в слепке есть None

        codes = ProductCardDescription.objects.filter(description__contains='None')
        update_descriptions_and_previews(
            codes=codes,
            do_update_description=True,
            do_upload_preview=False
        )

    Решение: сделать валидацию, которая не будет позволять делать карточку товара "проверенной" пока у неё не появится бренд.

    	Валидация нужна при сохранении одной карточки и при экшене, который обновляет статус выбранных карточек.

    	Можно написать универсальную валидацию для двух случаев.

    	Валидацию вставляем в class ProductCardAdmin/save_model, mark_cards_as_checked и в формирование слепков карточки товара - task/update_descriptions_and_previews

Товары без фото #18127

	Речь идет о фото карточки товара.

	Заходим в карточку товара, нажимаем "Галерея карточки", добавляем фото и сохраняем

    	админка ProductCardImageAdmin

        таблица cards_productcardimage

        модель ProductCardImage

    При добавлении можно задать порядок отображения и главную картику.

    Если не задана главная картика, то у товара её не будет.

    Если есть например одна главная картинка (номер 0), а все остальные 6 картинок с номером 1, то продукт будет иметь 2 картинки, а не 7. 

    Валидация

        У карточки товара должно быть хотя бы одно фото.

        Должна быть главная картинка с номером 0.

        Не должно быть повторяющихся картинок.

Ошибка при синхронизации фильтров #18298

	bin/celery -A app_celery call sync_filter_korallmicro --queue system

	остановился на change_view в ProductCardAdmin

Валидация карточки товара

    Есть момент, когда админ может пометить карточку товара, как проверенную, когда у неё нет ни одной фотки. При этом сейчас это нормально, потому что могут быть товары без фото.

Ошибочные карточки при формировнии кеша ЯМ #18082

    В выгрузку для яндекс маркета должны попадать карточки товара у которых есть фотки.

    class ProductCardModelTest(TestCase):
        """Проверяет работу кастомного функционала (менеджеры, queryset-ы)."""

        def setUp(self):
            """Наполняет бд нужными данными для тестов."""

            kind = Kind.objects.create(
                kind=u'Телефон',
                type=u'Телефон',
                worker=self.user
            )

            template = Template.objects.create()
            TemplateEntry.objects.create(
                template=template,
                name=u'Основные характеристики',
            )
            Property.objects.create(
                kind=kind,
                template=template
            )

            brand = Brand.objects.create(
                uuid='0026ffl3-40c8-11e6-93fc-001b22mad331',
                name='Apple',
                warranty=None
            )

            ProductCard.objects.bulk_create([
                ProductCard(
                    is_ready=True,
                    is_checked=False,
                    is_actual=True,
                    kind=kind
                ),
                ProductCard(
                    code=7,
                    is_ready=True,
                    is_checked=False,
                    is_actual=True,
                    kind=kind
                ),
                ProductCard(
                    code=8,
                    is_ready=True,
                    is_checked=False,
                    is_actual=True,
                    kind=kind,
                    brand=brand,
                ),
                ProductCard(
                    code=9,
                    is_ready=True,
                    is_checked=False,
                    is_actual=True,
                    kind=kind,
                    brand=brand,
                    has_invalid_images=True
                ),
                ProductCard(
                    code=10,
                    is_ready=True,
                    is_checked=True,
                    is_actual=True,
                    kind=kind,
                    brand=brand,
                    has_invalid_images=False
                )
            ])

            ProductCardImage.objects.create(
                card=ProductCard.objects.get(code=10),
                index=0,
                image='test.png'
            )

        def test_get_verified(self):
            """Должен возвращать валидные и проверенные карточки товара."""

            product_card_valid = ProductCard.objects.get_verified()
            self.assertEqual(
                first=product_card_valid.count(),
                second=1
            )

Необходимо получить фото товаров с нашего СДН, по следующим критериям #...

    Дата с 22.04.2019 по 25.04.2019 (выбирать из поля date_checked, потому что это дата, когда карточка была полностью проверена и выгружена на сайт)

    Карточки должны быть готовы к проверки, проверены и иметь картинки.

    product_card_pk_list = ProductCard.objects.filter(
        date_checked__in=['2019-04-22', '2019-04-23', '2019-04-24', '2019-04-25'], 
        images__isnull=False, 
        is_checked=True, 
        is_ready=True, 
        is_actual=True
    ).distinct().values_list('pk', flat=True)

    len(product_card_pk_list)

    images_name_list = ProductCardImage.objects.filter(card__in=product_card_pk_list).values_list('image', flat=True)

    len(images_name_list)

    image_without_path = [image_name.split('/')[1] for image_name in images_name_list]

    cp /media/storage/magic/images/223999_0_20190422_1622.jpg /media/storage/magic/images/224065_0_20190423_1121.jpg ~/TMP

    cp /media/storage/magic/images/223999_0_20190422_1622.jpg /media/storage/magic/images/224065_0_20190423_1121.jpg и т.д.

После подтверждения карточек товара они не появились на боевом #18506

    Причина в формировании кодов для сигнала update_descriptions_and_previews_signal. Если коды формируются до update, то всё ок, если после, то в некоторых случаях update очищает queryset и коды карточки товара формируются некорректно.

    Чудным образом у подтвержденных карточек товаров сбрасывается date_formed_description в None и их нет на сайте.

    date_formed_description выставляется в None, когда выполняется таск update_descriptions_and_previews и метод card_cancel.

    Места где production на сервере не совпадает с production на gitlab

        def mark_as_changed (return)

        def card_cancel (return)
        
        _find_duplicates_action_templates (return False)

        _find_duplicates_for_products (return False)   
    
Пересекающийся товар в неактивных акциях

    Время действие акции "15 лет КМ" не вышло, поэтому и возникала данная проблема.

Integrity Error в синхронизации между magic и 1c

    Падает таск sync_shop.

    Task sync_shop with id a8304a88-c59d-4254-b5ae-3003666a1cf5 raised exception:
    IntegrityError(1062, "Duplicate entry \'df1771cb-5db6-11e8-80d4-6805ca44419c\' for key \'PRIMARY\'")'

    File "/home/devel/www/magic/modules/catalog/tasks.py", line 620, in sync_shop
    sync(shop_type)
    File "/home/devel/www/magic/modules/catalog/tasks.py", line 444, in sync
    bk_product.flush()

    Группы и катологи это одно и то же.

Проблема с обработкой изображений с помощью PIL #18128

    Ошибка происходит в том случае, когда original_image.format = none

    Не давать загружать картинки с отсутствующим форматом

        Найти карточки с плохими картинками

        Сохранить битую картинку

        Убедиться, что скрипт падает с этой картинкой.

        Узнать можно ли валидировать картинки.

Когда карточка становится актуальной

    Ставится в 1с и обновляется таском в фоне.

Выгодные предложения

    js

        catalog/static/data/js/init.js

        function load_offerproperties

    модель OfferProperty

    get_json_offertypes

    from main.tasks.profiles  import apply_ones_action_prices
    pply_ones_action_prices.delay(1)

Не приходят письма если возникает ошибки при проведении карточек товара

    Может происходить из-за того что необновился счетчик в кэше.

    В таком случае не срабатывает нужное условие (см. таск update_descriptions_and_previews) и кэш никогда не отчищается.

    На 10.06.2019 счетчик в кэше может не обновится в том случае если не удалось получить кэш с помощью cache.get('separation_info').

        Эта ситуация может быть в двух случаях:

            1. Упал redis server

            2. Нет кэша с таким ключом

Проблема с выгодными предложениями magic

    Какой код падает с duplicate enry?

        190177

    http://magic.km-union.ru/catalog/offertype/172/change/

        https://www.korallmicro.ru/products/offer/172?utm_source=site&utm_medium=banner_mainpage&utm_campaign=category&utm_term=allactions

    http://magic.km-union.ru/catalog/catalog/318144/change/

        https://www.korallmicro.ru/catalog/portativnaya_tekhnika/vneshnie_akkumulyatory

    Коралл берет нужные данные из

        Базы korallmicro

            SELECT * FROM public.catalogs WHERE name = 'Внешние аккумуляторы';

        class CatalogController

            public function indexAction(){

                $renderedProductItems = $product->renderProductItemsByAlias($alias, $renderParams['type'], $renderParams['sort'], $renderParams['is_dealer_provided'], $renderParams['sort_direction']);

                var_dump($alias, $renderParams['type'], $renderParams['sort'], $renderParams['is_dealer_provided'], $renderParams['sort_direction']); die();

    Что записывает туда данные?

        def sync_catalogs_and_products(site_models=SITE_MODELS, shop_type=CURRENT_SHOPPING_TYPE):

    Как правильно вызвать catalog/tasks.py -> def sync?

        from catalog.tasks import *

        sync_shop.delay(shop_type='korallmicro')

    Как узнать на каком продукте падает?

        В /modules/ones/models.py -> def flush поставить это:

        if self._model.__name__ == 'Products' and self._cache and hasattr(self._cache[0], 'code'):
            my_prod = [product.code for product in self._cache]
            print my_prod

        Затем в добавить так:

            bk_distributions = BulkCreator(Distributions, cache_size=1)

    Помогло

        Korallmicro

            Для всех акций

                from catalog.tasks import *

                sync_offers_korallmicro.delay()

            Для банера с акциями над выводом продуктов

                from catalog.tasks import *

                sync_korallmicro.delay()

        Snr
        
            Для всех акций

                from catalog.tasks import *

                sync_offers_snr.delay()

            Для банера с акциями над выводом продуктов

                from snr.tasks import *

                sync.delay(site_models='sales_base_models.models', shop_type='snr_new')

    Куда смотреть?

        Изменение выгодных предложений

            http://magic.km-union.ru/catalog/offertype/35/change/

        Там должен быть вызов синхронизации выгодных предложений

            sync_offers_korallmicro.delay()

    Как узнать на каком продукте падает?

        def flush(self):
            from catalog.models import Products as CatalogProduct, Distributions
            if self._model.__name__ == 'Products' and self._cache and hasattr(self._cache[0], 'code'):
                print 'cache'
                print self._cache

                for product in self._cache:
                    print 'all cache product code'
                    print product.code

                product_code = self._cache[0].code
                print 'product_code'
                print product_code

                print 'is exists code in catalog_products'
                print CatalogProduct.objects.filter(code=product_code).exists()
            elif self._model.__name__ == 'Distributions' and self._cache and hasattr(self._cache[0], 'product_id'):
                print 'cache'
                print self._cache

                for distribution in self._cache:
                    print 'all cache distribution product_id'
                    print distribution.product_id

                product_id = self._cache[0].product_id
                print 'code'
                print product_id

                print 'is exists product_id in catalog_products'
                print CatalogProduct.objects.filter(code=product_id).exists()
            self._model.objects.bulk_create(self._cache)
            self.total_created += len(self._cache)
            self._cache = []

    Ошибки

        [2019-08-09 13:19:34,661: WARNING/Worker-2] cache
        [2019-08-09 13:19:34,661: WARNING/Worker-2] [<Products: 190177 - Сервер DELL PowerEdge R430 E5-2609v4/4x16Gb RDIMM/H330 PERC/3x1.2TB SAS/2x200GB SAS/ 500W PSU(SpecBuild 2252781)>]
        [2019-08-09 13:19:34,662: WARNING/Worker-2] all cache product code
        [2019-08-09 13:19:34,662: WARNING/Worker-2] 190177
        [2019-08-09 13:19:34,662: WARNING/Worker-2] product_code
        [2019-08-09 13:19:34,662: WARNING/Worker-2] 190177
        [2019-08-09 13:19:34,662: WARNING/Worker-2] is exists code in catalog_products
        [2019-08-09 13:19:34,664: WARNING/Worker-2] False


        [2019-08-09 13:19:37,613: WARNING/Worker-2] cache
        [2019-08-09 13:19:37,622: WARNING/Worker-2] [<Distributions: d155349c-fd61-11e5-93f9-001b21d8d330-Материнские платы : c94d7955-83dd-11e7-80c9-6805ca44419c-М/плата ASRock J4205-ITX, GLan/VGA/
        DVI/HDMI, mini-ITX - False>]
        [2019-08-09 13:19:37,622: WARNING/Worker-2] all cache distribution product_id
        [2019-08-09 13:19:37,623: WARNING/Worker-2] 189832
        [2019-08-09 13:19:37,623: WARNING/Worker-2] code
        [2019-08-09 13:19:37,624: WARNING/Worker-2] 189832
        [2019-08-09 13:19:37,624: WARNING/Worker-2] is exists product_id in catalog_products
        [2019-08-09 13:19:37,628: WARNING/Worker-2] True


        [2019-08-09 13:19:48,417: INFO/Worker-2] sync_shop[1ad6e6bb-9493-4b50-b13f-efefe7d9281a]: done sync "snr_new"
        [2019-08-09 13:19:48,420: INFO/MainProcess] Task sync_shop[1ad6e6bb-9493-4b50-b13f-efefe7d9281a] succeeded in 44.5890488997s: None
        [2019-08-09 13:19:48,429: INFO/Worker-2] sync_shop[b9beb080-ac91-4823-8d58-81ef1649d102]: run sync "istore"


        [2019-08-09 13:19:48,442: WARNING/Worker-1] cache
        [2019-08-09 13:19:48,442: WARNING/Worker-1] [<Products: 189832 - М/плата ASRock J4205-ITX, GLan/VGA/DVI/HDMI, mini-ITX>]
        [2019-08-09 13:19:48,443: WARNING/Worker-1] all cache product code
        [2019-08-09 13:19:48,443: WARNING/Worker-1] 189832
        [2019-08-09 13:19:48,443: WARNING/Worker-1] product_code
        [2019-08-09 13:19:48,443: WARNING/Worker-1] 189832
        [2019-08-09 13:19:48,443: WARNING/Worker-1] is exists code in catalog_products
        [2019-08-09 13:19:48,445: WARNING/Worker-1] False
        [2019-08-09 13:19:48,536: INFO/MainProcess] Received task: sync_snr_new[f10d304f-51d4-4177-8f5e-88a47187c0b9]
        [2019-08-09 13:19:48,611: ERROR/MainProcess] Task sync_shop[9195af5d-e0ef-4a1b-a23f-0ec919ca49c8] raised unexpected: IntegrityError(1062, "Duplicate entry 'c94d7955-83dd-11e7-80c9-6805ca4441
        9c' for key 'PRIMARY'")

    Итог

        Отключили istore/snr_new после чего синхронизация начала работать нормально.

        Причина наложение тасков.

        Для каждого магазина запускается таск sync_shop.

        Внутри sync_shop выполняется метод sync.

        Внутри метода sync выполняется удаление всех продуктов, затем добавление нужных.

        Затем внутри метода sync выполняется удаление всех distributions, затем добавление нужных.

        Именно в этих местах и происходит наложение тасков.

        Первый таск удалил все продукты и добавил нужные. Второй таск паралельно удалил все продукты, а когда начал вставлять увидель, что уже есть продукт и упал с duplicate entry.

            Products.objects.filter(uid__in=delete_products).exclude(distributions__catalog__type__in=shop_types).delete()
            bk_product = BulkCreator(Products)
            for add_product_uuid in add_products:
                ones_product = ones_products[add_product_uuid]
                defaults = {
                    'uid': add_product_uuid,
                    'code': ones_product['code'],
                    'art': ones_product['code'],
                    'name': ones_product['name'],
                    'translit': get_translit(ones_product['name']),
                    'new': ones_product['is_new'],
                    'create_date': ones_product['create_date']
                }
                bk_product.create(**defaults)
            bk_product.flush()

        Аналогично с distribution

            Distributions.objects.filter(catalog__uid__in=delete_distributions_catalog_uuids).delete()
            bk_distributions = BulkCreator(Distributions, cache_size=1)
            for group_uuid in add_distributions_catalog_uuids:
                product_uuids = get_product_uuids_for_sale(
                    ones_distributions[group_uuid],
                    shop_type=shop_type,
                    vtb_pks=rules.get(group_uuid, None)
                )
                _product_uuids = [product_uuid for product_uuid in product_uuids
                                  if products.has_key(product_uuid)]
                bk_distributions.extend([
                    Distributions(catalog_id=groups[group_uuid]['pk'],
                                  product_id=products[product_uuid]['code'])
                    for product_uuid in _product_uuids
                ])
                added_items.extend([
                    u'{0} <-> {1} {2}'.format(
                        groups[group_uuid]['full_name'], products[product_uuid]['code'],
                        products[product_uuid]['name']
                    ) for product_uuid in _product_uuids
                ])
            bk_distributions.flush()

Проблема с синхронизацией

    Падает таск sync_shop.

    Ошибки duplicate entry в таблице catalog_products и constrait foreign key в таблице catalog_distributions.

    Причина - наложение тасков.

    Как это работает?

        Все сигналы посылаются в наш брокер.

        Посылается сигнал full_ones_sync_finish.

            Обработчик сигнала full_ones_to_magic_sync запускает таск sync_db.

        Когда таск sync_db заканчивает свою работу, он посылает сигнал full_ones_to_magic_sync_finish.

            Обработчик catalog_korallmicro_sync запускает таск sync_shop.

            Обработчик catalog_snr_new_sync запускает таск sync_shop.

            Обработчик catalog_istore_sync запускает таск sync_shop.

            Сейчас эти обработчики работают паралельно.

        Когда таск sync_shop заканчивает свою работу (для каждого магазина), он посылает сигналы catalog_korallmicro_sync_finish и catalog_snr_new_sync_finish

            Обработчик site_korallmicro_sync запускает таск sync_korallmicro

            Обработчик site_snr_new_sync запускает таск sync_snr_new

        Таски sync_korallmicro и sync_snr_new внутри себя вызывают метод внутри, которого

            sync_catalogs_and_products()
            sync_offers()
            sync_tags()

        В методе sync_catalogs_and_products и происходит наложение.

    Решение проблемы

        Вызывать обработчики по цепочке.

        Когда закончил один, тогда запустился другой.

    Вопрос

        Где разруливать локигу, которая запускает следующий обработчик?

            кидаем событие, что я, мол, синк каталогов снр и я завершился

            и добавляем правило что после этого сигнала вызвать во-он тот обработчик

    Реализация

        full_ones_sync_finish -> (обработчик) full_ones_to_magic_sync -> (таск) sync_db

            full_ones_to_magic_sync_finish -> (обработчик) catalog_korallmicro_sync -> (таск) sync_shop

                таск sync_shop посылает сигнал catalog_korallmicro_sync_finish -> (обработчик) catalog_snr_new_sync -> (таск) sync_shop

                    таск sync_shop посылает сигнал catalog_snr_new_sync_finish -> (обработчик) catalog_istore_sync -> (таск) sync_shop

        Выключил

            catalog_istore_sync

            catalog_snr_new_sync

        Добавил

            catalog_korallmicro_sync_finish - обработчик catalog_snr_new_sync

                {"shop_type": "snr_new", "destination_task_params": {"routing_key": "system"}}

            catalog_snr_new_sync_finish - обработчик catalog_istore_sync

                {"shop_type": "istore", "use_confidence_interval": false, "destination_task_params": {"countdown": 15, "routing_key": "system"}}

Проблема с офферами и сегментом

    Виктор, добрый день!

    Возникла проблема с офферами.

    КораллМикро:

        В этом оффере был сегмент, я его в пятницу отключил, но в magic показывается что он есть и более того выгружается на сайт

            http://magic.km-union.ru/catalog/offertype/239/change/

        А вот новый оффер, которому был привязан сегмент из предыдущего оффера и он тоже применился и есть на сайте

            http://magic.km-union.ru/catalog/offertype/250/change/

    SNR:

        Старый

            http://magic.km-union.ru/catalog/offertype/239/change/

        Новый

            http://magic.km-union.ru/catalog/offertype/250/change/

Доработать функционал выгодных предложений на предмет отвязывния акции #19972

    Проблема

        Когда акция, например "Скидки каждый день" заканчивается, то она больше не выгружается из 1с в magic.

        В magic акция "Скидки каждый день" остается и становится не активной.

        Если через время возродить акцию "Скидки каждый день" в 1с, то после синка она станет активной и в magic с дальнейшей выгрузкой товаров на сайт.

        Это поведение создает проблему в том случае если уже есть активная акция с похожими продуктами.

    Задача

        Когда акция закончилась, убрать в magic все связи с этой акцией.

            Таблица catalog_offertype, поле ones_action_uuid

    Нюансы

        Акция в magic не должна потерять связь с акцией из 1с если эта акция в 1с не удаляется, а просто изменяются даты её проведения.

    Решение

        Находим неактивную акцию в мэджик

            http://0.0.0.0:8000/catalog/offertype/252/change/

        Проверяем, что от нее отвязана акция из 1с

            +

        Находим таблицу в 1с 8 рав с выгодными предложениям

            таблица Акции

        Находим код, который отвечает за синхронизации 1с - мэджик для выгодных предложений

            def sync_ones_offers(request):

    Заметки

        В мэджик связь выглядит так Offer -> OfferProperty -> OfferType (offer_properties). OfferProperty в данном случае это страница, где редактируется выгодное предложение и к нему привязывается акция из 1с.

        Если акция неактивна в мэджик, то ее нет в бд 1с_8_рав в таблице Акции

            SELECT 
                *
            FROM
                1C_8_RAW.Акции;
            where
                -- Наименование = 'Быстрее! Выше! Сильнее!';

        После синхронизации в мэджике у выгодного предложения удаляются связи из таблиц catalog_offerproperty и catalog_offer, но остаестя связь с акцией из 1с в таблице catalog_offertype, поле ones_action_uuid.

            Если акция воскрешается в 1с, то после синхронизации в мэджик она тоже воскреснет.

        Если закончилась акция в 1с, то запись не попала в бд 1с_8_рав и в таком случае после синхронизации в мэджике на странице редактирования выгодного предложения в поле Акция из 1С становится пустое значение

            http://127.1.0.1:8100/catalog/offertype/257/change/

    Запросы

        SELECT 
            *
        FROM
            magic.catalog_offer
        WHERE
            offer_property_id = 1151;

        ---

        SELECT 
            *
        FROM
            magic.catalog_offerproperty
        WHERE
            offer_type_id = 257;

        ---

        SELECT 
            *
        FROM
            magic.catalog_offertype
        where
            id = 257;

        ---

        SELECT 
            *
        FROM
            1C_8_RAW.Акции
        where
            Идентификатор = '35cfc53a-eb2d-11e9-80e1-6805ca44419c';

        ---

        SELECT 
            *
        FROM
            1C_8_RAW.ДействующиеАкции
        where
            Акция = '35cfc53a-eb2d-11e9-80e1-6805ca44419c';

        ---

        DELETE
        FROM
            1C_8_RAW.ДействующиеАкции/Акции
        where
            Акция/Идентификатор = '35cfc53a-eb2d-11e9-80e1-6805ca44419c';

        ---

        INSERT INTO 
            1C_8_RAW.Акции 
        VALUES (
            '35cfc53a-eb2d-11e9-80e1-6805ca44419c', 
            '2f733aff-eb2d-11e9-80e1-6805ca44419c', 
            'Супервещь Коралл', 
            '5c9f38b8-5f0d-442b-b02a-b0b018b17678', 
            '01b57c57-e12f-11e9-80e1-6805ca44419c', 
            '6a1fee40-e491-11e7-80ca-6805ca44419c', 
            '0'
        );

        INSERT INTO 
            1C_8_RAW.ДействующиеАкции 
        VALUES (
            '35cfc53a-eb2d-11e9-80e1-6805ca44419c', 
            '2019-10-01 00:00:00', 
            '2019-11-01 23:59:59'
        );