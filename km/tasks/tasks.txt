Невозможно отменить заказы #18943

	У дилера из Ленинградской есть два заказа которые он не может отменить.

	dp пишет ошибку, что нельзя завершить уже завершенный заказ.

		По логике все верно.

	В админке в заказах статус "Завершено", а отображается в "необходимо связаться с покупателем".

	Смотреть на признак need_to_call.

	Вопросы:

		Где должны отображаться заказы со статусом "Отменен"?

			В разделе "Все заказы".

	orders_order - id - 157172

	Причина возникновения бага:

		Завершенный заказ не может быть завершен, пока диллер не нажал кнопку "Созвонились".

		Дмитрий Малашыхин говорит, что это ненормальное поведение и что возможно они когда то давно при тестировании допустили косяк.

		Сейчас этот косяк нужно исправить и давать возможность диллеру отменять заказ даже если он не созвонился с заказчиком.

	orders/urls/__init__.py

		wrapper_need_to_call_orders_view

	orders/views/arm.py

		NeedToCallOrdersView

Защита от DDOS атаки яндекса #17614

	Когда робот яндекса сходит с ума, он начинает запрашивать фид по несколько раз в секунду... это ложит наш ресурс...

	Необходимо лимитировать запросы...

	Небоходимо отправлять об этом письмо. И после того, как ситуация нормализовалась.

	Вопросы:

		Что такое фид?

			Фид - это файл, содержащий в себе информацию о товаре или услуге. 

			Может быть нескольких форматов: YML, XML, CSV,  GZ, TSV, ZIP.

		Где в snr урл, который отдает файл с фидом?

			modules/main/__init__.py

			    url(r'^yandex_market/{}/(?P<subdomain>\w+).yml$'

		Как получить руками файл с фидом?

			Перейти по адресу http://127.0.1.1:8100/yandex_market/8319d51f-98d2-4b2a-992d-a2ab5461effa/anapa.yml

		Где место, которое формирует фид?

			main/views/market.py

				YandexMarketView

					engine/views/main/market.py

						YandexMarketView -> BaseYml -> TemplateView

		Что нужно отправить яндекс роботу, чтобы правильно отбить его запрос?

		Если ддос повторяется из минуты в минуту, развер нормально спамить наших ответственны и что мы будем делать, если они попросят остановить этот спам?

	Что

		Лимитировать запросы яндекса.

		Если больше какого то кол-ва в минуту, то блокируем.

		Потом отправляем письмо диллерам и админам.

		Если атака остановилась, то опять отправляем диллерам и админам письмо, а яндексу разрешаем обращаться.

Закрыть возможность создавать пользователей с одинаковым email 18347

	create

		url(r'^create/(?P<event_uuid>[0-9a-f|-]+)/$', create_customer, name='api_create_customer')

		http://127.1.0.1:8300/api/customer/create/4097a061-d6ae-4655-9823-84f7e83cbcd9

		dp_package/profile/form.py -> 

			class BaseCreateCustomerForm(RenderFormMixin, DateBirthValidationMixin

				def clean_email(self):

	auth

		url(r'^auth/$', authorization_customer, name='api_auth_customer')

		dp_package/profile/form.py 

			class AuthCustomerForm(RenderFormMixin, forms.Form):

				def clean_email(self):

	request

		import requests

		requests.post('http://127.1.0.1:8300/api/customer/create/4097a061-d6ae-4655-9823-84f7e83cbcd9/', data = {'name': 'Ilya3', 'email': 'KADUK_IA@km-union.ru', 'password': 'asdf1234'})

		def create_customer_handler(post):

			...

			print create_customer_form.errors

	Вопросы:

		Все уже есть, в чем тогда проблема?

	Что

		Валидацию на почту.

		Имя почты одинаковое с верхним регистром, должно выдавать ошибку.

	Как

		Проверяем почту.

		Если есть символы в верхнем регистре, то показываем ошибку.

		Если нет, то разрешаем создать.

	Как

		re.findall(r'[A-ZА-Я]', a)

Посадочная страница

	- все, что они хотят размесить согласовать Зелюков Анатолий

	- если все ок, мы берем в работу

	- создать задачу в мега плане

	- подключить Виктора


Проблема с апи MoneyCare, 17835

	def check_status_order_in_money_care():

	    for mc_order in money_care_orders:
	        order = mc_order.order
	        response = requests.get(
	            url.format(settings.MONEY_CARE_URL, mc_order.mc_id),
	            headers=auth_header
	        )
	        print reponse
	        print auth_header

	Все ок.

	Сервер где находится https://mc1.moneycare.su установил сертификат.

	Dp делает запрос, получает в ответ сертификат, проверяется его в центре.

	Если не валидные выкидывает ошибку.

		Из модуля requests

			"Requests verifies SSL certificates for HTTPS requests, just like a web browser. By default, SSL verification is enabled, and Requests will throw a SSLError if it’s unable to verify the certificate"

Исправить отчет с состоянием обработки заказа, 18349

	Заказы диллера

		http://127.1.0.1:8300/orders/?dealer_site=67

	Состояние заказа

		http://127.1.0.1:8300/dpa/orders/orderprocessstate/123372/change/?_changelist_filters=q%3D146308

	Отчет

		http://127.1.0.1:8300/reports/

	Название отчета

		"Отчет об ошибках" или "Отчет об ошибках по заказам" (более подробный).

	Поддомен

		stavropol.korallmicro.ru

	Время

		с 14 по 18 февраля 2019

	В коде

		modules/report/views.py

			class Report(FormView):
				def form_valid(self, form):
					REPORT_MAPPER.get(report_type)

						total-orders-errors

							modules/report/views.py

								'total-orders-errors': reports.OrderErrorByClientReport,

									class OrderErrorByClientReport(BaseReport, SimpleHeaderMixin):
										def _render_data(self, block_render, report_options):

											...

											error_times_dict = OrderProcessState.objects
										
	Вопросы Малашихина:

		Ставится ли стоп, когда диллер нажал "не дозвонился"?

		А если через 3 дня нажал "дозвонился" то как считается время?

	Проверка

		163821

		http://127.1.0.1:8300/dpa/orders/order/163821/change/

		http://127.1.0.1:8300/dpa/orders/orderprocessstate/?q=163821

		http://127.0.1.1:8200/orders/?dealer_site=67

		В pgadmin

			SELECT * FROM public.orders_order WHERE id = 163821;

			SELECT * FROM public.orders_orderprocesstime WHERE state_id = 140844;

			-----------

			SELECT * FROM public.orders_order WHERE id = 166361;

			SELECT * FROM public.orders_orderprocessstate WHERE order_id = 166361;

			SELECT * FROM public.orders_orderprocesstime WHERE state_id = 143375;

			SELECT * FROM public.orders_historicalorder WHERE id = 166361;

			166463 

		Сброс времени начала обработки

			from orders.models import *

			ord_process_state = OrderProcessState.objects.get(order_id=163821)

			ord_process_state - 140844

			ord_process_time = OrderProcessTime.objects.get(state_id=ord_process_state.pk)

			ord_process_time.end_time=None

			ord_process_time.reason_for_finish=None

			ord_process_time.save()

		Cброс статуса заказа

			ord = Order.objects.get(pk=163821)

			ord.state='New'

			ord.save()

	Какой статус получает заказ при создании?

		New

	В какой раздел попадает заказ со статусом New?

		В раздел "Заказ сформирован".

			class NewOrdersView(OrdersBaseView):

	Что такое OrderProcessState?

		Это таблица, где фиксируется статус заказа.

		По умолчанию заказ создается, как неошибочный. То есть поля error_start_time и error_end_time пустые, а has_error равно False.

	Что такое OrderProcessTime?

		Это таблица для учета времени обработки заказа.

	Когда начинается учет времени обработки заказа?

		from orders.views import *

		from orders.signals import start_order_process_time

		from orders.models import *

        start_order_process_time.send(Order, order_id=166467, reason_alias='ORDER_CREATED')

        	Обработчик:

        		start_order_process_time.connect(start_process_time_handler)

        		def start_process_time_handler(

    Когда останавливается учет времени обработки заказа?

    	from orders.views import *

		from orders.signals import end_order_process_time

        end_order_process_time.send(Order, order_id=order.id, reason_alias='NEED_TO_CALL')

    	Обработчик: 

    		end_order_process_time.connect(end_process_time_handler)

    		def end_process_time_handler(

    	Учет времени может остановиться если закончилось время работы магазина. Для обработки таких ситуация работает крон.

    		check_time_order_processing

    Как протестить

    	Создать через dpa заказ

    	start_order_process_time.send(Order, order_id=76626, reason_alias='ORDER_CREATED')

    	ord_process_state = OrderProcessState.objects.get(order_id=76626)

    	print OrderProcessTime.objects.get(state_id=ord_process_state.pk)

Проблема с выгодными предложениями magic

	Какой код падает с duplicate enry?

		190177

	http://magic.km-union.ru/catalog/offertype/172/change/

		https://www.korallmicro.ru/products/offer/172?utm_source=site&utm_medium=banner_mainpage&utm_campaign=category&utm_term=allactions

	http://magic.km-union.ru/catalog/catalog/318144/change/

		https://www.korallmicro.ru/catalog/portativnaya_tekhnika/vneshnie_akkumulyatory

	Коралл берет нужные данные из

		Базы korallmicro

			SELECT * FROM public.catalogs WHERE name = 'Внешние аккумуляторы';

		class CatalogController

			public function indexAction(){

				$renderedProductItems = $product->renderProductItemsByAlias($alias, $renderParams['type'], $renderParams['sort'], $renderParams['is_dealer_provided'], $renderParams['sort_direction']);

				var_dump($alias, $renderParams['type'], $renderParams['sort'], $renderParams['is_dealer_provided'], $renderParams['sort_direction']); die();

	Что записывает туда данные?

		def sync_catalogs_and_products(site_models=SITE_MODELS, shop_type=CURRENT_SHOPPING_TYPE):

	Как правильно вызвать catalog/tasks.py -> def sync?

		from catalog.tasks import *

		sync_shop.delay(shop_type='korallmicro')

	Как узнать на каком продукте падает?

		В /modules/ones/models.py -> def flush поставить это:

        if self._model.__name__ == 'Products' and self._cache and hasattr(self._cache[0], 'code'):
            my_prod = [product.code for product in self._cache]
            print my_prod

	    Затем в добавить так:

	    	bk_distributions = BulkCreator(Distributions, cache_size=1)

	Помогло

		Korallmicro

			Для всех акций

				from catalog.tasks import *

				sync_offers_korallmicro.delay()

			Для банера с акциями над выводом продуктов

				from catalog.tasks import *

				sync_korallmicro.delay()

		Snr
		
			Для всех акций

				from catalog.tasks import *

				sync_offers_snr.delay()

			Для банера с акциями над выводом продуктов

				from snr.tasks import *

				sync.delay(site_models='sales_base_models.models', shop_type='snr_new')

	Куда смотреть?

		Изменение выгодных предложений

			http://magic.km-union.ru/catalog/offertype/35/change/

		Там должен быть вызов синхронизации выгодных предложений

			sync_offers_korallmicro.delay()

	Как узнать на каком продукте падает?

	    def flush(self):
	        from catalog.models import Products as CatalogProduct, Distributions
	        if self._model.__name__ == 'Products' and self._cache and hasattr(self._cache[0], 'code'):
	            print 'cache'
	            print self._cache

	            for product in self._cache:
	                print 'all cache product code'
	                print product.code

	            product_code = self._cache[0].code
	            print 'product_code'
	            print product_code

	            print 'is exists code in catalog_products'
	            print CatalogProduct.objects.filter(code=product_code).exists()
	        elif self._model.__name__ == 'Distributions' and self._cache and hasattr(self._cache[0], 'product_id'):
	            print 'cache'
	            print self._cache

	            for distribution in self._cache:
	                print 'all cache distribution product_id'
	                print distribution.product_id

	            product_id = self._cache[0].product_id
	            print 'code'
	            print product_id

	            print 'is exists product_id in catalog_products'
	            print CatalogProduct.objects.filter(code=product_id).exists()
	        self._model.objects.bulk_create(self._cache)
	        self.total_created += len(self._cache)
	        self._cache = []

	Ошибки

		[2019-08-09 13:19:34,661: WARNING/Worker-2] cache
		[2019-08-09 13:19:34,661: WARNING/Worker-2] [<Products: 190177 - Сервер DELL PowerEdge R430 E5-2609v4/4x16Gb RDIMM/H330 PERC/3x1.2TB SAS/2x200GB SAS/ 500W PSU(SpecBuild 2252781)>]
		[2019-08-09 13:19:34,662: WARNING/Worker-2] all cache product code
		[2019-08-09 13:19:34,662: WARNING/Worker-2] 190177
		[2019-08-09 13:19:34,662: WARNING/Worker-2] product_code
		[2019-08-09 13:19:34,662: WARNING/Worker-2] 190177
		[2019-08-09 13:19:34,662: WARNING/Worker-2] is exists code in catalog_products
		[2019-08-09 13:19:34,664: WARNING/Worker-2] False


		[2019-08-09 13:19:37,613: WARNING/Worker-2] cache
		[2019-08-09 13:19:37,622: WARNING/Worker-2] [<Distributions: d155349c-fd61-11e5-93f9-001b21d8d330-Материнские платы : c94d7955-83dd-11e7-80c9-6805ca44419c-М/плата ASRock J4205-ITX, GLan/VGA/
		DVI/HDMI, mini-ITX - False>]
		[2019-08-09 13:19:37,622: WARNING/Worker-2] all cache distribution product_id
		[2019-08-09 13:19:37,623: WARNING/Worker-2] 189832
		[2019-08-09 13:19:37,623: WARNING/Worker-2] code
		[2019-08-09 13:19:37,624: WARNING/Worker-2] 189832
		[2019-08-09 13:19:37,624: WARNING/Worker-2] is exists product_id in catalog_products
		[2019-08-09 13:19:37,628: WARNING/Worker-2] True


		[2019-08-09 13:19:48,417: INFO/Worker-2] sync_shop[1ad6e6bb-9493-4b50-b13f-efefe7d9281a]: done sync "snr_new"
		[2019-08-09 13:19:48,420: INFO/MainProcess] Task sync_shop[1ad6e6bb-9493-4b50-b13f-efefe7d9281a] succeeded in 44.5890488997s: None
		[2019-08-09 13:19:48,429: INFO/Worker-2] sync_shop[b9beb080-ac91-4823-8d58-81ef1649d102]: run sync "istore"


		[2019-08-09 13:19:48,442: WARNING/Worker-1] cache
		[2019-08-09 13:19:48,442: WARNING/Worker-1] [<Products: 189832 - М/плата ASRock J4205-ITX, GLan/VGA/DVI/HDMI, mini-ITX>]
		[2019-08-09 13:19:48,443: WARNING/Worker-1] all cache product code
		[2019-08-09 13:19:48,443: WARNING/Worker-1] 189832
		[2019-08-09 13:19:48,443: WARNING/Worker-1] product_code
		[2019-08-09 13:19:48,443: WARNING/Worker-1] 189832
		[2019-08-09 13:19:48,443: WARNING/Worker-1] is exists code in catalog_products
		[2019-08-09 13:19:48,445: WARNING/Worker-1] False
		[2019-08-09 13:19:48,536: INFO/MainProcess] Received task: sync_snr_new[f10d304f-51d4-4177-8f5e-88a47187c0b9]
		[2019-08-09 13:19:48,611: ERROR/MainProcess] Task sync_shop[9195af5d-e0ef-4a1b-a23f-0ec919ca49c8] raised unexpected: IntegrityError(1062, "Duplicate entry 'c94d7955-83dd-11e7-80c9-6805ca4441
		9c' for key 'PRIMARY'")

	Итог

		Отключили istore/snr_new после чего синхронизация начала работать нормально.

		Причина наложение тасков.

		Для каждого магазина запускается таск sync_shop.

		Внутри sync_shop выполняется метод sync.

		Внутри метода sync выполняется удаление всех продуктов, затем добавление нужных.

		Затем внутри метода sync выполняется удаление всех distributions, затем добавление нужных.

		Именно в этих местах и происходит наложение тасков.

		Первый таск удалил все продукты и добавил нужные. Второй таск паралельно удалил все продукты, а когда начал вставлять увидель, что уже есть продукт и упал с duplicate entry.

			Products.objects.filter(uid__in=delete_products).exclude(distributions__catalog__type__in=shop_types).delete()
	        bk_product = BulkCreator(Products)
	        for add_product_uuid in add_products:
	            ones_product = ones_products[add_product_uuid]
	            defaults = {
	                'uid': add_product_uuid,
	                'code': ones_product['code'],
	                'art': ones_product['code'],
	                'name': ones_product['name'],
	                'translit': get_translit(ones_product['name']),
	                'new': ones_product['is_new'],
	                'create_date': ones_product['create_date']
	            }
	            bk_product.create(**defaults)
	        bk_product.flush()

	    Аналогично с distribution

	    	Distributions.objects.filter(catalog__uid__in=delete_distributions_catalog_uuids).delete()
	    	bk_distributions = BulkCreator(Distributions, cache_size=1)
	        for group_uuid in add_distributions_catalog_uuids:
	            product_uuids = get_product_uuids_for_sale(
	                ones_distributions[group_uuid],
	                shop_type=shop_type,
	                vtb_pks=rules.get(group_uuid, None)
	            )
	            _product_uuids = [product_uuid for product_uuid in product_uuids
	                              if products.has_key(product_uuid)]
	            bk_distributions.extend([
	                Distributions(catalog_id=groups[group_uuid]['pk'],
	                              product_id=products[product_uuid]['code'])
	                for product_uuid in _product_uuids
	            ])
	            added_items.extend([
	                u'{0} <-> {1} {2}'.format(
	                    groups[group_uuid]['full_name'], products[product_uuid]['code'],
	                    products[product_uuid]['name']
	                ) for product_uuid in _product_uuids
	            ])
	        bk_distributions.flush()


Продукт пометили в 1с, как "не для магазина", а он всеравно появился на korallmicro

	is_not_for_retail

	from raw_processing.models import *

	class Nomenclature(models.Model):
		code = код карточки товара
		is_not_for_retail = models.BooleanField(db_column=u'НеДляРозницы')

	Nomenclature.objects.get(code=26491).is_not_for_retail

	full_ones_sync_send_signal

		full_ones_sync_finish

			http://broker.km-union.ru/broker/rule/

				ищим full_ones_sync_finish (должно быть MagicRabbitMQ, всю чепочку тасков можно посмотреть в http://broker.km-union.ru/dashboard/)

					def sync_db():

						def sync(self):

							self.prepare_1c_data(vtbs_dict, type_prices_dict, stores_dict)

				# вызывает наш брокер
				def sync_shop(shop_type=settings.DEFAULT_SHOPPING_TYPE, use_confidence_interval=True):

					def sync(shop_type=settings.DEFAULT_SHOPPING_TYPE):

						'148b0e4d-b200-11e2-93f1-002655df3ac1' in products_uuids
						'148b0e4d-b200-11e2-93f1-002655df3ac1' in ones_product_uuids

						'148b0e4d-b200-11e2-93f1-002655df3ac1' in add_products
					    '148b0e4d-b200-11e2-93f1-002655df3ac1' in delete_products
					    '148b0e4d-b200-11e2-93f1-002655df3ac1' in change_products

						Products.objects.filter(uid__in=delete_products).exclude(distributions__catalog__type__in=shop_types).delete()

							Products.objects.filter(uid='148b0e4d-b200-11e2-93f1-002655df3ac1')[0].distributions.first().catalog.type

						OProducts.objects.get_for_sale_and_retail(shop_type=shop_type)

							В условии для snr, snr_new все правильно.

				catalog_products (SELECT * FROM magic.catalog_products WHERE uid = '148b0e4d-b200-11e2-93f1-002655df3ac1';)

					catalog_distributions (SELECT * FROM magic.catalog_distributions where product_id = 26491;)

						catalog_catalog (SELECT * FROM magic.catalog_catalog where id = 318246;)

				ones_products (SELECT * FROM magic.ones_products WHERE uid = '148b0e4d-b200-11e2-93f1-002655df3ac1';)

	Цепочка работы этой хуйни

		1с выгрузил все продукты в 1C_8_RAW и послал сигнал.

			task_sync_db

		На этот сигнал среагировал magic и отправил сигнал в наш брокер.

			full_ones_sync_finish

		Наш брокер принял сигнал от magic и обработал.

			full_ones_to_magic_sync

		Обработчик сигнала от magic послал свой сигнал.

			full_ones_to_magic_sync_finish

		Сигнал full_ones_to_magic_sync_finish обработали обработчики

			catalog_istore_sync

			full_sync

			full_sync

			price_update

			catalog_korallmicro_sync

			catalog_snr_new_sync	

		Magic выгрузил данные из 1с 8 рав в свои таблицы.

	Некоторые сигналы посылает наш брокер

		http://gitlab0.km-union.ru/python/broker/blob/master/modules/broker/sources/rabbitmq/sources.py

	Можно ли добавить один и тот же продукт в каталоги snr и korallmicro?

		Да, можно.

	Причина возникновения бага

		Скорее всего добавили один и тот же товар в каталоги korallmicro и snr (в 1с).

		Затем удалили этот товар из каталога korallmicro (в 1с).

		... Не создаётся в catalog_distributions

	Как товар попадает в таблицу product в базе korallmicro?

		def sync_catalogs_and_products(site_models=SITE_MODELS,shop_type=CURRENT_SHOPPING_TYPE):

	Где могут возникать проблемы?

		catalog/tasks.py

			def sync

		korallmicro/tasks.py

			def sync_catalogs_and_products

	Как протестить?

		from catalog.tasks import *

		sync_shop.delay(shop_type='korallmicro')

		from korallmicro.tasks import sync as korallmicro_shop_sync

		sync_korallmicro.delay()

		from catalog.models import *

		Products.objects.filter(code__in=[65963, 65964, 65965, 65966, 65967, 65968, 85880, 85881, 85882, 85884, 86408, 86410, 111088, 111089, 111357, 111360, 111362, 123404, 124525, 143455, 143456, 155652, 183643]).count()

	Отработало, как нужно

		from catalog.tasks import *

		sync_shop.delay(shop_type='korallmicro')

		from korallmicro.tasks import sync as korallmicro_shop_sync

		sync_korallmicro.delay()

страна производитель есть в 1С, но нет в magic

	229812

Проблема с синхронизацией

	Падает таск sync_shop.

	Ошибки duplicate entry в таблице catalog_products и constrait foreign key в таблице catalog_distributions.

	Причина - наложение тасков.

	Как это работает?

		Все сигналы посылаются в наш брокер.

		Посылается сигнал full_ones_sync_finish.

			Обработчик сигнала full_ones_to_magic_sync запускает таск sync_db.

		Когда таск sync_db заканчивает свою работу, он посылает сигнал full_ones_to_magic_sync_finish.

			Обработчик catalog_korallmicro_sync запускает таск sync_shop.

			Обработчик catalog_snr_new_sync запускает таск sync_shop.

			Обработчик catalog_istore_sync запускает таск sync_shop.

			Сейчас эти обработчики работают паралельно.

		Когда таск sync_shop заканчивает свою работу (для каждого магазина), он посылает сигналы catalog_korallmicro_sync_finish и catalog_snr_new_sync_finish

			Обработчик site_korallmicro_sync запускает таск sync_korallmicro

			Обработчик site_snr_new_sync запускает таск sync_snr_new

		Таски sync_korallmicro и sync_snr_new внутри себя вызывают метод внутри, которого

			sync_catalogs_and_products()
		    sync_offers()
		    sync_tags()

		В методе sync_catalogs_and_products и происходит наложение.

	Решение проблемы

		Вызывать обработчики по цепочке.

		Когда закончил один, тогда запустился другой.

	Вопрос

		Где разруливать локигу, которая запускает следующий обработчик?

			кидаем событие, что я, мол, синк каталогов снр и я завершился

			и добавляем правило что после этого сигнала вызвать во-он тот обработчик

	Реализация

		full_ones_sync_finish -> (обработчик) full_ones_to_magic_sync -> (таск) sync_db

			full_ones_to_magic_sync_finish -> (обработчик) catalog_korallmicro_sync -> (таск) sync_shop

				таск sync_shop посылает сигнал catalog_korallmicro_sync_finish -> (обработчик) catalog_snr_new_sync -> (таск) sync_shop

					таск sync_shop посылает сигнал catalog_snr_new_sync_finish -> (обработчик) catalog_istore_sync -> (таск) sync_shop






			

