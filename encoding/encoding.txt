======
Кратко
======

Локаль - набор языковых настроек вообще (набор символов, язык пользователя, часовой пояс, страна, ...)
Кодировка - способ представления цифр, букв и знаков в памяти компьютера (в нулях-единицах); en_GB.UTF-8 - кодировка UTF-8, британский английкий;
Unicode - стандарт, а не кодировка; определяет связь между символом и неким числом; в сущности, огромная таблица символов;
UTF-8, UTF-16 - Юникод-кодировки (формат, как числа будут преобразовываться в байты)

Любой символ может быть закодирован множеством разных последовательностей бит, и любая последовательность бит может представлять разные символы, в зависимости от используемой кодировки. Причина в том, что разные кодировки используют разное число бит на символ и разные значения для кодирования разных символов.
Первая причина нечитаемости текста в том, что кто-то пытается прочитать последовательность байт в неверной кодировке. Компьютеру всегда нужно подсказывать. Сам он не догадается. Некоторые типы документов определяют кодировку своего содержимого, но последовательность байт всегда остается черным ящиком.

=======
Python2
=======

Подход к обработке строк, использующих определенную кодировку, в Python 2 довольно прост: вы берете строку (байтовую), которую вы могли получить откуда угодно, а затем преобразуете ее из той кодировки, которая характерна для источника строки(метаданные, заголовки, иные) в строку Unicode. Став Unicode строкой, она поддерживает все те же операции что и байтовая, но теперь она может хранить больший диапазон символов. Когда вам необходимо передать строку на обработку куда-либо еще, то вы снова преобразуете ее в ту кодировку, которая используется принимающей стороной, и перед нами вновь байтовая строка. (можно вспомнить принцип сендвича из Python к вершинам мастерства)

<str> - байтовые строки (просто бинарные данные, которые могут быть чем-угодно ('a' - просто синоним для написания '\x61', и не больше)
<unicode> - не последовательность байт, а последовательность собственно символов без какого либо представления о том, как эти символы эффективно сохранить в памяти компьютера (более высокой уровень абстракции, чем байтовый строки). 

Что такое строка в Python 2.x? Это просто байты. Просто бинарные данные, которые могут быть чем-угодно. Символ 'a' здесь просто синоним для написания '\x61', и ни чуточку больше. Например:
>>> '\x61' 
'a'
>>> struct.unpack('>4b', x)  # 'x' - это просто четыре signed/unsigned char-а
(97, 98, 99, 100)


Способы создания юникод-строки:
	u'abc'
	'abc'.decode('ascii')			# 'abc'.decode('utf-8'), ascii, utf-8 - кодировка, которая будет использована для превращения байтов в символы
	unicode('abc', 'ascii')

Этапы этого превращения выглядят примерно так:

'\x61' -> кодировка ascii -> строчная латинская "a" -> u'\u0061' (unicode-point для этой буквы)
или
'\xe0' -> кодировка c1251 -> строчная кириличная "a" -> u'\u0430'


Создание обычной строки из юникода (закодировать):
	u'abc'.encode('ascii')

Запоминаем и не путаем:
	юникод == символы
	строка == байты
	
	байты -> что-то значащее (символы) — это де-кодирование (decode)
	символы -> байты — кодирование (encode).


Ошибки:

Как работает конкатенация строки и юникод-строки? Простая строка должна быть превращена в юникод-строку, и поскольку интерпретатор не знает кодировки, от использует кодировку по умолчанию — ascii.

«UnicodeDecodeError» обычно есть свидетельством того, что нужно декодировать строку в юникод, используя правильную кодировку.

res = u'баба-яга'
s = 'кощей'
print res + s.decode('cp1251')		# будет unicode



Теперь использование «str» и юникод-строк. Не используйте «str» и юникод строки :) В «str» нет возможности указать кодировку, соответственно кодировка по умолчанию будет использоваться всегда и любые символы > 128 будут приводить к ошибке. Используйте метод «encode»:

«UnicodeEncodeError» — знак того, что нам нужно указать правильную кодировку во время превращения юникод-строки в обычную (или использовать второй параметр 'ignore'\'replace'\'xmlcharrefreplace' в методе «encode»).

res = u'баба-яга'
s = s.encode('cp1251')
print type(s), s					# будет str; при преобазовании в str(s) упадет с UnicodeEncodeError


Python 2 имеет два подхода к представлению строк: байтами и Unicode. Преобразование между этими представлениями осуществляется при помощи механизма кодеков. Данный механизм не навязывает схему преобразования Unicode->byte или на нее похожую. Кодек может производить преобразование byte->byte или Unicode->Unicode. Фактически система кодеков может реализовывать преобразование между любыми типами Python. Вы можете иметь JSON кодек, который производит преобразование строки в сложный Python объект на ее основе, если сочтете, что такое преобразование вам необходимо. 

=======
Python2
=======
Не надо заморачиваться


Главное различие между Python 2 и Python 3 --базовые типы, существующие для работы со строками и байтовыми строками. В Python 3 мы имеем один строковый тип: str, который хранит данные в Unicode, и два байтовых типа: bytes и bytearray.


Ну и вроде всё. Основные советы — не путать «encode»\«decode» и понимать различия между байтами и символами.