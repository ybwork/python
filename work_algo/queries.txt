Оглавление

	Как составлять запрос

	Формат

Как составлять запрос

	Идём по схеме

		Что
			
			name, products

		Откуда

			users, products

		Как получить

			Соединение

				JOIN

			Подзапрос

			Группировка

				group by

				Объединяет значения в одну строку при совпадении значений в столбцах.

			Агрегация

				min, max, avg, count

			Сортировка

				order by

				desc/asc

			Уникальность

				distinct
			
		Условие

			Подзапрос

			Группировка

			Агрегация

			Объединение

			Условия (case)

	Составляем чистый sql запрос (если возможно в разных вариациях)

	Профилируем чистый sql запрос/запросы и выбираем самый эффективный

		Выполняя запрос, PostgreSQL разрабатывает для него план запроса.

		Выбор правильного плана запроса крайне важен для хорошей производительности, поэтому в системе работает сложный планировщик, задача которого подобрать хороший план.

		Узнать, какой план был выбран для какого-либо запроса, можно с помощью команды EXPLAIN.

		EXPLAIN SELECT * FROM tenk1;	

			Seq Scan on tenk1  (cost=0.00..458.00 rows=10000 width=244)

			0.00 - приблизительная стоимость запуска, прежде чем начнётся вывод данных

			458.00 - приблизительная общая стоимость операции

		С параметром ANALYZE оператор будет выполнен на самом деле, а не только запланирован. 

		При этом в вывод добавляются фактические сведения о времени выполнения, включая общее время, затраченное на каждый узел плана (в миллисекундах) и общее число строк, выданных в результате. 

		Это помогает понять, насколько близки к реальности предварительные оценки планировщика.

		EXPLAIN ANALYZE SELECT * FROM tenk1 t1, tenk2 t2 WHERE t1.unique1 < 10 AND t1.unique2 = t2.unique2;

			Planning time: 0.181 ms 

			Execution time: 0.501 ms

		Если вы хотите проанализировать запрос, изменяющий данные, но при этом сохранить прежние данные таблицы, вы можете откатить транзакцию после запроса.

			BEGIN;

				EXPLAIN ANALYZE UPDATE tenk1 SET hundred = hundred + 1 WHERE unique1 < 100;

			ROLLBACK;

		Время выполнения, измеренное командой EXPLAIN ANALYZE, может значительно отличаться от времени выполнения того же запроса в обычном режиме.

		Не следует полагать, что выводы, полученные для игрушечной таблицы, будут применимы и для настоящих больших таблиц, поэтому возможно лучше выгрузить боеву бд и использовать ее.

	Составляем запрос на orm (если возможно в разных вариациях)
		
	Профилируем orm запрос/запросы и выбираем самый эффективный

		django

			# работает при debug = True
			from django.db import connection
			print(connection.queries)

			Вспоминаем, что queryset ленивый

				Вы можете добавлять фильтры хоть весь день и Django не выполнит ни один запрос, пока QuerySet не вычислен.

					# здесь 3 фильтра, но будет выполнен один запрос в самом конце, когда мы попросим вывести значение q
					q = Entry.objects.filter(headline__startswith="What")
					q = q.filter(pub_date__lte=datetime.date.today())
					q = q.exclude(body_text__icontains="food")
					print(q)

				Срез QuerySet возвращает новый QuerySet

					Entry.objects.all()[:5]

					Entry.objects.all()[5:10]

					Обратите внимание, хотя срез не вычисленного QuerySet вернет новый не вычисленный QuerySet, вы не можете изменять его дальше (добавлять фильтры, менять сортировку и т.д.).

			Смотрим, когда вычисляется queryset

				При первом выполнении итерации

					for e in Entry.objects.all():
    					print(e.headline)

    			Если будет указан шаг среза

    				Entry.objects.all()[:10:2]

    			QuerySet будет вычислен при вызове repr()

    			QuerySet будет вычислен при выполнении len()

    				Не используйте len() с QuerySet если вам нужно узнать только количество записей в выборке. Эффективнее использовать подсчет на уровне базы данных с помощью count.

    			QuerySet будет вычислен при использовании list()

    			QuerySet будет вычислен при выполнении bool(), использовании с or, and или if

    				if Entry.objects.filter(headline="Test"):
   						pass

   					Эффективнее использовать метод exists().

   				При обращение к вызываемым атрибутам

   					entry = Entry.objects.get(id=1)
   					entry.authors.all()
   					entry.authors.all()

			Смотрим на кэширование queryset

				Для использования кэширования в QuerySet можно использовать шаблонный тэг with.

				Если у вас очень много объектов, кэширование в QuerySet может использовать большой объем памяти. В этом случае может помочь iterator().

			Смотрим на кэширование атрибутов

				entry = Entry.objects.get(id=1)
				entry.blog
				# cache
				entry.blog

				Помнить, что с собственными свойствами нужно самостоятельно реализовать кэширование, используя, например, декоратор cached_property

			Лучше использовать поле с unique или db_index в методе get(), потом что работа с индексами ускоряет запрос, а работа с unique, потому что уникальное поле исключает ситуацию, когда несколько объектов будут удовлетворять запросу.

			Используем .select_related() и prefetch_related() если нужны все данные сразу и они будут использоваться.

			Использум values() и values_list() если нужен dict или list значений.

			Используйте defer() и only(), если есть колонки в базе данных, которые вы не будете использовать. 

				Если я в дальнейшем всё же захочу их использовать, то ORM сделает дополнительный запрос для их получения, что уменьшит производительность.

			Используем .exists(), вместо if queryset.

			Используем .count(), вместо len(queryset).

			Вместо загрузки данных в объекты, изменения значений и отдельного их сохранения (в массовом обновлении), используем .update().

				Помним, что они сигналы pre/post save не сработают.

			Используем общее добавление с .bulk_create() (при массовом добавлении)

				Entry.objects.bulk_create([
				    Entry(headline="Python 3.0 Released"),
				    Entry(headline="Python 3.1 Planned")
				])

				Это относится и к ManyToManyFields

					my_band.members.add(me, my_friend)

			Не сортируем данные, если это не требуется.

				Сортировка требует ресурсы. Каждое поле, по которому производится сортировка, требует от базы данных дополнительных ресурсов. 

				Если модель имеет сортировку по-умолчанию (Meta.ordering) и она вам не нужна, уберите её из запроса с помощью order_by() (без параметров).

			Если вам необходимо только значение внешнего ключа, то оно уже в объекте и лучше взять его так:

				entry.blog_id вместо entry.blog.id

			Используем RawSQL и SQL, если предыдущие методы не помогают.

		Общее

			Смотрим на индексацию

			Смотрим на типы полей

			Выполнять задачи базы данных в базе данных, а не с помощью языка. 

Формат

	SELECT

		name,
		car

	FROM

		users

	JOIN

		cars

	WHERE

		...