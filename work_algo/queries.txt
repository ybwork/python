Оглавление

	Как составлять запрос

	Формат

Как составлять запрос

	Идём по схеме

		Что
			
			name, products

		Откуда

			users, products

		Как получить

			Соединение

				JOIN

			Подзапрос

			Группировка

				group by

				Объединяет значения в одну строку при совпадении значений в столбцах.

			Агрегация

				min, max, avg, count

			Сортировка

				order by

				desc/asc

			Уникальность

				distinct
			
		Условие

			Подзапрос

			Группировка

			Агрегация

			Объединение

			Условия (case)

	Составляем чистый sql запрос (если возможно в разных вариациях)

	Составляем запрос на orm

		помним о кэшировании django запросов

		помним о select/prefetch related
		
	Профилируем запрос/запросы и выбираем самый эффективный

		django

			# работает при debug = True
			from django.db import connection
			print(connection.queries)

			Вспоминаем, что queryset ленивый

				Вы можете добавлять фильтры хоть весь день и Django не выполнит ни один запрос, пока QuerySet не вычислен.

					# здесь 3 фильтра, но будет выполнен один запрос в самом конце, когда мы попросим вывести значение q
					q = Entry.objects.filter(headline__startswith="What")
					q = q.filter(pub_date__lte=datetime.date.today())
					q = q.exclude(body_text__icontains="food")
					print(q)

				Срез QuerySet возвращает новый QuerySet

					Entry.objects.all()[:5]

					Entry.objects.all()[5:10]

					Обратите внимание, хотя срез не вычисленного QuerySet вернет новый не вычисленный QuerySet, вы не можете изменять его дальше (добавлять фильтры, менять сортировку и т.д.).

			Смотрим, когда вычисляется queryset

				При первом выполнении итерации

					for e in Entry.objects.all():
    					print(e.headline)

    			Если будет указан шаг среза

    				Entry.objects.all()[:10:2]

    			QuerySet будет вычислен при вызове repr()

    			QuerySet будет вычислен при выполнении len()

    				Не используйте len() с QuerySet если вам нужно узнать только количество записей в выборке. Эффективнее использовать подсчет на уровне базы данных с помощью count.

    			QuerySet будет вычислен при использовании list()

    			QuerySet будет вычислен при выполнении bool(), использовании с or, and или if

    				if Entry.objects.filter(headline="Test"):
   						pass

   					Эффективнее использовать метод exists().

   				При обращение к вызываемым атрибутам

   					entry = Entry.objects.get(id=1)
   					entry.authors.all()
   					entry.authors.all()

			Смотрим на кэширование queryset

				Для использования кэширования в QuerySet можно использовать шаблонный тэг with.

				Если у вас очень много объектов, кэширование в QuerySet может использовать большой объем памяти. В этом случае может помочь iterator().

			Смотрим на кэширование атрибутов

				entry = Entry.objects.get(id=1)
				entry.blog
				# cache
				entry.blog

				Помнить, что с собственными свойствами нужно самостоятельно реализовать кэширование, используя, например, декоратор cached_property

			Лучше использовать поле с unique или db_index в методе get(), потом что работа с индексами ускоряет запрос, а работа с unique, потому что уникальное поле исключает ситуацию, когда несколько объектов будут удовлетворять запросу.

			Используем .select_related() и prefetch_related() если нужны все данные сразу и они будут использоваться.

			Использум values() и values_list() если нужен dict или list значений.

			Используйте defer() и only(), если есть колонки в базе данных, которые вы не будете использовать. 

				Если я в дальнейшем всё же захочу их использовать, то ORM сделает дополнительный запрос для их получения, что уменьшит производительность.

			Используем .exists(), вместо if queryset.

			Используем .count(), вместо len(queryset).

			Используем RawSQL и SQL, если предыдущие методы не помогают.

		Общее

			Смотрим на индексацию

			Смотрим на типы полей

			Выполнять задачи базы данных в базе данных, а не с помощью языка. 

Формат

	SELECT

		name,
		car

	FROM

		users

	JOIN

		cars

	WHERE

		...