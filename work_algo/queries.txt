Оглавление

	Как составлять запрос

	Формат

Как составлять запрос

	Идём по схеме

		Что
			
			name, products

		Откуда

			users, products

		Определяем стороны откуда можно начать строить запрос

			От users

			От products

		Как получить

			Соединение

				JOIN

			Подзапрос

			Группировка

				group by

				Объединяет значения в одну строку при совпадении значений в столбцах.

			Агрегация

				min, max, avg, count

			Сортировка

				order by

				desc/asc

			Уникальность

				distinct
			
		Условие

			Подзапрос

			Группировка

			Агрегация

			Объединение

			Условия (case)

	Составляем чистый sql запрос (если возможно в разных вариациях)

	Профилируем чистый sql запрос/запросы и выбираем самый эффективный

		Выполняя запрос, PostgreSQL разрабатывает для него план запроса.

		Выбор правильного плана запроса крайне важен для хорошей производительности, поэтому в системе работает сложный планировщик, задача которого подобрать хороший план.

		Узнать, какой план был выбран для какого-либо запроса, можно с помощью команды EXPLAIN.

		EXPLAIN SELECT * FROM tenk1;	

			Seq Scan on tenk1  (cost=0.00..458.00 rows=10000 width=244)

			0.00 - приблизительная стоимость запуска, прежде чем начнётся вывод данных

			458.00 - приблизительная общая стоимость операции

		С параметром ANALYZE оператор будет выполнен на самом деле, а не только запланирован. 

		При этом в вывод добавляются фактические сведения о времени выполнения, включая общее время, затраченное на каждый узел плана (в миллисекундах) и общее число строк, выданных в результате. 

		Это помогает понять, насколько близки к реальности предварительные оценки планировщика.

		EXPLAIN ANALYZE SELECT * FROM tenk1 t1, tenk2 t2 WHERE t1.unique1 < 10 AND t1.unique2 = t2.unique2;

			Planning time: 0.181 ms 

			Execution time: 0.501 ms

		Если вы хотите проанализировать запрос, изменяющий данные, но при этом сохранить прежние данные таблицы, вы можете откатить транзакцию после запроса.

			BEGIN;

				EXPLAIN ANALYZE UPDATE tenk1 SET hundred = hundred + 1 WHERE unique1 < 100;

			ROLLBACK;

		Время выполнения, измеренное командой EXPLAIN ANALYZE, может значительно отличаться от времени выполнения того же запроса в обычном режиме.

		Не следует полагать, что выводы, полученные для игрушечной таблицы, будут применимы и для настоящих больших таблиц, поэтому возможно лучше выгрузить боеву бд и использовать ее.

	Составляем запрос на orm (если возможно в разных вариациях)
		
	Профилируем orm запрос/запросы и выбираем самый эффективный

		django

			# работает при debug = True
			from django.db import connection
			print(connection.queries)

			Вспоминаем, что queryset ленивый

				Вы можете добавлять фильтры хоть весь день и Django не выполнит ни один запрос, пока QuerySet не вычислен.

					# здесь 3 фильтра, но будет выполнен один запрос в самом конце, когда мы попросим вывести значение q
					q = Entry.objects.filter(headline__startswith="What")
					q = q.filter(pub_date__lte=datetime.date.today())
					q = q.exclude(body_text__icontains="food")
					print(q)

				Срез QuerySet возвращает новый QuerySet

					Entry.objects.all()[:5]

					Entry.objects.all()[5:10]

					Обратите внимание, хотя срез не вычисленного QuerySet вернет новый не вычисленный QuerySet, вы не можете изменять его дальше (добавлять фильтры, менять сортировку и т.д.).

			Смотрим, когда вычисляется queryset

				При первом выполнении итерации

					for e in Entry.objects.all():
    					print(e.headline)

    			Если будет указан шаг среза

    				Entry.objects.all()[:10:2]

    			QuerySet будет вычислен при вызове repr()

    			QuerySet будет вычислен при выполнении len()

    				Не используйте len() с QuerySet если вам нужно узнать только количество записей в выборке. Эффективнее использовать подсчет на уровне базы данных с помощью count.

    			QuerySet будет вычислен при использовании list()

    			QuerySet будет вычислен при выполнении bool(), использовании с or, and или if

    				if Entry.objects.filter(headline="Test"):
   						pass

   					Эффективнее использовать метод exists().

   				При обращение к вызываемым атрибутам

   					entry = Entry.objects.get(id=1)
   					entry.authors.all()
   					entry.authors.all()

			Смотрим на кэширование queryset

				Для использования кэширования в QuerySet можно использовать шаблонный тэг with.

				Если у вас очень много объектов, кэширование в QuerySet может использовать большой объем памяти. В этом случае может помочь iterator().

			Смотрим на кэширование атрибутов

				entry = Entry.objects.get(id=1)
				entry.blog
				# cache
				entry.blog

				Помнить, что с собственными свойствами нужно самостоятельно реализовать кэширование, используя, например, декоратор cached_property

			Лучше использовать поле с unique или db_index в методе get(), потом что работа с индексами ускоряет запрос, а работа с unique, потому что уникальное поле исключает ситуацию, когда несколько объектов будут удовлетворять запросу.

			Используем .select_related() и prefetch_related() если нужны все данные сразу и они будут использоваться.

			Использум values() и values_list() если нужен dict или list значений.

			Используйте defer() и only(), если есть колонки в базе данных, которые вы не будете использовать. 

				Если я в дальнейшем всё же захочу их использовать, то ORM сделает дополнительный запрос для их получения, что уменьшит производительность.

			Используем .exists(), вместо if queryset.

			Используем .count(), вместо len(queryset).

			Вместо загрузки данных в объекты, изменения значений и отдельного их сохранения (в массовом обновлении), используем .update().

				Помним, что они сигналы pre/post save не сработают.

			Используем общее добавление с .bulk_create() (при массовом добавлении)

				Entry.objects.bulk_create([
				    Entry(headline="Python 3.0 Released"),
				    Entry(headline="Python 3.1 Planned")
				])

				Это относится и к ManyToManyFields

					my_band.members.add(me, my_friend)

			Не сортируем данные, если это не требуется.

				Сортировка требует ресурсы. Каждое поле, по которому производится сортировка, требует от базы данных дополнительных ресурсов. 

				Если модель имеет сортировку по-умолчанию (Meta.ordering) и она вам не нужна, уберите её из запроса с помощью order_by() (без параметров).

			Если вам необходимо только значение внешнего ключа, то оно уже в объекте и лучше взять его так:

				entry.blog_id вместо entry.blog.id

			Используем RawSQL и SQL, если предыдущие методы не помогают.

		Общее

			Смотрим на индексацию

			Смотрим на типы полей

			Выполнять задачи базы данных в базе данных, а не с помощью языка. 

Формат

	SELECT

		name,
		car

	FROM

		users

	JOIN

		cars

	WHERE

		...