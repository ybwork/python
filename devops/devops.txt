https://habr.com/ru/company/oleg-bunin/blog/459446/

про devops имхо правильно пишет, про остальное можно, в общем, поспорить
Мне было интересно, как собрать приложение в один пакет, то есть не просто нарисовать на экране какие-то кнопки, а сделать именно цельное приложение. Очевидно, код, например, на Swift и продукт в мобильном телефоне — это две совершенно разные вещи: первая очень маленькая, а вторая очень большая и включает в себя такие вопросы:

	Unit-тесты;
	статический анализ;
	Continuous Integration;
	управление зависимостями;
	Continuous Delivery;
	Staging Environment;
	процесс approve приложения в Apple Store;
	процесс сборки дефектов с продакшена и т.д.

Как расставить на экране кнопки легко прочитать в интернете. Мне нужен был специалист, эксперт, который помог бы мне собрать весь pipeline. Для меня, как программиста, это важнее, чем расставить кнопки на экране.
Я нашел такого специалиста, но он мне сказал: «Зачем ты об этом думаешь? Нарисуй сначала приложение. Какой Continuous Integration? Подожди пока с Unit-тестами — сделай, чтобы заработало. Какой Delivery pipeline? Зачем TestFlight — используй симулятор».
Наверняка, он хороший программист, но у него в голове, на мой взгляд, все перевернуто с ног на голову. Он думает, что код важен, а вся остальная упаковка вторична. На мой взгляд, это большая проблема, и об этом я и хочу поговорить.
Многие разработчики почему-то считают, что важен сам код, а сборка — это то, что делает DevOps-инженер или кто-то еще. Обычно, когда вы приходите в команду, это уже сделано и настроено. Вы попадаете в проект, где пишете код, не зная, как все в итоге попадает в продакшен. Я считаю, что то, что программисты не видят полный цикл сборки, не знают, как он устроен, — это проблема.
Сначала деплой, потом код
Я пишу книги о программировании, и знаю по себе, что книга получится хорошо, если сначала ее красиво оформить. То есть я занимаюсь оформлением книги до того, как пишу. Сначала делаю makefile, который прямо из командной строки собирает всю книгу из файлов на LaTeX, готовлю тексты, картинки, обложку. Я трачу много времени и делаю так, чтобы одной командой собрать всю книгу в PDF-файл. Уделяю большое внимание тому, как она будет выглядеть, где какие отступы, какие текстовые блоки и расстояние между ними, как будут нумероваться страницы. Когда мне все это нравится, я вижу, что все красиво собирается и все в этом продукте цельно, пусть и написана пока только одна страница, только тогда я начинаю писать книгу, и только тогда мне это доставляет удовольствие.
Чаще программисты делают наоборот: пишут, запускают на симуляторе, проверяют работу. Я считаю, что правильнее сначала деплоить, потом кодить.
Приведу еще один пример. Один начинающий разработчик вызвался делать с нами open source проект. Он выбрал Flutter, сделал первую итерацию, запустил, сказал, что все здорово и круто работает, и предложил посмотреть. Спрашиваем: «Как пробовать-то? Вот iPhone — куда нажимать?». На что он стал объяснять, куда зайти, что скачать— длинный процесс.
Нам это показалось неудобным, и в итоге он согласился, что действительно приложение надо выложить на TestFlight. Еще через какое-то время он показал приложение на TestFlight. Я понажимал на кнопки, и заметил некоторые дефекты. Я не работал с Flutter и не очень-то и хотел, но хотел быстро поправить то, что заметил. Я спросил, как мне это сделать, куда и как прислать pull request. Открываю репозиторий, readme-файл: «Это крутое приложение… нажми download…».
Инструкция была сложная и непонятная, я опять переспросил, как все это развернуть на своем компьютере. Я хотел простым нажатием нескольких кнопок на своем компьютере модифицировать чужой код, запустить симулятор и отправить pull request. Тот парень ушел это все описывать, и так и не вернулся.
Эта ситуация иллюстрирует то, что его качества, как программиста, хорошие — он смог запустить приложение. Но его качества, как человека, который видит проект целиком, оставляют желать лучшего. В итоге проект потерял не только меня, как контрибьютера, но и многих других. Этот программист не получил отдачи от окружающих, он сработал как одиночка.

в комментах еще прикапывались к оформлению книги на латехе - мол, важно содержание;
кто ж спорит, но если не настроить автоматизацию сразу, потом все меньше будет желания ее делать, все больше времени будет уходить на рутинные однотипные действия (и даже осознать это сложно, т.к. момент сложных действий придет постепенно, а ты уже привык их выполнять; как только попробуешь кому-нибудь рассказать, как это собирать - вот тут и выясняется, что нифига не очевидно и не просто);
а если потратить время на такую автоматизацию перед более-менее долгоиграющим проектом (написание книги, программы, и т.п.), будешь больше сосредоточен на том, что реально интересно - для программы это новая интересная функциональность, без постоянных мыслей о том, где что может сломаться или что не забыть сделать, когда выкладываешь приложение; для книги - собсно сборка в готовую книгу будет одной кнопкой (если латех), и после написания главы будешь сразу видеть ее в готовом виде, что мотивирует; и можно больше времени потом уделять содержанию;
еще плюс - обычно автоматизацию легко распространить на все подобные проекты: для новой книги уже будет латех-шаблон, для программы вся нужная обвязка с .gitignore, настроенным гитом, запускаторами тестов и т.п.

даже если на другой стек перейдешь (с питона на яву, к примеру) - шаги, которые упрощают жизнь уже будут известны, их польза очевидна, и в другом стеке надо просто поискать инструменты, делающие то же самое