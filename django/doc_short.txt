Оглавление

	1.1. Создание проекта

	1.2. Структура проекта от Two scoops of Django

	1.3. Настройка проекта -

	1.4. Приложения проекта от Two scoops of Django

	2. Последовательность действий

	3.1. Модели

	3.2. Миграции

	3.3. Представления

	3.4. Шаблоны -

	3.5. Url-ы -

	3.6. Тесты -

	3.7. Формы -

	3.8. Логгирование -

	3.9. Статические файлы - (сюда, как подключить и где хранить)

	3.10. Медиа файлы - (сюда, как подключить и где хранить)

	3.11. Сигналы -

	3.12. Безопасность - (сюда просто, что есть в django)

	3.13. Интерфейс администратора -

	3.14. Запросы -

	3.15. Аутентификация
	
1.1. Создание проекта

	Команды для создания виртуального окружения

		whereis python

		virtualenv --python=/usr/bin/python3.7 name_venv

		. name_venv/bin/activate

		deactivate

	Команды для создания проекта

		pip install django==1.9

		django-admin startproject name_project

1.2. Структура проекта от Two scoops of Django

	project_name/
		config/

			settings/
				__init__.py
				local.py
				production.py
				...

			__init__.py
			urls.py
			wsgi.py

		docs/

		project_name/
			media/
			name_app/
			name_app/
			static/
			templates/

		.gitignore
		README.rst
		manage.py
		requirements.txt
		package.json

	Для корректной работы меняем:

		local.py

			ROOT_URLCONF = 'config.urls'

			WSGI_APPLICATION = 'config.wsgi.application'

	Запуск и встроенные команды

		Теперь к каждой команде добавляем файл с настоойками.

			./manage.py runserver --settings=config.settings.local

	Bootstrap и другие js/css либы

		Ставим через npm и package.json

		В итоге в корне проекта появляется директория node_modules

		При деплое руками переносим нужные файлы в директорию static, потому что команда ./manage collectstatic расчитана только на приложения django, а bootstrapp, jquery и т.д. относятся ко всему проекту, а не к конкретному приложению.

	Установка через npm

		В корне проекта создаем package.json

			У него четкой правил по структуре, поэтому можно не добавлять много.

			{
			  "name": "project_name",
			  "version": "1.0.0",
			  "private": true,
			  "dependencies": {
			    "bootstrap": "",
			    "jquery": "",
			    "popper.js": ""
			  }
			}

		В терминале выполняем команду npm i

		Для просмотра установленных пакетов в терминале выполняем npm ls

	Подключение общей статики в шаблонах

		Добавляет путь к общей статике в STATICFILES_DIRS

			STATICFILES_DIRS = [
			    os.path.join(PROJECT_ROOT, 'node_modules')
			]

1.3. Настройка проекта

	...

1.4. Приложения проекта от Two scoops of Django

	Приложения должны делать только одну вещь и делать её хорошо.

	Приложения могут быть взаимосвязанны между собой.

	Название приложений могут быть, как в единственном, так и во множественном числе. Это завист от того, что делает приложение, например blog и shop будут в единственном числе, потому что на сайте один блог и один магазин, а например events и tickets будут во множественном, потому что отвечают за работу со множеством событий и билетов.

2. Последовательность действий

	Создали приложение.

	Добавили приложение в installed_apps.

	На основе структуры бд создали модель.

	Создали миграцию.

	Выполнили миграцию.

	Создали представление.

	Привязали к представлению url.

	Написали тест на функцию, которая будет в представлении (если будет и если нужно её тестировать).

	Выполнили тест (он не прошел, потому что функция ещё не написана).

	Реализовали представление.

	Ещё раз выполнили тот же тест (он прошел).

3.1. Модели

	В сообществе принято называть таблицы и модели в единственном числе.

	На основе модели в бд создается таблица в формате appname_modelname (cards_product).

	Обычная модель

		class Something(models.Model):

			id = models.AutoField(primary_key=True)

				Django добавляет такое поле по умолчанию к каждой модели (можно изменить)

			sites = models.ForeignKey(Site, verbose_name='list of sites')

				В полях типа ForeignKey, ManyToManyField и OneToOneField с помощью первого аргумента 'list of sites' можно указать читабельное название поля.

			dealer = models.ForeignKey(Dealer, related_name='cars')

				Имя для обратной связи, например если мы захотим обратиться от другой модели, то это можно сделать так Dealer.objects.first().cars

			dealer = models.ForeignKey('Dealer', on_delete=models.CASCADE)

				'Dealer' позволяет создать связь с моделью, которая еще не определена для обращения к модели из другого приложения пишем так 'name_app.Manufacturer'

			name = models.CharField('User name')

				C помощью первого аргумента 'user name' можно указать читабельное название поля

			surname = models.CharField(null=True)

				Если null=True, то сохранит в бд пустое значение из формы, как NULL

			phone = models.CharField(blank=True)

				Если blank=True, форма позволит передать пустое значение на сервер

		    SHIRT_SIZES = (
		        ('S', 'Small'),
		        ('M', 'Medium'),
		        ('L', 'Large'),
		    )
		    shirt_size = models.CharField(max_length=1, choices=SHIRT_SIZES)

		    	Виджет формы использует select и ограничит значение поля указанными значениями в SHIRT_SIZES

		    amount = models.IntegerField(default=0)

		    	Значение из default будет попадать в бд по умолчанию

		    code = models.IntegerField(primary_key=True)

		    	Поле будет первичным ключом и по умолчанию не добавится поле id 

		    email = models.CharField(unique=True)

		    	Значение в поле должно быть уникальным

			class Meta:

		        ordering = ['end_date'/'-end_date']

		        	Сортировка asc/desc

		        db_table = 'music_album'

		        	Название таблицы для этой модели

		        managed = False

		        	При миграция таблицы для этой модели не будет создаваться или удаляться это полезно, если модель отображает существующую таблицу, которая была создана другим способом

		        # остальные настройки можно посмотреть здесь

			        https://djbook.ru/rel1.9/ref/models/options.html

			        https://docs.djangoproject.com/en/2.2/ref/models/options

	Одни к одному

		class People(models.Model):
			name = models.CharField(max_length=255)

		class Pasport(models.Model):
			people = models.OneToOneField(People, on_delete=models.CASCADE)
			code = models.IntegerField()

		На основе этих моделей создадутся 2 таблицы в бд - appname_people, appname_pasport.

		В таблице appname_pasport будет связь один к одному - people_id.

	Один ко многим

		class Dealer(models.Model):
			name = models.CharField(max_length=255)

		class Car(models.Model):
			dealer = models.ForeignKey(Dealer, on_delete=models.CASCADE)

	Один ко многим на себя

		Используется например для вложенных категорий, когда главная категория имеет сслыку на свою вложенную категорию.

			class Category(models.Model):
				subcategory = models.ForeignKey('self', on_delete=models.CASCADE)

			На основе данной модели создастся таблица appname_category с полями id и subcategory_id.

	Многие ко многим

		Не имеет значения какая модель содержит поле ManyToManyField, но его может содержать только одна из моделей.

		Желательно, чтобы название поля ManyToManyField было во множественном числе.

		Обычно, ManyToManyField необходимо добавить в модель, которая будет редактироваться в форме.

			class Topping(models.Model):
			    name = models.CharField(max_length=255)

			class Pizza(models.Model):
			    toppings = models.ManyToManyField(Topping)
			    name = models.CharField(max_length=255)

			На основе данной модели в бд появятся таблицы appname_pizza, appname_topping, appname_pizza_toppings.

		Иногда необходимо хранить дополнительную информацию о связи. Например музыкальные группы, музыканты и когда музыкант вступил в группу.

			class Person(models.Model):
			    name = models.CharField(max_length=128)

			class Group(models.Model):
			    name = models.CharField(max_length=128)
			    members = models.ManyToManyField(Person, through='Membership')

			class Membership(models.Model):
			    person = models.ForeignKey(Person, on_delete=models.CASCADE)
			    group = models.ForeignKey(Group, on_delete=models.CASCADE)
			    date_joined = models.DateField()
			    invite_reason = models.CharField(max_length=64)

			На основе этих моделей создадутся таблицы appname_person, appname_group, appname_membership (здесь будет находиться связи - person_id, group_id и доп. данные - date_joined, invite_reason)

	Класс пользовательское модели должен наследоваться от models.Model

		class Author(models.Model):

	Multi-table наследование

		Каждая модель имеет собственную таблицу в базе данных и может быть использована независимо.

		Наследование использует связь между родительской и дочерней моделью через автоматически созданное поле OneToOneField.

		Все поля родительской модели будут доступны в дочерней при том, что значения будут храниться в разных таблицах.

		Дочерняя модель не имеет доступа к родительскому классу Meta.

		Можно не наследовать настроеки Meta родительской модели.

		При использовании ForeignKey и ManyToManyField в дочерней модели по отношении к родительской обязательно нужно указать related_name/

	Для определении общих полей для некскольких моделей используются абстрактные модели

		class CommonInfo(models.Model):
		    name = models.CharField(max_length=100)
		    age = models.PositiveIntegerField()

		    class Meta:
		        abstract = True

		class Student(CommonInfo):

		class Teacher(CommonInfo):

		Запрещено переопределять атрибуты класса родителя в дочернем классе. То есть если родительская модель имеет поле author, вы не можете создать поле с именем author в дочерних моделях.

	Для переопределения поведения модели (сортировка, менеджер и т.д.) не меняя структуры базы данных используются proxy модели

		class Person(models.Model):
		    name = models.CharField(max_length=30)

		class ProxyPerson(Person):
			objects = NewManager()

		    class Meta:
		        proxy = True

		Если вы не определите ни один менеджер для proxy модели, он будет унаследован от родительской модели.

		Proxy модель использует ту же таблицу в базе данных, что и оригинальная.

		Proxy модель должна наследоваться от одной модели.

	Множественное наследование

		class Article(models.Model):
		    article_id = models.AutoField(primary_key=True)

		class Book(models.Model):
		    book_id = models.AutoField(primary_key=True)

		class BookReview(Book, Article):
		    pass

		Если есть несколько родительских объектов с классом Meta, в таком случае будет использован атрибут первой родительской модели, остальные будут проигнорированы.

		Наследование от нескольких моделей, которые содержат первичное поле id, вызовет ошибку.Чтобы избежать этой проблемы, можно явно указать AutoField поля в базовых моделях.

	Менеджер модели

		Это интерфейс, через который создаются запросы.

		Каждая модель имеет хотя бы один менеджер.

		Первый менеджер, который заметит Django будет менеджер по умолчанию.

			Менеджером по умолчанию становится первый менеджер, определенный в модели.

			Если он отсутствует, используется менеджер по умолчанию первого абстрактного класса среди родительских моделей, если он существует. 

			Если таким образом не удалось определить менеджер по умолчанию, используется стандартный менеджер Django.

		Менеджеры обычных моделей не наследуются дочерними.

		Менеджеры абстрактного моделей наследуются дочерними (имена дочернего класса переопределяют имена родительского).

		Обычно менеджеры предназначены для работы с моделью, к которой принадлежат, поэтому наследовать их в дочерних моделях - не всегда хорошая идея.

		По умолчанию Django добавляет менеджер с именем objects для каждого класса модели.

			Author.objects.first()

		Можно переименовать Manager

			class Person(models.Model):
			    people = models.Manager()

		Методы менеджера могут возвращать что угодно. И это не обязательно должен быть QuerySet.

		Базовый QuerySet менеджера возвращает все объекты модели.

			Book.objects.all()

		Вы можете изменить базовый QuerySet, переопределив метод get_queryset()

			class BookManager(models.Manager):
			    def get_queryset(self):
			        return super().get_queryset().filter(author='dahl')

			class Book(models.Model):
			    title = models.CharField(max_length=100)
			    author = models.CharField(max_length=50)

			    objects = models.Manager()
			    custom_manager = BookManager()

			Book.custom_manager.all()

		Можно добавить столько угодно экземпляров менеджера.

		Можно добавлять собственные методы в переопределенный QuerySet

			class PersonManager(models.Manager):
			    def get_queryset(self):
			        return PersonQuerySet(self.model, using=self._db)

			    def authors(self):
			        return self.get_queryset().authors()

			    def editors(self):
			        return self.get_queryset().editors()

	Queryset модели

		Queryset-ы модели более гибче, чем менеджеры модели и похожи на фильтры. 

		Используются не вместо Book.objects, а вместе с Book.objects.queryset_method()

			class ProductCardQuerySet(models.QuerySet):
				def get_actual(self):
					return self.filter(is_actual=True)

			objects = ProductCardQuerySet.as_manager()

			ProductCard.objects.get_actual()

		В кастомном queryset-е не переопределяется метод get_queryset, только в кастомном менеджере.

		Не каждый метод QuerySet следует добавлять в менеджер. Для этого можно создать метод внутри QuerySet с атрибутом queryset_only равным True.

		    def method_name(self):
		    	...
		        return result
		    method_name.queryset_only = True

3.2. Миграции

	Основы работы

		Создали и описали модель.

		Выполнили ./manage.py makemigrations

		В приложении в директории migrations создался файл.

		Выполнили ./manage.py migrate

		В базе создались таблицы.

		Добавили в модель новое поле.

		Выполнили ./manage.py makemigrations

		В приложении в директории migrations создался новый файл.

		Выполнили ./manage.py migrate

		В базе в нужной таблице создалось поле, которое добавили в модель.

		Удалили новое поле из модели.

		Выполнили ./manage.py makemigrations

		В приложении в директории migrations создался еще один файл. При этом предыдущие два остались.

		Выполнили ./manage.py migrate

		В базе в нужной таблице удалилось поле, которое удалили из модели.

		Если нужно вернуть выполненную миграцию, то ./manage.py migrate my_app zero

		Для просмотра миграций ./manage.py showmigrations
	
	Тестирование работы в бою

		Заливаем актуальный дамп в бд.

		Создаем новое поле в модели.

		Выполняем ./manage.py makemigrations

		Выполняем ./manage.py migrate

		Должно успешно создасться новое поле в бд.

	Команды

		./manage.py makemigrations

			--empty - создает пустую миграцию для последующего редактирования вручную

			--merge - решает конфликты с миграциями

			--name - задает имя миграции

		./manage.py migrate

			<app_label>

			<app_label> <migrationname>

			--database

			--fake - помечает миграции, как невыполненные (может “сломать” автоматическое применение миграций)

			--fake-initial - помечает миграции, как выполненные

		./manage.py showmigrations

		./manage.py migrate my_app zero

3.3. Представления

	Определяются в файле views.py

	Это функция или метод класса, которая принимает запрос и возвращает ответ.

		def home(request):
			return HttpResponse('home')

		class ProductView(View):
			def get(self, request):
				return HttpResponse('all products')

			def post(self, request):
				return HttpResponse('create product')

			def put(self, request):
				return HttpResponse('edit product')

			def delete(self, request):
				return HttpResponse('delete product')

	Чтобы представление работало его нужно привязать к определенному URL-у.

		path('home', views.home, name='home')

		path('product', ProductView.as_view(), name='product')

		path('category', CategoryListView.as_view(), name='category')

	Встроенные (generic) представления классы

		Нужны для решения тривиальных задач.

		Попытка скрестить более чем один generic класс не будет работать так, как вы ожидаете.

		Общие классы представления автоматически создают класс ModelForm при работе с моделями.

		Подробное описание и все методы смотреть здесь:

			https://djbook.ru/rel1.9/ref/class-based-views/flattened-index.html

			https://docs.djangoproject.com/en/2.2/ref/class-based-views/flattened-index/

		TemplateView

			Обрабатывает заданный шаблон.

			class HomePageView(TemplateView):
			    template_name = '/path_to_templage/home.html'

		RedirectView

			Редирект на заданный URL.

			Если переданный URL равен None, Django вернет исключение HttpResponseGone (410).

			class ArticleCounterRedirectView(RedirectView):
				# должно ли перенаправление быть постоянным
			    permanent = False

			    # передавать ли строку GET запроса в новую локацию
			    query_string = True

			    # название URL-шаблона на который перенаправлять
			    pattern_name = 'article-detail'

    	DetailView

    		Берет из бд и отображает детальную информацию одного объекта.

    		class PublisherDetailView(DetailView):
			    model = Publisher

		ListView

			Берет из бд и отображает список объектов.

			В шаблоне список всех объектов по умолчанию будет в object_list или modelname_list.

			class PublisherListView(ListView):
    			model = Publisher
    			template_name = '/books/publisher_list.html'

    			# имя list объектов для доступа в шаблоне
    			context_object_name = 'my_favorite_publishers'

		FormView

			Для работы с формой (инициализирующий GET запрос, POST с верными или неверными данными).

			forms.py

				from django import forms

				class ContactForm(forms.Form):
				    name = forms.CharField()
				    message = forms.CharField(widget=forms.Textarea)

			views.py

				class ContactFormView(FormView):
				    template_name = '/path_to_template/contact.html'
				    form_class = ContactForm
				    success_url = reverse_lazy(viename='home')

		CreateView

			Для создания объекта.

			Если вы указали и fields и form_class, будет вызвано исключение ImproperlyConfigured.

			class AuthorCreateView(CreateView):
			    model = Author

			    # поля формы для создания
			    fields = ['name']

			Вместе с CreateView используется форма

				<form action="" method="post">
					{% csrf_token %}
				    {{ form.as_p }}
				    <button type="submit">create<button/>
				</form>

				Django ожидает увидеть эту форму в name_app и с названием namemodel_form.html

				Чтобы изменить это поведение можно использовать template_name для полного указания шаблона и его местоположения.

			Пример с использованием AJAX

				class AjaxableResponseMixin(object):
				    def form_invalid(self, form):
				        response = super(AjaxableResponseMixin, self).form_invalid(form)
				        if self.request.is_ajax():
				            return JsonResponse(form.errors, status=400)
				        else:
				            return response

				    def form_valid(self, form):
				        response = super(AjaxableResponseMixin, self).form_valid(form)
				        if self.request.is_ajax():
				            data = {
				                'pk': self.object.pk,
				            }
				            return JsonResponse(data)
				        else:
				            return response

				class AuthorCreate(AjaxableResponseMixin, CreateView):
				    model = Author
				    fields = ['name']

		UpdateView

			Для редактирования объекта.

			Если вы указали и fields и form_class, будет вызвано исключение ImproperlyConfigured.

			class AuthorUpdateView(UpdateView):
			    model = Author

			    # поля формы для редактирования
			    fields = ['name']

		DeleteView

			Для удаления объекта.

			Если вы указали и fields и form_class, будет вызвано исключение ImproperlyConfigured.

			reverse_lazy используется, потому что urls ещё не загрузились при импорте файла.

			class AuthorDeleteView(DeleteView):
			    model = Author
			    success_url = reverse_lazy(viewname='author-list')

		Так же уществуют общие классы представления для работы с датами: DateDetailView, TodayArchiveView, DayArchiveView, WeekArchiveView, MonthArchiveView, YearArchiveView. ArchiveIndexView.

		Миксины

			Это классы, которые хранят в себе общий код для повторного использования в других классах.

			Чем больше реализация методов будет размазана по примесям, тем сложнее будет читать дочерний класс и понимать что же он всё-таки делает, какие методы откуда берутся и какие методы уже перекрыты в родительских классах. Поэтому с миксинами лучше не грубить.

				class AjaxableResponseMixin(object):
				    def form_invalid(self, form):
				        response = super(AjaxableResponseMixin, self).form_invalid(form)
				        if self.request.is_ajax():
				            return JsonResponse(form.errors, status=400)
				        else:
				            return response

				    def form_valid(self, form):
				        response = super(AjaxableResponseMixin, self).form_valid(form)
				        if self.request.is_ajax():
				            data = {
				                'pk': self.object.pk,
				            }
				            return JsonResponse(data)
				        else:
				            return response

				class AuthorCreate(AjaxableResponseMixin, CreateView):
				    model = Author
				    fields = ['name']

			Миксины классов представлений

				ContextMixin - для работы с контекстом шаблона

				TemplateResponseMixin - для работы с шаблоном

				SingleObjectMixin - для работы с одиночным объектом

				SingleObjectTemplateResponseMixin - для работы с шаблоном и одиночным объектом

				MultipleObjectMixin - для работы с множеством объектов

				MultipleObjectTemplateResponseMixin - для работы с множеством объектов и шаблоном

				FormMixin - для создания и отображения формы

				ModelFormMixin - для создания и отображения модельной формы

				ProcessFormView - для работы с формой в рамках GET и POST запросов

				DeletionMixin - для работы с удалением

				YearMixin, MonthMixin, DayMixin, WeekMixin, DateMixin - для работы с датами

				Подробней смотреть здесь:

					https://docs.djangoproject.com/en/2.2/ref/class-based-views/mixins/

		Декорирование представлений классов

			Расширение представлений-классов не ограничивается использованием миксинов, также можно подключить декораторы.

			Для декорирования каждого метода представления класса, нужно декорировать метод dispatch().

				Метод класса не то же самое, что и обычная функция, к нему просто так применить декоратор не получится.

				Нужно сначала преобразовать его в метод декоратор. Для этого существует декоратор method_decorator.

					@method_decorator(login_required)
					def dispatch(self, *args, **kwargs):
					    return super(ProtectedView, self).dispatch(*args, **kwargs)

					Также вы можете декорировать класс, указав название методы, которые необходимо декорировать, в аргументе name.

						@method_decorator(login_required, name='dispatch')
						class ProtectedView(TemplateView):
						    template_name = 'secret.html'

					Если у вас есть список декораторов, которые используются в нескольких местах, вы можете указать список или кортеж декораторов и использовать его в method_decorator() несколько раз. При этом декораторы обрабатывают запрос в указанном порядке.

						decorators = [never_cache, login_required]

						@method_decorator(decorators, name='dispatch')
						class ProtectedView(TemplateView):
						    template_name = 'secret.html'

		Обработка форм с помощью представлений классов

			class MyFormView(View):
			    form_class = MyForm
			    initial = {'key': 'value'}
			    template_name = 'form_template.html'

			    def get(self, request, *args, **kwargs):
			        form = self.form_class(initial=self.initial)
			        return render(request, self.template_name, {'form': form})

			    def post(self, request, *args, **kwargs):
			        form = self.form_class(request.POST)

			        if form.is_valid():
			            return HttpResponseRedirect('/success/')
			        return render(request, self.template_name, {'form': form})

3.4. Шаблоны

	Стоп - https://djbook.ru/rel1.9/topics/templates.html (Язык шаблонов Django)

	Шаблон - это просто текстовый файл, или строка Python.

	Шаблоны содержат статический HTML и динамические данные.

	Загрузка шаблона включает в себя поиск шаблона по названию и предварительную обработку, обычно выполняется загрузка шаблона в память. 

	Рендеринг означает передачу данных контекста в шаблон и возвращение строки с результатом.

	Шаблоны можно настроить с помощью настройки TEMPLATES, но по умолчанию они настроенны нормально.

	Для загрузки шаблона рекомендуется использовать метод get_template или select_template.

	Если вызвать get_template('story_detail.html'), Django будет искать следующие файлы:

		/home/html/example.com/story_detail.html

	Вы можете использовать select_template для гибкой загрузки шаблонов. 

		Например, вы написали новость и хотите использовать другой шаблон для некоторых новостей. 

		Вы можете использовать select_template(['story_%s_detail.html' % story.id, 'story_detail.html']). 

		Это позволить создать отдельный шаблон для определенных новостей, а для всех остальных использовать шаблон по умолчанию.

	Ребята из 'two scoops of django' предлагают использовать Jinja2.

	Структура by 'two scoops of django'

		2-ух уровневая

			templates/

				base.html

				profiles/

					profile_detail.html # extends base.html

					profile_form.html # extends base.html

		3-х уровневая

			Подходит для сайтов с совершенно разными макетами для каждой страницы.

			templates/

				base.html

				profiles/

					base_profiles.html # extends base.html

					profile_detail.html # extends base_profiles.html

					profile_form.html # extends base_profiles.html

	Язык шаблонов


3.15. Аутентификация

	https://djbook.ru/rel1.9/topics/auth/index.html

	https://djbook.ru/rel1.9/topics/auth/default.html

	https://docs.djangoproject.com/en/2.2/topics/auth/

	https://docs.djangoproject.com/en/2.2/topics/auth/default/