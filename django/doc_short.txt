Оглавление

	1.1. Создание проекта

	1.2. Структура проекта by two scoops of django

	1.3. Локальная настройка проекта by two scoops of django -

	1.4. Приложения проекта by two scoops of Django

	2. Последовательность действий

	3.1. Модели

	3.2. Миграции

	3.3. Представления

	3.4. Шаблоны

	3.5. Url-ы

	3.6. Unit тесты

	3.7. Формы

	3.8. Логгирование

	3.9. Статические файлы

	3.10. Медиа файлы

	3.11. Сигналы

	3.12. Безопасность

	3.13. Интерфейс администратора

	3.14. Запросы

	3.15. Аутентификация

	3.16. Кэширование

	4.1. Советы
	
1.1. Создание проекта

	Команды для создания виртуального окружения

		whereis python

		virtualenv --python=/usr/bin/python3.7 name_venv

		. name_venv/bin/activate

		deactivate

	Команды для создания проекта

		pip install django==1.9

		django-admin startproject name_project

1.2. Структура проекта by two scoops of django

	project_name/
		config/
			__init__.py
			urls.py
			wsgi.py

			settings/
				__init__.py
				local.py
				production.py

		node_modules/
			jquery/
			uikit/

		docs/

		project_name/
			__init__.py
			app_name/
				migrations/
					__init__.py

				static/
					app_name/
						css/
						js/

				tests
					__init__.py
					test_methods.py

				__init__.py
				admin.py
				apps.py
				models.py
				urls.py
				views.py

			logs/
				.gitkeep

			media/
				article/
				price/

			static/
				admin/
				jquery/
				app_name/

			templates/
				auth/
				emails/
					.gitkeep
				main/
				base.html

		.gitignore
		README.rst
		manage.py
		requirements.txt
		package.json

1.3. Локальная настройка проекта by two scoops of django

	Найстройка структуры

		Перешли в место, где храняться виртуальные окружения.

		Открыли терминал.

		Создали новое виртуальное окружение.

			virtualenv --python=/usr/bin/python3.6 env_name

		Активировали виртуальное окружение.

			. env_name/bin/activate

		Установили django

			pip3 install django

		Создали базовый проект 

			django-admin startproject mysite

		Поменяли структуру проекта согласно структуре из two scoops of django

	Для корректной работы в local.py

		ROOT_URLCONF = 'config.urls'

		WSGI_APPLICATION = 'config.wsgi.application'

	Запуск

		./manage.py runserver --settings=config.settings.local

	Миграции

		Будут создаваться в директории migrations для каждого приложения.

		./manage.py migrate --settings=config.settings.local

	Шаблоны

		В local.py TEMPLATES задаем 'DIRS': [os.path.join(PROJECT_ROOT, 'project_name/templates/')]

		Создаем в project_name/project_name/ директорию templates/

		Создаем базовый шаблон внутри директории templates/, например templates/base.html

		Для каждого приложения создаем директорию внутри templates/ с именем приложения, например project_name/project_name/templates/products

		Создаем внутри директории с именем приложения файл шаблона, например project_name/project_name/templates/products/product_list.html

		Для обращения внутри view пишем путь в формате 'app_name/template_name.html', например 'products/product_list.html' 

	Статика

		Моя

			В local.py добавляем:

				STATIC_URL = '/static/'

				STATIC_ROOT = os.path.join(PROJECT_ROOT, 'project_name/static/')

			В project_name/project_name/ создаем директорию static

			Выполняем команду для сборки.

		Библиотеки

			В local.py добавляем:

				STATICFILES_DIRS = [
				    os.path.join(PROJECT_ROOT, 'node_modules')
				]

			В project_name/ создаем директорию node_modules

			В project_name/ создаем файл package.json

				{
				  "name": "project_name",
				  "version": "1.0.0",
				  "private": true,
				  "dependencies": {
				    "jquery": "",
				    "uikit": ""
				  }
				}

			В терминале выполняем команду для установки: npm i

			Для просмотра установленных пакетов в терминале выполняем npm ls.

			Выполняем команду для сборки.

			При деплое руками переносим нужные файлы в директорию static, потому что команда ./manage collectstatic расчитана только на приложения django, а bootstrapp, jquery и т.д. относятся ко всему проекту, а не к конкретному приложению.

		Сборка 

			./manage.py collectstatic --settings=config.settings.local

	Логгирование

		В local.py добавляем:

			LOGGING = {
			    'version': 1,
			    'disable_existing_loggers': False,
			    'handlers': {
			        'file': {
			            'level': 'WARNING',
			            'class': 'logging.FileHandler',
			            'filename': os.path.join(PROJECT_ROOT, 'project_name/logs/warning.log'),
			        },
			        'mail_admins': {
			            'level': 'ERROR',
			            'class': 'django.utils.log.AdminEmailHandler'
			        }
			    },
			    'loggers': {
			        'default': {
			            'handlers': ['mail_admins', 'file'],
			            'level': 'ERROR',
			            'propagate': True,
			        }
			    }
			}

			EMAIL_BACKEND = 'django.core.mail.backends.filebased.EmailBackend'
			EMAIL_FILE_PATH = os.path.join(PROJECT_ROOT, 'project_name/templates/emails/')

		В project_name/project_name/ создаем директорию logs

			Внутри будет автоматом создаваться файл warning.log и туда будут писаться логи

		В project_name/project_name/templates создаем директорию emails

			Внутри будет автоматом создаваться файлы-сообщения (.log), имитирующие реальные сообщения из почты

		Для проверки в любом view пишем: 

			logger.error('Something went wrong!')

	Отправка почты

		В local.py добавляем:

			EMAIL_BACKEND = 'django.core.mail.backends.filebased.EmailBackend'
			EMAIL_FILE_PATH = os.path.join(PROJECT_ROOT, 'project_name/templates/emails/')

		В project_name/project_name/templates создаем директорию emails

			Внутри будет автоматом создаваться файлы-сообщения (.log), имитирующие реальные сообщения из почты

		Для проверки в любом view пишем:

			send_mail(
				subject='Subject here',
				message='Here is the message.',
				from_email='from@example.com',
				recipient_list=['to@example.com']
			)

	Медиа

		В local.py добавляем:

			MEDIA_URL = '/media/'
			MEDIA_ROOT = os.path.join(PROJECT_ROOT, 'project_name/media/')

		В главный файл с ulrl-ами добавляем:

			urlpatterns = [тут другие url-ы] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

		В project_name/project_name/ добавляем директорию media

		В модель добавляем поле для хранения картинки или файла:

			image = models.ImageField(upload_to='article/')

		В директории media создаем директорию равную директории из upload_to, который находится в поле модели

			Например project_name/project_name/media/article/

		Для проверки

			model.py

				class Article(models.Model):
				    image = models.ImageField(upload_to='article/')

			view.py

				class ArticleCreateView(CreateView):
					model = Article
					fields = ['image', 'price']
					success_url = reverse_lazy('main:article_list')


				class ArticleListView(ListView):
					model = Article

			urls.py

				app_name = 'main'
				urlpatterns = [
				    path(
				        route='articles/create',
				        view=views.ArticleCreateView.as_view(),
				        name='article_create'
				    ),
				    path(
				        route='articles/list',
				        view=ArticleListView.as_view(),
				        name='article_list'
				    )
				] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

			article_form.html

		        <form method="POST" action="{% url 'main:article_create' %}" enctype="multipart/form-data">
		            {% csrf_token %}
		            {{ form }}
		            <button type="submit">Create</button>
		        </form>

		    article_list.html

		        {% for article in object_list %}
		            <img src="{{ article.image.url }}"/>
		        {% endfor %}

	Тесты

		Внутри приложения создаем директорию tests в которую кладем __init__.py и test_methods.py

			app_name/
				tests/
					__init__.py
					test_methods.py

		Все методы внутри test_methods.py начинаем со слова test

			class ArticleMethodsTests(TestCase):
			    def test_article_create(self):
			        self.assertEqual(1, 0)

		Запускаем с помощью ./manage.py test --settings=config.settings.local

	Кэширование

		Docker
		
			docker pull memcached

			docker run --name memcache -p 11211:11211 -d memcached

			docker start memcached

		Django

			pip install python-memcached

		Settings

			CACHES = {
			    'default': {
			        'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache',
			        'LOCATION': '127.0.0.1:11211',
			    }
			}

		Проверка работы

			cache.set('my_key', 'hello, world!', 30)
			print(cache.get('my_key'))
			
	Celery

		Должен быть установлен брокер сообщний, например RabbitMQ.

		Заходим в брокер и создаем хост, например project_name.

			В панели rabbitmq переходим в admin - virtual hosts

			Задаем имя и нажимаем Add virtual host

		Устанавливаем celery

			pip install celery

		В файле с настройками проекта задаем настройки для celery

			CELERY_BROKER_URL = 'amqp://user_name:user_password@localhost:5672/host_name'

			CELERY_ACKS_LATE = True

		В poject_name/config/ создаем celery.py

			os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'settings.local')

			app = Celery('project_name')

			app.config_from_object('django.conf:settings', namespace='CELERY')
			app.autodiscover_tasks()

		В директории с manage.py создаем файл __init__.py

			from __future__ import absolute_import, unicode_literals
			from .celery import app as celery_app

			__all__ = ('celery_app',)

			Это гарантирует, что celery загрузится при старте django.

	Readme

		...

1.4. Приложения проекта by two scoops of Django

	Приложения должны делать только одну вещь и делать её хорошо.

	Приложения могут быть взаимосвязанны между собой.

	Название приложений могут быть, как в единственном, так и во множественном числе. Это завист от того, что делает приложение, например blog и shop будут в единственном числе, потому что на сайте один блог и один магазин, а например events и tickets будут во множественном, потому что отвечают за работу со множеством событий и билетов.

2. Последовательность действий

	Создали приложение.

	Добавили приложение в installed_apps.

	На основе структуры бд создали модель.

	Создали миграцию.

	Выполнили миграцию.

	Создали представление.

	Привязали к представлению url.

	Написали тест на функцию, которая будет в представлении (если будет и если нужно её тестировать).

	Выполнили тест (он не прошел, потому что функция ещё не написана).

	Реализовали представление.

	Ещё раз выполнили тот же тест (он прошел).

3.1. Модели

	В сообществе принято называть таблицы и модели в единственном числе.

	На основе модели в бд создается таблица в формате appname_modelname (cards_product).

	Обычная модель

		class Something(models.Model):

			id = models.AutoField(primary_key=True)

				Django добавляет такое поле по умолчанию к каждой модели (можно изменить)

			sites = models.ForeignKey(Site, verbose_name='list of sites')

				В полях типа ForeignKey, ManyToManyField и OneToOneField с помощью первого аргумента 'list of sites' можно указать читабельное название поля.

			dealer = models.ForeignKey(Dealer, related_name='cars')

				Имя для обратной связи, например если мы захотим обратиться от другой модели, то это можно сделать так Dealer.objects.first().cars

			dealer = models.ForeignKey('Dealer', on_delete=models.CASCADE)

				'Dealer' позволяет создать связь с моделью, которая еще не определена для обращения к модели из другого приложения пишем так 'name_app.Manufacturer'

			name = models.CharField('User name')

				C помощью первого аргумента 'user name' можно указать читабельное название поля

			surname = models.CharField(null=True)

				Если null=True, то сохранит в бд пустое значение из формы, как NULL

			phone = models.CharField(blank=True)

				Если blank=True, форма позволит передать пустое значение на сервер

		    SHIRT_SIZES = (
		        ('S', 'Small'),
		        ('M', 'Medium'),
		        ('L', 'Large'),
		    )
		    shirt_size = models.CharField(max_length=1, choices=SHIRT_SIZES)

		    	Виджет формы использует select и ограничит значение поля указанными значениями в SHIRT_SIZES

		    amount = models.IntegerField(default=0)

		    	Значение из default будет попадать в бд по умолчанию

		    code = models.IntegerField(primary_key=True)

		    	Поле будет первичным ключом и по умолчанию не добавится поле id 

		    email = models.CharField(unique=True)

		    	Значение в поле должно быть уникальным

			class Meta:

		        ordering = ['end_date'/'-end_date']

		        	Сортировка asc/desc

		        db_table = 'music_album'

		        	Название таблицы для этой модели

		        managed = False

		        	При миграция таблицы для этой модели не будет создаваться или удаляться это полезно, если модель отображает существующую таблицу, которая была создана другим способом

		        # остальные настройки можно посмотреть здесь

			        https://djbook.ru/rel1.9/ref/models/options.html

			        https://docs.djangoproject.com/en/2.2/ref/models/options

	Одни к одному

		class People(models.Model):
			name = models.CharField(max_length=255)

		class Pasport(models.Model):
			people = models.OneToOneField(People, on_delete=models.CASCADE)
			code = models.IntegerField()

		На основе этих моделей создадутся 2 таблицы в бд - appname_people, appname_pasport.

		В таблице appname_pasport будет связь один к одному - people_id.

	Один ко многим

		class Dealer(models.Model):
			name = models.CharField(max_length=255)

		class Car(models.Model):
			dealer = models.ForeignKey(Dealer, on_delete=models.CASCADE)

	Один ко многим на себя

		Используется например для вложенных категорий, когда главная категория имеет сслыку на свою вложенную категорию.

			class Category(models.Model):
				subcategory = models.ForeignKey('self', on_delete=models.CASCADE)

			На основе данной модели создастся таблица appname_category с полями id и subcategory_id.

	Многие ко многим

		Не имеет значения какая модель содержит поле ManyToManyField, но его может содержать только одна из моделей.

		Желательно, чтобы название поля ManyToManyField было во множественном числе.

		Обычно, ManyToManyField необходимо добавить в модель, которая будет редактироваться в форме.

			class Topping(models.Model):
			    name = models.CharField(max_length=255)

			class Pizza(models.Model):
			    toppings = models.ManyToManyField(Topping)
			    name = models.CharField(max_length=255)

			На основе данной модели в бд появятся таблицы appname_pizza, appname_topping, appname_pizza_toppings.

		Иногда необходимо хранить дополнительную информацию о связи. Например музыкальные группы, музыканты и когда музыкант вступил в группу.

			class Person(models.Model):
			    name = models.CharField(max_length=128)

			class Group(models.Model):
			    name = models.CharField(max_length=128)
			    members = models.ManyToManyField(Person, through='Membership')

			class Membership(models.Model):
			    person = models.ForeignKey(Person, on_delete=models.CASCADE)
			    group = models.ForeignKey(Group, on_delete=models.CASCADE)
			    date_joined = models.DateField()
			    invite_reason = models.CharField(max_length=64)

			На основе этих моделей создадутся таблицы appname_person, appname_group, appname_membership (здесь будет находиться связи - person_id, group_id и доп. данные - date_joined, invite_reason)

	Класс пользовательское модели должен наследоваться от models.Model

		class Author(models.Model):

	Multi-table наследование

		Каждая модель имеет собственную таблицу в базе данных и может быть использована независимо.

		Наследование использует связь между родительской и дочерней моделью через автоматически созданное поле OneToOneField.

		Все поля родительской модели будут доступны в дочерней при том, что значения будут храниться в разных таблицах.

		Дочерняя модель не имеет доступа к родительскому классу Meta.

		Можно не наследовать настроеки Meta родительской модели.

		При использовании ForeignKey и ManyToManyField в дочерней модели по отношении к родительской обязательно нужно указать related_name/

	Для определении общих полей для некскольких моделей используются абстрактные модели

		class CommonInfo(models.Model):
		    name = models.CharField(max_length=100)
		    age = models.PositiveIntegerField()

		    class Meta:
		        abstract = True

		class Student(CommonInfo):

		class Teacher(CommonInfo):

		Запрещено переопределять атрибуты класса родителя в дочернем классе. То есть если родительская модель имеет поле author, вы не можете создать поле с именем author в дочерних моделях.

	Для переопределения поведения модели (сортировка, менеджер и т.д.) не меняя структуры базы данных используются proxy модели

		class Person(models.Model):
		    name = models.CharField(max_length=30)

		class ProxyPerson(Person):
			objects = NewManager()

		    class Meta:
		        proxy = True

		Если вы не определите ни один менеджер для proxy модели, он будет унаследован от родительской модели.

		Proxy модель использует ту же таблицу в базе данных, что и оригинальная.

		Proxy модель должна наследоваться от одной модели.

	Множественное наследование

		class Article(models.Model):
		    article_id = models.AutoField(primary_key=True)

		class Book(models.Model):
		    book_id = models.AutoField(primary_key=True)

		class BookReview(Book, Article):
		    pass

		Если есть несколько родительских объектов с классом Meta, в таком случае будет использован атрибут первой родительской модели, остальные будут проигнорированы.

		Наследование от нескольких моделей, которые содержат первичное поле id, вызовет ошибку.Чтобы избежать этой проблемы, можно явно указать AutoField поля в базовых моделях.

	Менеджер модели

		Это интерфейс, через который создаются запросы.

		Каждая модель имеет хотя бы один менеджер.

		Первый менеджер, который заметит Django будет менеджер по умолчанию.

			Менеджером по умолчанию становится первый менеджер, определенный в модели.

			Если он отсутствует, используется менеджер по умолчанию первого абстрактного класса среди родительских моделей, если он существует. 

			Если таким образом не удалось определить менеджер по умолчанию, используется стандартный менеджер Django.

		Менеджеры обычных моделей не наследуются дочерними.

		Менеджеры абстрактного моделей наследуются дочерними (имена дочернего класса переопределяют имена родительского).

		Обычно менеджеры предназначены для работы с моделью, к которой принадлежат, поэтому наследовать их в дочерних моделях - не всегда хорошая идея.

		По умолчанию Django добавляет менеджер с именем objects для каждого класса модели.

			Author.objects.first()

		Можно переименовать Manager

			class Person(models.Model):
			    people = models.Manager()

		Методы менеджера могут возвращать что угодно. И это не обязательно должен быть QuerySet.

		Базовый QuerySet менеджера возвращает все объекты модели.

			Book.objects.all()

		Вы можете изменить базовый QuerySet, переопределив метод get_queryset()

			class BookManager(models.Manager):
			    def get_queryset(self):
			        return super().get_queryset().filter(author='dahl')

			class Book(models.Model):
			    title = models.CharField(max_length=100)
			    author = models.CharField(max_length=50)

			    objects = models.Manager()
			    custom_manager = BookManager()

			Book.custom_manager.all()

		Можно добавить столько угодно экземпляров менеджера.

		Можно добавлять собственные методы в переопределенный QuerySet

			class PersonManager(models.Manager):
			    def get_queryset(self):
			        return PersonQuerySet(self.model, using=self._db)

			    def authors(self):
			        return self.get_queryset().authors()

			    def editors(self):
			        return self.get_queryset().editors()

	Queryset модели

		Queryset-ы модели более гибче, чем менеджеры модели и похожи на фильтры. 

		Используются не вместо Book.objects, а вместе с Book.objects.queryset_method()

			class ProductCardQuerySet(models.QuerySet):
				def get_actual(self):
					return self.filter(is_actual=True)

			objects = ProductCardQuerySet.as_manager()

			ProductCard.objects.get_actual()

		В кастомном queryset-е не переопределяется метод get_queryset, только в кастомном менеджере.

		Не каждый метод QuerySet следует добавлять в менеджер. Для этого можно создать метод внутри QuerySet с атрибутом queryset_only равным True.

		    def method_name(self):
		    	...
		        return result
		    method_name.queryset_only = True

3.2. Миграции

	Основы работы

		Создали и описали модель.

		Выполнили ./manage.py makemigrations

		В приложении в директории migrations создался файл.

		Выполнили ./manage.py migrate

		В базе создались таблицы.

		Добавили в модель новое поле.

		Выполнили ./manage.py makemigrations

		В приложении в директории migrations создался новый файл.

		Выполнили ./manage.py migrate

		В базе в нужной таблице создалось поле, которое добавили в модель.

		Удалили новое поле из модели.

		Выполнили ./manage.py makemigrations

		В приложении в директории migrations создался еще один файл. При этом предыдущие два остались.

		Выполнили ./manage.py migrate

		В базе в нужной таблице удалилось поле, которое удалили из модели.

		Если нужно вернуть выполненную миграцию, то ./manage.py migrate my_app zero

		Для просмотра миграций ./manage.py showmigrations
	
	Тестирование работы в бою

		Заливаем актуальный дамп в бд.

		Создаем новое поле в модели.

		Выполняем ./manage.py makemigrations

		Выполняем ./manage.py migrate

		Должно успешно создасться новое поле в бд.

	Команды

		./manage.py makemigrations

			--empty - создает пустую миграцию для последующего редактирования вручную

			--merge - решает конфликты с миграциями

			--name - задает имя миграции

		./manage.py migrate

			<app_label>

			<app_label> <migrationname>

			--database

			--fake - помечает миграции, как невыполненные (может “сломать” автоматическое применение миграций)

			--fake-initial - помечает миграции, как выполненные

		./manage.py showmigrations

		./manage.py migrate my_app zero

3.3. Представления

	Определяются в файле views.py

	Это функция или метод класса, которая принимает запрос и возвращает ответ.

		def home(request):
			return HttpResponse('home')

		class ProductView(View):
			def get(self, request):
				return HttpResponse('all products')

			def post(self, request):
				return HttpResponse('create product')

			def put(self, request):
				return HttpResponse('edit product')

			def delete(self, request):
				return HttpResponse('delete product')

	Чтобы представление работало его нужно привязать к определенному URL-у.

		path('home', views.home, name='home')

		path('product', ProductView.as_view(), name='product')

		path('category', CategoryListView.as_view(), name='category')

	Встроенные (generic) представления классы

		Нужны для решения тривиальных задач.

		Попытка скрестить более чем один generic класс не будет работать так, как вы ожидаете.

		Общие классы представления автоматически создают класс ModelForm при работе с моделями.

		Подробное описание и все методы смотреть здесь:

			https://djbook.ru/rel1.9/ref/class-based-views/flattened-index.html

			https://docs.djangoproject.com/en/2.2/ref/class-based-views/flattened-index/

		TemplateView

			Обрабатывает заданный шаблон.

			class HomePageView(TemplateView):
			    template_name = '/path_to_templage/home.html'

		RedirectView

			Редирект на заданный URL.

			Если переданный URL равен None, Django вернет исключение HttpResponseGone (410).

			class ArticleCounterRedirectView(RedirectView):
				# должно ли перенаправление быть постоянным
			    permanent = False

			    # передавать ли строку GET запроса в новую локацию
			    query_string = True

			    # название URL-шаблона на который перенаправлять
			    pattern_name = 'article-detail'

    	DetailView

    		Берет из бд и отображает детальную информацию одного объекта.

    		Будет искать шаблон в myapp/modelname_detail.html

    		class PublisherDetailView(DetailView):
			    model = Publisher

		ListView

			Берет из бд и отображает список объектов.

			В шаблоне список всех объектов по умолчанию будет в object_list или modelname_list.

			Если не указать template_name, то будет искать appname/modelname_list.html

			class PublisherListView(ListView):
    			model = Publisher
    			template_name = '/books/publisher_list.html'

    			# имя list объектов для доступа в шаблоне
    			context_object_name = 'my_favorite_publishers'

		FormView

			Для работы с формой (инициализирующий GET запрос, POST с верными или неверными данными).

			Полюбому нужно указывать template_name.

			forms.py

				from django import forms

				class ContactForm(forms.Form):
				    name = forms.CharField()
				    message = forms.CharField(widget=forms.Textarea)

			views.py

				class ContactFormView(FormView):
				    template_name = '/path_to_template/contact.html'
				    form_class = ContactForm
				    success_url = reverse_lazy(viename='home')

		CreateView

			Для создания объекта.

			Если вы указали и fields и form_class, будет вызвано исключение ImproperlyConfigured.

			Будет искать шаблон в appname/modelname_form.html

			class AuthorCreateView(CreateView):
			    model = Author

			    # поля формы для создания
			    fields = ['name']

			Вместе с CreateView используется форма

				<form action="" method="post">
					{% csrf_token %}
				    {{ form.as_p }}
				    <button type="submit">create<button/>
				</form>

				Django ожидает увидеть эту форму в name_app и с названием namemodel_form.html

				Чтобы изменить это поведение можно использовать template_name для полного указания шаблона и его местоположения.

			Пример с использованием AJAX

				class AjaxableResponseMixin(object):
				    def form_invalid(self, form):
				        response = super(AjaxableResponseMixin, self).form_invalid(form)
				        if self.request.is_ajax():
				            return JsonResponse(form.errors, status=400)
				        else:
				            return response

				    def form_valid(self, form):
				        response = super(AjaxableResponseMixin, self).form_valid(form)
				        if self.request.is_ajax():
				            data = {
				                'pk': self.object.pk,
				            }
				            return JsonResponse(data)
				        else:
				            return response

				class AuthorCreate(AjaxableResponseMixin, CreateView):
				    model = Author
				    fields = ['name']

		UpdateView

			Для редактирования объекта.

			Если вы указали и fields и form_class, будет вызвано исключение ImproperlyConfigured.

			Необходимо указать template_name_suffix.

			Будет искать шаблон appname/modelname_update_form.html

			class AuthorUpdateView(UpdateView):
			    model = Author

			    # поля формы для редактирования
			    fields = ['name']

			    template_name_suffix = '_update_form'

		DeleteView

			Для удаления объекта.

			Если вы указали и fields и form_class, будет вызвано исключение ImproperlyConfigured.

			reverse_lazy используется, потому что urls ещё не загрузились при импорте файла.

			class AuthorDeleteView(DeleteView):
			    model = Author
			    success_url = reverse_lazy(viewname='author-list')

		Так же уществуют общие классы представления для работы с датами: DateDetailView, TodayArchiveView, DayArchiveView, WeekArchiveView, MonthArchiveView, YearArchiveView. ArchiveIndexView.

		Миксины

			Это классы, которые хранят в себе общий код для повторного использования в других классах.

			Чем больше реализация методов будет размазана по примесям, тем сложнее будет читать дочерний класс и понимать что же он всё-таки делает, какие методы откуда берутся и какие методы уже перекрыты в родительских классах. Поэтому с миксинами лучше не грубить.

				class AjaxableResponseMixin(object):
				    def form_invalid(self, form):
				        response = super(AjaxableResponseMixin, self).form_invalid(form)
				        if self.request.is_ajax():
				            return JsonResponse(form.errors, status=400)
				        else:
				            return response

				    def form_valid(self, form):
				        response = super(AjaxableResponseMixin, self).form_valid(form)
				        if self.request.is_ajax():
				            data = {
				                'pk': self.object.pk,
				            }
				            return JsonResponse(data)
				        else:
				            return response

				class AuthorCreate(AjaxableResponseMixin, CreateView):
				    model = Author
				    fields = ['name']

			Миксины классов представлений

				ContextMixin - для работы с контекстом шаблона

				TemplateResponseMixin - для работы с шаблоном

				SingleObjectMixin - для работы с одиночным объектом

				SingleObjectTemplateResponseMixin - для работы с шаблоном и одиночным объектом

				MultipleObjectMixin - для работы с множеством объектов

				MultipleObjectTemplateResponseMixin - для работы с множеством объектов и шаблоном

				FormMixin - для создания и отображения формы

				ModelFormMixin - для создания и отображения модельной формы

				ProcessFormView - для работы с формой в рамках GET и POST запросов

				DeletionMixin - для работы с удалением

				YearMixin, MonthMixin, DayMixin, WeekMixin, DateMixin - для работы с датами

				Подробней смотреть здесь:

					https://docs.djangoproject.com/en/2.2/ref/class-based-views/mixins/

		Декорирование представлений классов

			Расширение представлений-классов не ограничивается использованием миксинов, также можно подключить декораторы.

			Для декорирования каждого метода представления класса, нужно декорировать метод dispatch().

				Метод класса не то же самое, что и обычная функция, к нему просто так применить декоратор не получится.

				Нужно сначала преобразовать его в метод декоратор. Для этого существует декоратор method_decorator.

					@method_decorator(login_required)
					def dispatch(self, *args, **kwargs):
					    return super(ProtectedView, self).dispatch(*args, **kwargs)

					Также вы можете декорировать класс, указав название методы, которые необходимо декорировать, в аргументе name.

						@method_decorator(login_required, name='dispatch')
						class ProtectedView(TemplateView):
						    template_name = 'secret.html'

					Если у вас есть список декораторов, которые используются в нескольких местах, вы можете указать список или кортеж декораторов и использовать его в method_decorator() несколько раз. При этом декораторы обрабатывают запрос в указанном порядке.

						decorators = [never_cache, login_required]

						@method_decorator(decorators, name='dispatch')
						class ProtectedView(TemplateView):
						    template_name = 'secret.html'

		Обработка форм с помощью представлений классов

			class MyFormView(View):
			    form_class = MyForm
			    initial = {'key': 'value'}
			    template_name = 'form_template.html'

			    def get(self, request, *args, **kwargs):
			        form = self.form_class(initial=self.initial)
			        return render(request, self.template_name, {'form': form})

			    def post(self, request, *args, **kwargs):
			        form = self.form_class(request.POST)

			        if form.is_valid():
			            return HttpResponseRedirect('/success/')
			        return render(request, self.template_name, {'form': form})

3.4. Шаблоны

	Шаблон - это просто текстовый файл, или строка Python.

	Шаблоны содержат статический HTML и динамические данные.

	Шаблоны стоит хранить внутри каждого приложения, а не в корневой директории, чтобы не было хаоса.

		По умолчанию django будет искать шаблон в nameapp/templates/nameapp/

		Пример структуры хранения шаблонов:

			nameapp/templates/nameapp/author_list.html

	В корневой директории следует хранить только общие шаблоны.

		Для того, чтобы django искал шаблоны и в корневой директории нужно в корневой директории создать директорию 'templates' и в settings.py написать так:

			TEMPLATES = [
			    {
			        'BACKEND': 'django.template.backends.django.DjangoTemplates',
			        'DIRS': [BASE_DIR, 'templates']
			        ...
			    },
			]

			В списке DIRS хранятся пути для дополнительного поиска шаблонов.

	Основные конструкции внутри шаблона это переменные, теги, фильтры и комментарии.

		{{ first_name }} - переменная

		{% if ... %} ... {% endif %} - тег

		{{ django|title }} - фильтр

		{# this won't be rendered #} - комментарии

		{% comment "optional note" %} ... {% endcomment %} - многострочный комментарий

	Загрузка шаблона включает в себя поиск шаблона по названию, его обработку и рендеринг. 

	Рендеринг означает передачу данных контекста в шаблон и возвращение строки с результатом.

	Рендеринг заменяет переменные на их значения, которые ищутся в контексте, и выполняет теги.

	Шаблоны можно настроить с помощью настройки TEMPLATES, но по умолчанию они настроенны нормально.

	Для загрузки шаблона можно использовать методы get_template или select_template.

		from django.template import RequestContext, loader

		def index(request):
		    question_list = Question.objects.all()
		    template = loader.get_template('polls/index.html')
		    context = RequestContext(request, {
		        'latest_question_list': latest_question_list,
		    })
		    return HttpResponse(template.render(context))

	Но гораздо удобней использовать метод render.

		def index(request):
		    question_list = Question.objects.all()
		    context = {'question_list': question_list}
		    return render(request, 'polls/index.html', context)

	Если вызвать get_template('story_detail.html'), Django будет искать следующие файлы:

		/home/html/example.com/story_detail.html

	Вы можете использовать select_template для гибкой загрузки шаблонов. 

		Например, вы написали новость и хотите использовать другой шаблон для некоторых новостей. 

		Вы можете использовать select_template(['story_%s_detail.html' % story.id, 'story_detail.html']). 

		Это позволить создать отдельный шаблон для определенных новостей, а для всех остальных использовать шаблон по умолчанию.

	Фильтры

		Фильтры - это просто функции Python (могут принимать или не принимать аргументы)

		Фильтры используются вместе с переменными: {{ name|cut:"0" }}

		Есть ряд встроенных фильтров. Вспомнить о них прежде чем искать нунжный фильтр в катомных.

		Фильтр с аргументом

			{{ name|cut:"0" }}

			def cut(value, arg):
			    return value.replace(arg, '')

			В данном примере в функцию cut первым аргументом попадет значение переменной name, а вторым значение аргумента - "0"

		Фильтр без аргументов

			{{ name|lower }}

			def lower(value):
			    return value.lower()

		Наследование

			Позволяет создать шаблон-скелет, который содержит базовые элементы сайта и определяет блоки, которые могут быть переопределены дочерними шаблонами.

				base.html

					<!DOCTYPE html>
					<html lang="en">
					<head>
					    <link rel="stylesheet" href="style.css" />
					    <title>{% block title %}My amazing site{% endblock %}</title>
					</head>

					<body>
					    <div id="sidebar">
					        {% block sidebar %}
					        <ul>
					            <li><a href="/">Home</a></li>
					            <li><a href="/blog/">Blog</a></li>
					        </ul>
					        {% endblock %}
					    </div>

					    <div id="content">
					        {% block content %}{% endblock %}
					    </div>
					</body>
					</html>

				product_list.html

					{% extends "base.html" %}

					{% block title %}Products{% endblock %}

					{% block content %}
						{% for product in product_list %}
						    <h2>{{ product.name }}</h2>
						    <p>{{ product.price }}</p>
						{% endfor %}
					{% endblock %}

					Если вы используете {% extends %}, он должен быть первым тегом в шаблоне. Иначе наследование не будет работать.

					Тэг extends говорит механизму шаблонов, что этот шаблон наследует другой шаблон. 

					Когда механизм шаблонов выполняет этот шаблон, первым делом находится родительский шаблон.

					Далее механизм шаблонов находит тег block в base.html и заменяет его содержимым дочернего шаблона.

			Если вам необходимо содержимое блока родительского шаблона, используйте переменную {{ block.super }}. Это полезно, если вам необходимо дополнить содержимое родительского блока, а не полностью переопределить его.

		Доп. инфу см. здесь:

			https://djbook.ru/rel1.9/ref/templates/builtins.html

			https://djbook.ru/rel1.9/ref/templates/builtins.html#ref-templates-builtins-filters

			https://djbook.ru/rel1.9/howto/custom-template-tags.html#howto-writing-custom-template-filters

			https://djbook.ru/rel1.9/ref/templates/language.html#template-inheritance

			https://docs.djangoproject.com/en/2.2/ref/templates/builtins

			https://docs.djangoproject.com/en/2.2/ref/templates/builtins/#ref-templates-builtins-filters

			https://docs.djangoproject.com/en/2.2/howto/custom-template-tags/#howto-writing-custom-template-filters

			https://docs.djangoproject.com/en/2.2/ref/templates/language/#template-inheritance

	Ребята из 'two scoops of django' предлагают использовать Jinja2.

	Структура by 'two scoops of django'

		2-ух уровневая

			templates/

				base.html

				profiles/

					profile_detail.html # extends base.html

					profile_form.html # extends base.html

		3-х уровневая

			Подходит для сайтов с совершенно разными макетами для каждой страницы.

			templates/

				base.html

				profiles/

					base_profiles.html # extends base.html

					profile_detail.html # extends base_profiles.html

					profile_form.html # extends base_profiles.html

	Язык шаблонов

3.5. Url-ы

	Определяются в файле urls.py

	Когда запрос дошел до django он:

		определяет какой корневой модуль urls.py использовать, по умолчанию это будет файл из project_name/urls.py

			можно явно указать корневой модуль urls.py с помощью ROOT_URLCONF в settings.py

		загружает этот корневой модуль

		ищет в корневом модуле переменную urlpatterns

		перебирает каждый URL-шаблон по порядку, и останавливается при первом совпадении с запрошенным URL-ом

		импортирует и вызывает соответствующее представление передавая туда объет HttpRequest и если есть аргументы

		если нет соответствия, или возникла ошибка на любом из этапов, django вызывает соответствующий обработчик ошибок

	Django использует запрашиваемый url как обычную строку python. 

		Он не учитывает параметры GET, POST и имя домена.

		При запросе к https://www.example.com/category/, django возьмет category/.

	Не нужно добавлять слэш в начале, потому что каждый url содержит его.

	До версии 2.0. найденные аргументы всегда будут строкой, даже если регулярное выражение подразумевает число.

		url(r'^articles/(?P<year>[0-9]{4})/$', views.year_archive)

	Структура

		urls.py

			urlpatterns = [
				url(r'^home/', views.home, name='home')
				path('home/', views.home, name='home')
			]

	Подключение url-ов в корневом urls.py

		Когда проект имеет хотя бы одно приложение, то его url-ы находятся в appname/urls.py

		Эти url-ы нужно подключить в корневой urls.py

		url(r'^categories/', include('category.contact.urls'))

	Старый вариант

		project_name/urls.py

			url(r'^categories/', include('category.urls'))

		category/urls.py
		
			url(r'', views.index, name='category-index')

	Новый вариант

		project_name/urls.py

			path('categories/', include('category.urls'))

		category/urls.py
		
			path('', views.index, name='category-index')

	Для функций представлений

		url(r'^$', views.home, name='home')

		path('products', views.products), name='home')

	Для классов представлений

		url(r'^$', views.HomeView.as_view(), name='home')

		path('products', views.ProductListView.as_view(), name='home')

	Передача аргументов

		В include

			url(r'^blog/', include('inner'), {'blog_id': 3})

			path('blog/', include('inner'), {'blog_id': 3})

			# в эти два url-a придет аргумент blog_id из include
			url(r'^archive/$', views.archive),
    		url(r'^about/$', views.about),

    	В представления

    		url(r'^blog/(?P<year>[0-9]{4})/$', views.year_archive, {'foo': 'bar'})

    		path('blog/<int:id>/', views.year_archive, {'foo': 'bar'})

    	В url

    		url(r'^category/(?P<id>[-\w]+)/$', views.home)

    		path('category/<int:id>/', view.category)


    Обращение в других частях приложения

    	В шаблоне

    		{% url 'name-url' arg %}

    	В представлении

    		reverse('name-url', args=(1,))

    		reverse_lazy('name-url', args(2,)) - строит url до загрузки настроек url-ов

    			подходит, когда нужно установить атрибут класса, например success_url для DeleteView

    			подходит для переменной по умолчанию в параметре функции, например def set_url(url=reverse_lazy('name-url'))

    Пространства имен в url-ах

    	Нужно в том случае если имена урлов повторяются, но они находятся в разных приложениях.

    	Для этого нужно

    		app_name = 'author'
			urlpatterns = [
				...
			]

			Теперь ко всем урлам данного приложения можно обращаться так:

				{% url 'author:index' %}

				reverse('polls:index', current_app=self.request.resolver_match.namespace)

3.6. Unit тесты

	Это тесты, которые проверяют поведение функций и методов.

	Их еще называют модульными тестами.

	Они проверяют код и доказывают, что он работает.

	Сначала пишем тест, он не проходит, потому что тестируемый метод ещё не реализован, затем пишем тестируемый метод и запускаем ещё раз тест.

	Пишутся в файле tests.py для каждого приложения отдельно.

	Запускаются командой ./manage.py test

	Пример:

		class ProductCardAdminMethodTests(TestCase):
		    """Проверяет работу с карточкой товара."""

		    helper = ProductCardHelper()
		    request = HttpRequest()

		    def setUp(self):
		        ProductCard.objects.create(
		        	code=3,
		            is_ready=True,
		            is_checked=False,
		            is_actual=True
		        )

		    def test_validate_product_card_with_valid_values(self):
		        """Должна успешно пройти валидация карточки товара."""

		        product_card = self.product_card_qs.get(code=3)

		        self.request.POST['code'] = product_card.code
		        self.request.POST['is_checked'] = True

		        validation_result = self.helper.validate_product_card(
		            request=self.request,
		            product_card_pk=product_card.pk
		        )

		        self.assertEqual(
		            first=validation_result,
		            second=True
		        )

	Класс для теста должен наследоваться от from django.test import TestCase

	Методы тестирования должны начинаться со слова test. Например test_article_create.

	Метод setUp это встроенный метод тестирования, который позволяет создавать тестовые данные в бд в момент. Нужно потому что при прохождении тестов создается пустая бд.

	Именуем в формате PropertyAdminTests. Обратить внимание на то что во множественном числе - Tests.

	Именование делится на форматы:

		QuestionViewTests

		QuestionMethodTests

	Встроенный класс TestCase оборачивает каждый тест в транзакцию и отменяет её после выполнения теста, чтобы обеспечить изолированность тестов.

	Есть класс Client для тестов клиентской части приложения.

	Есть класс RequestFactory для использования в тестах объекта request.

	Нюансы

		Помнить, что при выполнении тестов создается ПУСТАЯ база данных.

		Если класс в котором написаны тесты наследуется от from django.test import TestCase, то при выполнении будет создана новая, пустая и временная база данных.

		Если класс в котором написаны тесты наследуется напрямую от unittest.TestCase (класс чистого python для тестирования), то при выполнении будет использована боевая база данных и это может иметь последствия.

		Помнить, что метод create_user возвращает хэшированный пароль и через него нельзя будет потом залогиниться. Поэтому можно сделать приватное св-во в методе setUp.

		Когда делаем логин и потом последующий запрос помнить, что нужно делать через клиент self.client.login, self.client.post

		Для тестирование кастомных actions в панели администратора используем:

			self.client.post(
	            reverse('admin:cards_productcard_changelist'),
	            {
	                'action': 'mark_cards_as_checked', 
	                '_selected_action': ProductCard.objects.values_list('pk', flat=True)
	            }
	        )

	    Если используем много баз данных, а для тестов должна создаваться одна, то можно при выполнении тестов переопределить DATABASES:

			if 'test' in sys.argv:
			    DATABASES = {
			        'default': {
			            'ENGINE': 'django.db.backends.mysql',
			            'NAME': 'magic',
			            'USER': 'root',
			            'PASSWORD': 'asdf1234',
			            'HOST': '127.0.0.1',
			            'PORT': '3306',
			            'OPTIONS': {
			            	'charset': 'utf8'
			                'init_command': 'SET default_storage_engine=INNODB',
			            }
			        },
			    }

		Работе тестового клиента может мешать debug_toolbar.

		При работе с тестовым клиентом если создаем суперпользователя, то лучше создавать его, как is_staff=True и is_superuser=True.

		При тестировании исключений один из варинтов такой:

			with self.assertRaises(ValidationError):
				# Если внутри этого метода будет выкинуто исключение ValidationError, то тест прошел
				self.helper.validate_product_card_image_indexes(index_list=[0, 1, 1])

		При работе с методом self.assertEqual(), первый аргумент это метод, который тестируем, а второй это значение, которое он должен вернуть

		Для создания общих данных доступных в каждом классе тесте нужно использовать метод setUpModule. Определяется без класса.

		Использовать bulk_create только в случаях, когда действительно много.

		При комментирование тестовых методов писать их в формате:

			"""
			Должен фильтровать queryset и возращать валидные карточки товара.

	        Валидные это те, у которых есть код 1с, бренд, шаблон у 
	        вида-типа и фотографии.
	        """

	        То есть пишем, что должен делать тестовый метод.

	    Каждый метод setUp наполняет базу своими уникальными объектами, которые не зависят от другого метода setUp. То есть если в одном создал 2 объекта, то в этом классе тестов будут доступны только эти два объекта при выборке всех.

	   	Лучше не использовать self в setUp, потому что если потом в методах теста обновляется объект, а мы берем его через self, то обновления не видны.

	   	Лучше дублировать наполнение данных в каждом методе setUp, потому что если выносить это на setUpModule, то можно запутаться + каждый метод setUp изолирован друг от друга и не вызывает проблем.

	   	Лучше разбивать тестирование одного метода на разные методы в тестах. 

	   		Например мы тестируем метод validate_product_card_image_indexes.

	   		Тесты к нему будут вынесены в отдельные методы, каждый из которых будет проверять один юз кейс: test_validate_product_card_image_indexes_with_same, test_validate_product_card_images_indexes_with_different и т.д. 

	   		Во первых один метод делает одно, а во вторых проще понять, где возникла ошибка если тесты упали.

	   	Из объекта Client можно получить текущего пользователя через result.wsgi_request.user

	   	'TEST': { 'CHARSET': 'utf8', 'COLLATION': 'utf8_general_ci',} - позволяет задать кодировку бд при выполнении тестов

	Команды

		self.client.login()

		self.assertEqual()

		self.assertQuerysetEqual()

		sefl.assertRaises(NameError)

		response = self.client.post(reverse('admin:user_invoice_add'), {'num': 'x23md'}) - делает пост запрос на нужный урл с нужными параметрами

		response.wsgi_request.user - выводит пользователя, который сделал запрос

		./manage.py test

		./manage.py test app_name/

3.7. Формы

	Класс Django Form

		Сердце всего механизма – класс Form.

		Класс Form описывает, как работает и показывается форма.

		Поля формы сами являются классами. Они управляют данными формы и выполняют их проверку при отправке формы.

		Каждый тип поля представлен по умолчанию определенным классом Widget.

		При работе с формой мы обычно создаем экземпляр формы в представлении.

		Для дополнительной проверки формы можно переопределить метод clean().

		Создаем в файле forms.py

	Связанные и не связанные с данными формы

		Незаполненная форма не содержит данных, привязанных к её полям и является не связанной.

		Заполненная форма содержит переданную информацию и, следовательно, может быть использована для проверки введённых данных и является связанной.

		Атрибут формы is_bound позволяет узнать связана форма с данными или нет.

	Виджеты

		Каждое поле формы содержит соответствующий класс Widget, который отвечает за создание HTML кода.

		В большинстве случаев поле уже содержит подходящий виджет. Например, по умолчанию поле CharField представлено виджетом TextInput, который создает тег <input type="text"> в HTML.

		Можно переопределить виджет для поля

			class ContactForm(forms.Form):
			    message = forms.CharField(widget=forms.Textarea)

	Настройки рендеринга формы

		{{ form.as_table }} - выведет поля в таблице

		{{ form.as_p }} - обернет поля в тег p

		{{ form.as_ul }} - выведет поля теге <ul>

	Рендеринг полей формы вручную

		<div class="fieldWrapper">
		    <label for="{{ form.message.id_for_label }}">Your message:</label>
		    {{ form.message }}
		</div>
		<div class="fieldWrapper">
		    <label for="{{ form.sender.id_for_label }}">Your email address:</label>
		    {{ form.sender }}
		</div>

	Рендеринг ошибок формы вручную

		# возвращает список ошибок, которые не привязаны к конкретному полю
		{{ form.non_field_errors }}

		<div class="fieldWrapper">
		    {{ form.message.errors }}
		    <label for="{{ form.message.id_for_label }}">Your message:</label>
		    {{ form.message }}
		</div>
		<div class="fieldWrapper">
		    {{ form.sender.errors }}
		    <label for="{{ form.sender.id_for_label }}">Your email address:</label>
		    {{ form.sender }}
		</div>

		Для более гибкой работы с ошибками можно делать так

			{% if form.message.errors %}
			    <ol>
			    {% for error in form.message.errors %}
			        <li><strong>{{ error|escape }}</strong></li>
			    {% endfor %}
			    </ol>
			{% endif %}

	Переопределение сообщения ошибок

		class AuthorForm(ModelForm):
		    class Meta:
		        model = Author
		        fields = ('name', 'title', 'birth_date')
		        error_messages = {
		            'name': {
		                'max_length': _('My custom message'),
		                'required': _('My custom message')
		            }
		        }

	Повторное использование шаблонов форм

		Сохраняем цикл по полям формы в отдельном шаблоне и подключаем его в другие шаблоны с помощью тега include

			form_snippet.html

				{% for field in form %}
				    <div class="fieldWrapper">
				        {{ field.errors }}
				        {{ field.label_tag }} {{ field }}
				    </div>
				{% endfor %}

			template_name.html

				{% include "form_snippet.html" %}

		Если объект формы, переданный в шаблон, имеет другое имя в контексте, вы можете создать для него псевдоним.

			{% include "form_snippet.html" with form=comment_form %}

	Указываем какие поля использовать

		fields = '__all__' - используем все поля

		exclude = ['title'] - исключаем поле title

		Если поле модели содержит editable=False, каждая форма, созданная по модели с помощью ModelForm, не будет включать в себя это поле.

	Наследование

		class RestrictedArticleForm(EnhancedArticleForm):
			class Meta(ArticleForm.Meta):

	Простые формы

		class NameForm(forms.Form):
		    your_name = forms.CharField(label='Your name', max_length=100)

		Проверка

			form = ContactForm(data)
			form.is_valid()

			Если все данные правильные, этот метод вернет True и добавит данные формы в атрибут cleaned_data

				form.cleaned_data
				form.cleaned_data['author']	

		Передача в шаблон

			form = ContactForm(data)
			return render(request, 'home.html', {'form': form})			

		В шаблоне

			<form action="{% url 'author-create' %}" method="post">
			    {% csrf_token %}
			    {{ form }}
			    <button type="submit" value="Submit"/>
			</form>

			Все поля формы и их атрибуты будут добавлены в HTML из {{ form }} при рендеринге шаблона.

		Работа в представлении

			def create(request):
			    if request.method == 'POST':
			        form = NameForm(request.POST)
			        if form.is_valid():
			            return HttpResponseRedirect('/thanks/')
			    else:
			        form = NameForm()

			    return render(request, 'name.html', {'form': form})

			Если в представление пришел GET запрос, будет создана пустая форма и добавлена в контекст шаблона для последующего рендеринга.

			Если форма отправлена через POST запрос, представление создаст форму с данными из запроса: form = NameForm(request.POST). Это называется привязать данные к форме.

	Наборы форм

		Позволяют работать с множеством форм на одной странице

			class ArticleForm(forms.Form):
				title = forms.CharField()
				pub_date = forms.DateField()

			ArticleFormSet = formset_factory(ArticleForm, extra=2, max_num=1, validate_max=True, min_num=1 validate_min=True)

				extra - кол-во пустых форм

				max_num - ограничивает кол-во пустых форм

				validate_max - проверяет, что общее количество форм, без учета помеченных для удаления, не больше чем max_num (будет ошибка даже если количество инициализированных форм превышает max_num). Независимо от validate_max, если количество форм превышает max_num на более чем 1000, будет ошибка валидации

				validate_min - проверяет, что общее количество форм, без учета помеченных для удаления, больше или равно min_num

		Доступ в шаблоне

			formset = ArticleFormSet(data)
			return render(request, 'name.html', {'forms': formset})

			При отображении формы в шаблоне, вы можете включать в страницу все управляющие данные с помощью {{ formset_name.management_form }}

				{{ formset_name.management_form }}
			    {% for form in formset %}
			        {{ form }}
			    {% endfor %}

		Использование начальных данных с наборами форм

			formset = ArticleFormSet(
				initial=[
					{
						'title': 'Django is now open source',
			     		'pub_date': datetime.date.today(),
			     	}
				]
			)

			В данном примере начальные данные будут только у первой формы.

		Проверка набора форм

			formset = ArticleFormSet(data)
			formset.is_valid()

		Собственная проверка набора форм

			Для этого набор форм имеет метод clean.

				class BaseArticleFormSet(BaseFormSet):
					def clean(self):
						if any(self.errors):
							return

	Модельные формы

		Чаще всего формы аналогичны моделям, поэтому можно создать форму на основе модели.

		Это можно сделать с помощью класса ModelForm.

			class ArticleForm(ModelForm):
				class Meta:
					model = Article
					fields = ['pub_date', 'headline', 'content', 'reporter']

			В итоге форма будет содержать поля указанные в fields и в том же порядке.

		Поле ForeignKey модели представлено полем формы ModelChoiceField.

		Поле ManyToManyField модели представлено полем формы ModelMultipleChoiceField.

		Если для поля модели установлен атрибут choices, тогда для поля формы будет использоваться виджет Select.

			TITLE_CHOICES = (
			    ('MR', 'Mr.'),
			    ('MRS', 'Mrs.'),
			    ('MS', 'Ms.'),
			)

			class Author(models.Model):
			    name = models.CharField(max_length=100)
			    title = models.CharField(max_length=3, choices=TITLE_CHOICES)

		Класс, унаследованный от ModelForm, может принимать существующий экземпляр модели через именованный аргумент instance.

			article = Article.objects.get(pk=1)
			form = ArticleForm(request.POST, instance=article)
			form.save()

			Если такой аргумент указан, то save() обновит переданную модель. В противном случае, save() создаст новый экземпляр указанной модели.

			Поля, которые не определены в форме, не будут учитываться при вызове метода save().

			По умолчанию поля в ModelForm не локализируют свои данные. Для локализации полей можно использовать параметр localized_fields класса Meta.

		Валидация в ModelForm

			form = ArticleForm(data)
			form.is_valid()

		Наборы модельных форм

			AuthorFormSet = modelformset_factory(Author, fields=('name', 'title'))

			formset = AuthorFormSet(request.POST)

	Дополнительная инфа

		https://djbook.ru/rel1.9/topics/forms/index.html

		https://djbook.ru/rel1.9/topics/forms/formsets.html

		https://djbook.ru/rel1.9/topics/forms/modelforms.html

		https://djbook.ru/rel1.9/topics/forms/media.html

		https://docs.djangoproject.com/en/3.0/topics/forms/

		https://docs.djangoproject.com/en/2.2/topics/forms/formsets/

		https://docs.djangoproject.com/en/2.2/topics/forms/modelforms/

		https://docs.djangoproject.com/en/2.2/topics/forms/media/

3.8. Логгирование

	Это запись сообщений о каких-либо событиях в работе системы (информационные сообщения, ошибки, предупреждения и т.д.)

	Конфигурация логгирования состоит из:

		Loggers

			Логгер - это именованный канал в который отправляются сообщения, которые нужно заллогировать

				logger.error('Something went wrong!')

			Каждый логгер имеет уровни логгирования:

				DEBUG - системная информация для отладки

				INFO - общая системная информация

				WARNING - инфа о мелких проблемах

				ERROR - инфа об ошибках

				CRITICAL - инфа о критических ошибках

			После того, как логгер принял сообщение на обработку, оно передается в Handler.

		Handlers 

			Обработчики определяют, что делать с сообщением пришедшим из логгера, например вывести на экран, записать в файл и т.д.

			Логгер может содержать несколько обработчиков, которые могут иметь различный уровень логгирования. 

				Например для ERROR и CRITICAL, один обработчик будет отправлять сообщения, а другой записывать все сообщения в файл.

			Если DEBUG = True, то django перенаправляет все сообщения уровня INFO и выше в консоль.

			Если DEBUG = False, то django отравляет все сообщения уровня ERROR или CRITICAL в AdminEmailHandler.

		Filters 

			Фильтры позволяют контролировать какие сообщения будут переданы из логгера в обработчик.

				Например, можно добавить фильтр, который позволяет обрабатывать ERROR сообщения отправленные определенным источником.

			По умолчанию все сообщения будут переданы в обработчик.

			Можно использовать несколько фильтров.

		Formatters

			Форматеры определяют точный формат текста сообщения.

	Простая конфигурация

		settings.py

			LOGGING = {
			    'version': 1,
			    'disable_existing_loggers': False,
			    'handlers': {
			        'file': {
			            'level': 'WARNING',
			            'class': 'logging.FileHandler',
			            'filename': os.path.join(PROJECT_ROOT, 'project_name/logs/warning.log'),
			        },
			        'mail_admins': {
			            'level': 'ERROR',
			            'class': 'django.utils.log.AdminEmailHandler'
			        }
			    },
			    'loggers': {
			        'default': {
			            'handlers': ['mail_admins', 'file'],
			            'level': 'ERROR',
			            'propagate': True,
			        }
			    }
			}

		Для переопределения некоторых или всех стандартных логгеров нужно установить disable_existing_loggers в False.

		Для записи лога в файл используется обработчик FileHandler.

			Имя файла для лога можно указывать согласно уровню логгирования, например warning.log

		Для отправки сообщений на почту используется AdminEmailHandler.

	Использование

		import logging
		logger = logging.getLogger(__name__)
		logger.error('Something went wrong!')

		__name__ - это название модуля, который содержит модуль

		'project.interesting.stuff' - составное имя логгера

	Логгирование от Two scoops of Django

		Делить логи на уровни.

		Использовать traceback при логгировании. logger.exception(e).

		В каждом новом модуле импортировать новый логгер, потому что если захочу поменять систему логирования в одном модуле не затрагивая другой, это не получится.

		Логи уровня INFO лучше писать в файл и хранить на диске, а уровня ERROR отправлять админам проекта на почту (по default в django).

	Дополнительная информация

		https://djbook.ru/rel1.9/topics/logging.html

		https://docs.djangoproject.com/en/2.2/topics/logging/

3.9. Статические файлы

	Статические файлы - это файлы css, js, шрифты и т.д.

	Описанное ниже подходит только для локальной разработки при DEBUG = True.

	Для production используем nginx.

	По умолчанию django будет искать статические файлы в appname/static/appname/

	Если после static не создать каталог appname, то Django использует первый найденный по имени файл и, если есть файлы с одинаковым названием в разных приложениях, то не будет возможности использовать оба.

	Структура

		appname/static/appname/css/
		appname/static/appname/js/
		appname/static/appname/fonts/

	Раздача статических файлов при разработке

		В настройках устанавливаем путь до каталога со статическими файлам: STATIC_URL = '/static/'

		В urls.py добавляем к основным, статические (будет работать только при DEBUG=True):

			if settings.DEBUG:
				urlpatterns + static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)

		Для загрузки и доступа в шаблоне загружаем статику и используем тэг static

			{% load static %}
    		<script src="{% static 'category/js/category.js' %}"></script>

    		При использовании тэга static будет искать в http://127.0.0.1:8000/static/category/js/category.js

    Раздача статических файлов с помощью веб-сервера

    	Указываем в STATIC_ROOT каталог, из которого будут раздаваться статические файлы

    		STATIC_ROOT = os.path.join(BASE_DIR, 'static')

    	Выполняем команду collectstatic, которая скопирует все статические файлы в каталог указанный в STATIC_ROOT

    		./manage.py collectstatic

    		По умолчанию django будет искать файлы в static/appname.

    		Если нужно задать другие директории для поиска, то используем STATICFILES_DIRS

    			STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static')]

3.10. Медиа файлы

	Медиа файлы - это файлы, которые были загружены пользователем (картинки, текстовые документы и т.д.)

	Когда Django обрабатывает загрузку файла, данные о нем в конце концов попадают в request.FILES

	Если файл меньше 2.5 мегабайт, то до сохранения файла на диск Django поместит его в память.

	Если файл больше 2.5 мегабайт, то до сохранения файла на диск Django запишет его во временный каталог вашей системы.

	Настройки

		Указываем каталог, где будут храниться медиа файлы

			MEDIA_ROOT и STATIC_ROOT должны отличаться

			MEDIA_ROOT = os.path.join(BASE_DIR, 'media')

		Указываем путь, который указывает на каталог с медиа файлами

			MEDIA_URL = '/media/'

			Если вы хотите использовать {{ MEDIA_URL }} в шаблонах, добавьте 'django.template.context_processors.media' в опцию 'context_processors' настройки TEMPLATES.

			'context_processors': [
                'django.template.context_processors.media'
            ],

		Добавляем медиа файлы к урлам

			urlpatterns = [
			] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

	Модель ImageField

		class Car(models.Model):
		    photo = models.ImageField(upload_to='cars')

		upload_to говорит куда сохранять картинку. При этом будет взят путь из MEDIA_ROOT и внутри него создана директория с именем равным upload_to и туда сохранен файл.

		car.photo
		car.photo.name
		car.photo.path
		car.photo.url

	Модель FileField

		class Report(models.Model):
		    file = models.FileField(upload_to='documents')

		upload_to говорит куда сохранять файл. При этом будет взят путь из MEDIA_ROOT и внутри него создана директория с именем равным upload_to и туда сохранен файл.

	Форма

		request.FILES будет содержать данные только при POST запросе и если форма содержит enctype="multipart/form-data". В противном случае request.FILES будет пустым.

		class UploadFileForm(forms.Form):
		    title = forms.CharField(max_length=50)
		    file = forms.FileField()

		form = UploadFileForm(request.POST, request.FILES)
		if form.is_valid():
			# назначаем файл из request.FILES соответствующему полю модели
            instance = ModelWithFileField(file_field=request.FILES['file'])
            instance.save()

	Стандартная обработка загруженного файла

		По умолчанию должно обрабатываться автоматом.

		def handle_uploaded_file(f):
		    with open('some/file/name.txt', 'wb+') as destination:
		        for chunk in f.chunks():
		            destination.write(chunk)

		chunks обезопасит вас от нагрузки системы при загрузке большого файла.

	Куда будут сохраняться файлы

		В отличии от статических файлов, медиа файлы храняться в общей директории media (либо в корне проекта, либо на cdn).

		По умолчанию django будет сохранять файл в /mysite/MEDIA_ROOT/upload_to/file.txt

	Подробности

		https://djbook.ru/rel1.9/howto/static-files/index.html

		https://djbook.ru/rel1.9/howto/static-files/deployment.html

		https://djbook.ru/rel1.9/topics/http/file-uploads.html

		https://docs.djangoproject.com/en/2.2/howto/static-files/

		https://docs.djangoproject.com/en/2.2/howto/static-files/deployment/

		https://docs.djangoproject.com/en/2.2/topics/http/file-uploads/

3.11. Сигналы

	Это инструмент, который позволяет одним приложениям получать уведомления от других.

	Сигналы позволяют определённым отправителям уведомлять некоторый набор получателей о совершении действий.

	Сигналы пишут в файле signals.py для каждого приложения.

	Создание сигналов

		import django.dispatch

		pizza_done = django.dispatch.Signal(providing_args=['toppings', 'size'])

			providing_args - список названий аргументов сигнала, которые будут доступны слушателям в списке именованных аргументов **kwargs (никакой проверки, передаёт ли сигнал эти параметры, не выполняется).

	Отправка сигналов

		from pizzas.signals import pizza_done

		pizza_done.send(sender=pizza_done, toppings=toppings, size=size)

		pizza_done.send_robust(sender=pizza_done, toppings=toppings, size=size)

			В отличии от send перехватывает все исключения сгенирированные получателем.

	Получатели

		Это функции, которые обрабатывают сигнал.

		Можно создавать в любых частях приложения. Но мы рекомендуем избегать корневого модуля приложения и models, чтобы сократить побочный эффект при импорте приложения.

		На практике, обработчики сигналов лежат в модуле signals приложения, к которому они относятся.

			def function_name(sender, **kwargs):
	    		pass

    	Аргументы sender и **kwargs обязательны.

    Регистрация получателя

    	Для того, чтобы прослушивать сигналы, нужно зарегистрировать функцию-получатель.

	    	from django.core.signals import request_finished
			request_finished.connect(function_name)

			или

			@receiver(signal_name)
			def function_name(sender, **kwargs):
		    	pass

	Отключение получателя

		from django.core.signals import request_finished
		request_finished.disconnect(function_name)

	Встроенные сигналы:

		pre_init - перед вызовом метода __init__ модели

		post_init - после того, как отработал метод __init__ модели

		pre_save - перед вызовом метода save()

		post_save - после вызова метода save()

		pre_delete - перед вызовом метода delete()

		post_delete - после вызова метода delete()

		m2m_changed - после изменения ManyToManyField в модели

		pre_migrate - перед выполнением миграций

		post_migrate - после выполнения миграций

		request_started - перед началом выполнения HTTP запроса

		request_finished - когда заканчивает HTTP запрос

	Дополнительная информация:

		https://djbook.ru/rel1.9/ref/signals.html

		https://docs.djangoproject.com/en/2.1/topics/signals/

3.13. Интерфейс администратора

	Обычно создается в файле admin.py

	Класс ModelAdmin - это отображение модели в интерфейсе администратора.

	При добавлении 'django.contrib.admin' в INSTALLED_APPS setting, Django автоматически ищет модуль admin в каждом приложении и импортирует его.

	Регистрация

		class AuthorAdmin(admin.ModelAdmin):
		    pass
		admin.site.register(Author, AuthorAdmin)

		или

		@admin.register(Author)
		class AuthorAdmin(admin.ModelAdmin):
		    pass

		или

		@admin.register(Author, Reader, Editor, site=custom_admin_site)
		class PersonAdmin(admin.ModelAdmin):
		    pass

	Настройки

		Пишутся внутри класса

			class FlatPageAdmin(admin.ModelAdmin):
			    fields = ('url', 'title', 'content')

		fields = ('url', 'title', 'content') - какие поля модели должны отображаться

		readonly_fields = ('address_report',) - какие поля модели можно только смотреть, а не редактировать

		fieldsets - позволяет изменить макет страниц добавления и редактирования объекта

		form = PersonForm - для указания формы, по умолчанию ModelForm создается динамически для модели

		list_display = ('first_name', 'last_name') - указывает какие поля отображать на странице списка объектов

		list_filter = ('is_staff', 'company') - чтобы определить фильтры данных в правой панели страницы

		list_per_page = 50 - чтобы определить количество объектов на одной странице, по умолчанию равно 100

		list_select_related = ('author', 'category') - чтобы указать Django использовать select_related() при выборе объектов, может сократить количество запросов на этой странице

		ordering - позволяет определить сортировку

		paginator - для создания постраничного отображения

	Методы

		С помощью методов можно изменить поведение по умолчанию.

		save_model - дополнительные операции до или после сохранения

		delete_model - дополнительные операции до или после удаления

		save_formset - для работы с набором форм

		get_ordering - для переопределения сортировки

		get_search_results - фильтрует список объектов в соответствии с параметрами поиска

		save_related - дополнительные операции до или после сохранения связанных объектов

		get_readonly_fields - работает с полями, которые только для чтения

		get_list_display - аботает с полями, которые для отображения на странице списка объектов

		get_urls - для добавляения своих url-ов

		get_form - для работы с формой создания и редактирования

		has_add_permission/has_change_permission/has_delete_permission = True/False - позволяет или ограничивает возможнось добавлять, изменять или удалять объект

		message_user - для работы с отправкой сообщений

		response_add - при создании вызывается поле отправки формы и после сохранения объекта и всех связанных объектов

		response_change - при редактировании вызывается поле отправки формы и после сохранения объекта и всех связанных объектов

		response_delete - при удалении вызывается поле отправки формы и после сохранения объекта и всех связанных объектов

		add_view - для страницы добавления объекта модели

		change_view - для страницы редактирования объекта модели

		changelist_view - для страницы отображения всех объектов

		delete_view - для страницы подтверждения удаления

		history_view - для страницы истории изменений объекта

	Добавление статических файлов

		Будут искаться в директории из STATIC_ROOT.

		class ArticleAdmin(admin.ModelAdmin):
		    class Media:
		        css = {
		            "all": ("my_styles.css",)
		        }
		        js = ("my_code.js",)

		Если вы хотите использовать jQuery в собственных JavaScript файлах без добавления еще одной копии, вы можете использовать объект django.jQuery

	Дополнительная проверка данных

		class ArticleAdmin(admin.ModelAdmin):
		    form = MyArticleAdminForm

		class MyArticleAdminForm(forms.ModelForm):
		    def clean_name(self):
		        return self.cleaned_data["name"]

	Объект InlineModelAdmin

		Для редактирования связанных объектов на одной странице с родительским объектом.

		Django предоставляет два подкласса InlineModelAdmin: TabularInline и StackedInline. Разница между ними только в используемом шаблоне.

		class BookInline(admin.TabularInline):
		    model = Book

		class AuthorAdmin(admin.ModelAdmin):
		    inlines = [
		        BookInline,
		    ]

	Переопределение шаблонов

		Шаблоны интерфейса администратора находятся в каталоге contrib/admin/templates/admin.

		Чтобы переопределить шаблоны, для начала создайте каталог admin в каталоге templates проекта.

			templates/admin

		В каталоге admin создайте подкаталоги с названием приложений.

			templates/admin/products

		В этих подкаталогах создайте подкаталоги для моделей.

			templates/admin/products/product

		Создайте шаблон, который нужно изменить

			templates/admin/products/product/change_list.html

		Измените шаблон

			Для изменения нужно переопределять блоки

			{% extends "admin/change_form.html" %}
			{% load i18n admin_urls %}
			{% block object-tools-items %}
			    <li>
			        <a href="{% url opts|admin_urlname:'history' original.pk|admin_urlquote %}" class="historylink">{% trans "History" %}</a>
			    </li>
			    <li>
			        <a href="mylink/" class="historylink">My Link</a>
			    </li>
			    {% if has_absolute_url %}
			        <li>
			            <a href="{% url 'admin:view_on_site' content_type_id original.pk %}" class="viewsitelink">{% trans "View on site" %}</a>
			        </li>
			    {% endif %}
			{% endblock %}

			Список шаблоных для переопределения:

				app_index.html

				change_form.html

				change_list.html

				delete_confirmation.html

				object_history.html

	Добавление экземпляра AdminSite в url-ы

		urlpatterns = [
		    url(r'^admin/', admin.site.urls),
		]

		или

		from myproject.admin import basic_site, advanced_site

		urlpatterns = [
		    url(r'^basic-admin/', basic_site.urls),
		    url(r'^advanced-admin/', advanced_site.urls),
		]

	Добавление возможности сброса пароля

		Помимо url(r'^admin/', admin.site.urls) добавляем в url-ы следующий код:

			url(r'^admin/password_reset/$', auth_views.password_reset, name='admin_password_reset'),

			url(r'^admin/password_reset/done/$', auth_views.password_reset_done, name='password_reset_done'),

			url(r'^reset/(?P<uidb64>[0-9A-Za-z_\-]+)/(?P<token>.+)/$', auth_views.password_reset_confirm, name='password_reset_confirm'),

			url(r'^reset/done/$', auth_views.password_reset_complete, name='password_reset_complete')

	Имена url-ов

		Django сгенерирует сам по схеме

			app_label_model_name_changelist - список объектов

			app_label_model_name_add - добавления объекта

			app_label_model_name_history - история

			app_label_model_name_delete - удаление объекта

			app_label_model_name_change - изменение объекта

			auth_user_password_change - смена пароля

		Поэтому если нужно обратиться, то url будет такой: products_product_changelist

		Для обращение через reverse или url нужно написать так: admin:products_product_changelist

	Нюансы

		response.context['cl'].queryset - доступ к списку сущности

		self.kwargs - доступ к GET параметрам, не работает в actions

		request.get_full_path() - позовляет получить полный путь запроса, вместе с GET параметрами

		Если и ModelForm и ModelAdmin определяют опцию exclude, ModelAdmin будет иметь больший приоритет.

		Чтобы переопределить шаблоны главной страницы и страниц входа/выхода, лучше создать собственный экземпляр AdminSite и изменить свойства AdminSite.index_template , AdminSite.login_template и AdminSite.logout_template.

3.12. Безопасность

	Защита от межсайтового скриптинга (XSS)

		XSS атаки позволяют вставить собственные JS скрипты в браузеры других пользователей и запустить их.

		Это достигается с помощью:

			Предложения пользователю нажать на какую-нибудь кнопку или ссылку.

			Добавить этот скрипт в куки при переходе пользователя на сайт злоумышленника.

		XSS атаки могут происходить из любого недоверенного источника данных, такого как куки или веб сервисы.

		Шаблоны Django экранируют специальные символы, которые обычно создают проблемы для HTML.

		Django не защищает от подобного кода: <style class={{ var }}>...</style>

			Если var содержит 'class1 onmouseover=javascript:func()', то это может вылиться в неавторизованный запуск JavaScript

	Защита от подделки межсайтового запроса (CSRF)

		CSRF атаки позволяют недобросовестному пользователю выполнять действия от имени другого пользователя, без ведома последнего или его согласия.

		Схема работы такая:

			Пользователь прошел аутентификация на сайте платежной системы.

			Пользователь окрыл новую вкладку в браузере и перешел на другой сайт (сайт злоумышленника).

			Сайт злоумышленника тайно сделал запрос от лица пользователя на сайт платежной системы и перевел деньги со счета пользователя на счет злоумышленника.

		CSRF защита проверяет метку с текущим временем в каждом POST запросе.

		Именно поэтому в каждой форме должен быть csrf token.

		При работе через HTTPS, CsrfViewMiddleware будет проверять, что заголовок HTTP Referer установлен на URL того же источника (включая поддомен и порт).

	Защита от внедрения SQL

		Внедрение SQL - это тип атаки, когда недобросовестный пользователь имеет возможность выполнить в базе данных определённый SQL запрос. 

		Результатом выполнения такого запроса может быть удаление или даже утечка данных.

		Такая атака может быть возможна из-за некорректной обработки входных данных, используемых в SQL-запросах.

		Для защиты от данного типа атак необходимо тщательно фильтровать входные параметры.

		Например для MySQL, требуется брать в кавычки все строковые параметры.

		По умолчанию за нас это делает orm, но об этом нужно знать и помнить если мы делаем сырые запросы.

		При использовании Django ORM созданный SQL запрос будет правильно экранирован соответствующим драйвером базы данных.

	Защита от скликивания

		Это тип атаки, когда вредоносный сайт оборачиваем другой сайт фо фрейм и пользователи могут совершать действия на этом сайте ничего не подозревая.

		Django предоставляет защиту от этой атаки в виде модуля X-Frame-Options, который, при использовании соответствующего браузера, может предотвратить отображение сайта внутри фрейма.

	SSL/HTTPS

		При отсутствии HTTPS злоумышленник имеет возможность перехватывать аутентификационные данные или любую другую информацию, передаваемую между клиентом и сервером.

		Настройте перенаправление HTTP запросов на HTTPS.

		Если браузер изначально подключается через HTTP, что характерно для большинства браузеров, есть возможность утечки существующих кук.

	Проверка заголовка хоста

		Клиент отправляет на север заголовок host.

		Поддельный заголовок Host может быть использован для атак CSRF, подмены кэша и для подмены ссылок в сообщениях электронной почты.

		Django использует заголовок Host, предоставляемый клиентом, для создания URL в определённых случаях. 

		Django проверяет этот заголовок относительно параметра конфигурации ALLOWED_HOSTS.

			Но если ваш код получает содержимое заголовка Host напрямую из request.META, то вы игнорируете эту защиту.

	Безопасность сессии

		Поддомены внутри сайта имеют возможность устанавливать куки на клиенте для всего домена.

		Это приводит к возможности управления сессией, если куки принимаются от поддоменов, которые не находятся под управлением доверенных пользователей.

		Например, атакующий может авторизоваться на good.example.com и получить достоверную сессию для своего аккаунта.

		Если у атакующего есть контроль над bad.example.com, он может использовать его для отправки своего ключа сессии вам, так как поддомену разрешено устанавливать куки для *.example.com. 

		Когда вы посетите good.example.com, вы будете авторизован как атакующий и можете непреднамеренно внести важные персональные данные (например, номер кредитной карты) в аккаунт атакующего.

	Контент, загружаемый пользователями

		Если ваш сайт принимает файлы, настоятельно советуем ограничить размер таких загрузок в конфигурации веб сервера для предотвращения атак на отказ сервиса (DOS).

3.13. Интерфейс администратора

	

3.14. Запросы

	QuerySet

		Для получения объектов из базы данных, создается QuerySet.

		QuerySet представляет выборку объектов из базы данных.

		Обратиться к менеджерам можно только через класс модели и нельзя через экземпляр.

		После каждого изменения QuerySet, вы получаете новый QuerySet, который никак не связан с предыдущим.

		Создание QuerySet не выполняет запросов к базе данных, пока QuerySet не вычислен.

		Если используется срез, больше нельзя изменять queryset (например, добавлять фильтры, менять сортировку и т.д.).

	Когда вычисляется QuerySet
		
		При первом выполнении итерации

			for e in Entry.objects.all():
	    		print(e.headline)

	    Если будет указан шаг среза

	    	Entry.objects.all()[1:10:2]

	    	Срез без шага возвращает новый не вычисленный QuerySet.

	    Если используется pickle для QuerySet

	    При обращении к св-ву объекта

	    	entry = Entry.objects.all()
	    	entry.first().name

	    При использовании repr()

	    	repr() используется для строкового представления объекта.

	    При использовании len()

	    	entry_count = len(Entry.objects.all())

	    При использовании list()

	    	entry_list = list(Entry.objects.all())

	    При вычислении булевого значения

	    	if Entry.objects.filter(headline='Test'):

	Кэширование и QuerySet

		Каждый QuerySet содержит кэш, для уменьшения количества запросов.

		В только что созданном QuerySet кеш пустой.

		После вычисления QuerySet Django сохраняет результат запроса в кеше и возвращает необходимый результат.

		Последующие вычисления QuerySet используют кеш.

		Использование print с queryset не заполнит кэш т.к. будет вызван __repr__(), который показывает только часть объектов.

		Этот код создаст два экземпляра QuerySet и вычислит их не сохраняя. Это означает, что один и тот же запрос будет выполнен дважды, удваивая нагрузку на бд.

			a = [e.headline for e in Entry.objects.all()]

			b = [e.pub_date for e in Entry.objects.all()]

		Чтобы избежать этой проблемы, просто сохраните QuerySet и используйте его повторно:

			queryset = Entry.objects.all()

			# выполнился запрос
			a = [p.headline for p in queryset]

			# был использован кэш
			b = [p.pub_date for p in queryset]

		Или загрузите весь QuerySet:

			queryset = Entry.objects.all()

			[entry for entry in queryset]

			# берет из кэша
			a = queryset[5]

			# берет из кэша
			b = queryset[5]

		QuerySet не кэшируется при использовании индекса или среза.

			queryset = Entry.objects.all()

			# запрос к базе
			a = queryset[5]

			# запрос к базе
			b = queryset[5]

	Создание

		Вы можете использовать get_or_create() с атрибутами ManyToManyField и обратными внешними связями, но это может вызвать некоторые проблемы при создании объектов.

		При использовании bulk_create метод save() не будет вызван, и сигналы pre_save и post_save тоже.

		bulk_create не работает с дочерними моделями при multi-table наследовании и со связями многое-ко-многим.

		Person.objects.create(first_name='Ilya', last_name='Kaduk')

		obj, created = Person.objects.get_or_create(first_name='Ilya', last_name='Kaduk')

		obj, created = Person.objects.update_or_create(first_name='Ilya', last_name='Kaduk')

		Person.objects.bulk_create([
			Person(first_name='Vika', last_name='Baranova'),
			Person(first_name='Ilya', last_name='Kaduk'),
		])

	Копирование

		Связанные объекты не копируются.

		Пример:

			blog = Blog(name='My blog')
			blog.save()

			blog.pk = None
			blog.save()

		Если используем наследование моделей:

			class ThemeBlog(Blog):
			    theme = models.CharField(max_length=200)

			blog = ThemeBlog(name='Django')
			blog.save()

			blog.pk = None
			blog.id = None
			blog.save()

		Для копирования связанных объектов:

			entry = Entry.objects.all()[0]

			old_authors = entry.authors.all()

			entry.pk = None
			entry.save()
			entry.authors = old_authors

	Обновление

		Django не выполняет запросов к базе данных, пока не будет вызван метод save().

		offer = Offer.objects.get(name='old_name')
		offer.name = 'new_name'
		offer.save()

		Обновление связанных объектов

			joe = Author.objects.create(name="Joe")
			entry.authors.add(joe)


			john = Author.objects.create(name="John")
			paul = Author.objects.create(name="Paul")
			entry.authors.add(john, paul)

		Обновление нескольких объектов, которые соотвествуют условию

			Entry.objects.filter(
				pub_date__year=2007
			).update(
				headline='New value'
			)

		Обновление в связанном объекте

			b = Blog.objects.get(pk=1)
			Entry.objects.all().update(blog=b)

		Обновление с сохранением каждого объекта в QuerySet и методом save()

			for item in my_queryset:
			    item.save()

	Выборка 

		Одного

			Entry.objects.get()

			Entry.objects.first()

			Для получения одного объекта, а не списка, используйте индекс вместо среза.

				Entry.objects.all()[0]

		Одного и всех связанных с ним

			blog = Blog.objects.get(pk=1)

			blog.entry__set.all()

			Берет все связанные объекты.

		Всех

			Entry.objects.all()

		Одного/нескольких и связанных с ними

			Entry.objects.select_related('blog').get(pk=5)

			Entry.objects.filter(pub_date__gt=timezone.now()).select_related('blog')

			select_related('foo', 'bar')


			select_related включает в выборку данные связанных объектов.

			Это повышает производительность, потому что потом при обращении к связанным объектам они берутся из кэша.

			Работает только со связями один к одному. То есть берет данные только для одного объекта за раз.

			Чтобы очистить список полей указанных ранее select_related для QuerySet, предайте None.


			pizza = Pizza.objects.all().prefetch_related('toppings')

			Будет выполнено 2 запроса.

			pizza.toppings.all()

			Этот код аналогичен выполнению self.toppings.all() для каждого объекта Pizza, но будут использоваться данные, из кэша QuerySet.


			prefetch_related выбирает данные для каждой связи отдельно.

			Работает со связями один к одному, один ко многим и имногие ко многим.

			Обратите внимание, что будет закэширован также результат выполнения основного QuerySet, а также будут загружены все связанные объекты. Это отличается от стандартного поведения QuerySets, при котором Django старается не загружать связанные данные как можно дольше.

	Фильтрация 

		Entry.objects.filter(pk__in=[1,4,7])

		По связанным объектам

			Entry.objects.filter(blog__name='Beatles Blog')

			Все работает и в другую сторону. Чтобы обратиться к обратной связи, просто используйте имя модели в нижнем регистре или имя указанное в related_name.

				Blog.objects.filter(entry__authors__name='Lennon')

			Если вы используйте фильтр через несколько связей и одна из промежуточных моделей не содержит подходящей связи, Django расценит это как пустое значение

		По связям многие ко многим

			# возьми все с ...=2006, а также с ...='What'

			Entry.objects.filter(
				pub_date__year=2006
			).filter(
				headline__startswith='What'
			)

			# запись должна удовлетворять оба условия

			Entry.objects.filter(
				pub_date__year=2006, 
				headline__startswith='What', 
				pub_date__gte=datetime(2005, 1, 30)
			)

		Exclude по связям многие ко многим

			Blog.objects.exclude(
			    entry__headline__contains='Lennon',
			    entry__pub_date__year=2008,
			)

		Фильтры могут ссылаться на поля модели

			Entry.objects.filter(n_comments__gt=F('n_pingbacks'))

		Если необходимо всего лишь узнать содержит ли результат, то эффективнее использовать метод exists()

			Entry.objects.filter(pk=22).exists()

		Другие варианты

			# точное совпадение
			Entry.objects.filter(headline__exact="Cat bites dog")

			# точное регистро-независимое, совпадение
			Entry.objects.filter(name__iexact='beatles blog')

			# проверка на вхождение, как Like
			Entry.objects.filter(headline__contains='Lennon')
			
			# знак % экранировать не нужно
			Entry.objects.filter(headline__contains='%')

			# регистронезависимая проверка на вхождение
			Entry.objects.filter(headline__icontains='Lennon')

			# больше чем
			Entry.objects.filter(id__gt=4)

			# больше чем или равно
			Entry.objects.filter(id__gte=4)

			# меньше чем
			Entry.objects.filter(id__lt=4)

			# меньше чем или равно
			Entry.objects.filter(id__lte=4)

			# начинается ли поле с указанного значения
			Entry.objects.filter(id__startswith=4)

			# регистронезависимая проверка начинается ли поле с указанного значения
			Entry.objects.filter(id__istartswith=4)

			# проверка оканчивается ли поле с указанного значения
			Entry.objects.filter(id__endswith=4)

			# регистронезависимая проверка оканчивается ли поле с указанного значения
			Entry.objects.filter(id__iendswith=4)

			# проверка на вхождение в диапазон (включающий)
			Entry.objects.filter(pub_date__range=(start_date, end_date))

			# проверка на дату
			Entry.objects.filter(pub_date__date=datetime.date(2005, 1, 1))

			# проверяет на IS NULL
			Entry.objects.filter(pub_date__isnull=True)

			# проверяет на IS NOT NULL
			Entry.objects.filter(pub_date__isnull=False) 

			# полнотекстовый поиск, который использует преимущества полнотекстового индекса. Работает как и contains но значительно быстрее.
			Entry.objects.filter(headline__search="+Django -jazz Python")

			# проверка регулярным выражением
			Entry.objects.filter(title__regex=r'^(An?|The) +')

			# регистронезависимая проверка регулярным выражением
			Entry.objects.filter(title__iregex=r'^(an?|the) +')

	F()

		Экземпляр F() рассматривается как ссылка на другое поле модели.

		Эти ссылки могут быть использованы например для сравнения значений двух разных полей одного объекта модели.

		Так же с помощью экземпляра F() можно получить значение не из кэша queryset.

		Entry.objects.filter(n_comments__gt=F('n_pingbacks'))

	Q()

		Используется для составления сложных выборок с множественными операторами OR, AND.

		Объекты Q могут быть объединены операторами & и |.

		from django.db.models import Q

		Poll.objects.get(
		    Q(question__startswith='Who'),
		    Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6))
		)

			SELECT 
				* 
			FROM 
				polls 
			WHERE 
				question 
			LIKE 
				'Who%' 
			AND 
				(pub_date = '2005-05-02' OR pub_date = '2005-05-06')

	Агрегация

		Позволяют вычислить одно значение из группы значений одного столбца в таблице. 

		Например мы хотим узнать кол-во книг всех авторов или кол-во книг одного автора.


		Для всех объектов в целом

			Используется .aggregate()

			aggregate() завершающая инструкция для QuerySet, которая возвращает словарь с результатом.


			Book.objects.all().aggregate(Avg('price'))

			Book.objects.aggregate(Avg('price'))

			# Оба запроса выше вычислят результат, который будет доступен по ключу price__avg

			Book.objects.aggregate(Avg('price'), Max('price'), Min('price'))

			# average_price - имя ключа по которому можно получить результат
			Book.objects.aggregate(average_price=Avg('price'))

		Для каждого объекта

			Используется .annotate()


			book = Book.objects.annotate(Count('authors'))

			book[0].authors__count

			book[1].authors__count

			Book.objects.annotate(num_authors=Count('authors'))

			Book.objects.annotate(Count('authors'), Count('chapters'))


			Объединение нескольких агрегаций через annotate() может привести к неправильному результату, т.к. объединяются несколько таблиц. Из-за использования LEFT OUTER JOIN могут создаваться дублирующиеся записи, если объединенные таблицы содержат разное количество записей. Однако, агрегация Count принимает аргумент distinct, который может помочь.

				Book.objects.annotate(Count('authors', distinct=True), Count('chapters', distinct=True))

		По связанным моделям

			Store.objects.aggregate(min_price=Min('books__price'))

			Store.objects.annotate(min_price=Min('books__price'))


			Store.objects.aggregate(youngest_age=Min('books__authors__age'))

		Обратные связи

			Publisher.objects.annotate(Count('book'))

			# получаем самую старую книгу издателя
			Publisher.objects.aggregate(oldest_pubdate=Min('book__pubdate'))

		Другие методы и агрегация

			При исользовании будет использовататься тот порядок, который задан, то есть если сначала идет агрегация, а потом фильтрация, то так и будет. И на оборот.


			Фильтр ограничит выборку объектов, для которых необходимо выполнить агрегацию.

			Фильтры и exclud-ы можно использовать после агрегации.


			Book.objects.filter(name__startswith="Django").annotate(num_authors=Count('authors'))

			Book.objects.annotate(num_authors=Count('authors')).filter(num_authors__gt=1)

		Аннотация и сортировка order_by()

			При исользовании будет использовататься тот порядок, который задан, то есть если сначала идет агрегация, а потом фильтрация, то так и будет. И на оборот.

			Book.objects.annotate(num_authors=Count('authors')).order_by('num_authors')

		Аннотация и values()

			При исользовании будет использовататься тот порядок, который задан, то есть если сначала идет агрегация, а потом фильтрация, то так и будет. И на оборот.

			Вместо того, чтобы вычислить значение для каждого объекта QuerySet, сначала все объекты результата будут разделены на группы по уникальному значению полей, указанных в values().

			А аннотация будет использована для каждой группы и будут использованы значения всех объектов группы.

			Author.objects.values('name').annotate(average_rating=Avg('book__rating'))

				В примере выше, авторы будут сгруппированы по имени, поэтому вы получите средний рейтинг для уникального имени автора. 

				Это означает, что, если в базе есть два автора с одинаковым именем, их результаты будут объединены вместе, а среднее значение будет вычислено, как среднее значение книг обоих авторов.

				Однако, если annotate() используется перед values(), аннотация будет вычислена для каждого объекта и values() просто ограничит возвращаемые поля.

		Влияние сортировки по-умолчанию и order_by()

			Если в модели задана сортировка по умолчанию, то она будет влиять.

				class Meta:
					ordering = ['name']

				Чтобы решить проблему нужно убрать сортировку из запроса и добавить нужные поля в values().

					Item.objects.values("data").annotate(Count("id")).order_by()

		Аннотация для агрегации

			Можно использовать если нужно посчитать среднее количество авторов для каждой книги.

				Book.objects.annotate(num_authors=Count('authors')).aggregate(Avg('num_authors'))

	Удаление

		entry = Entry.objects.first()
		entry.delete()

		Entry.objects.filter(pub_date__year=2005).delete()

	Использование чистого SQL

		Использование модели

			Этот вариант выполняет запрос и возвращает RawQuerySet.

			RawQuerySet может быть проитерирован (как и обычный QuerySet) для получения объектов.

				Хотя RawQuerySet и можно проитерировать как QuerySet, RawQuerySet не предоставляет все методы QuerySet.

			SQL Запрос переданный в .raw() не проверяется.

			Если запрос возвращает не набор записей, вы получите ошибку.

			Выполняя запрос в MySQL, обратите внимание на преобразование типов. 

				Если вы выполняете запрос по текстовому полю, но используете числовое значение, MySQL преобразует все значения поля в число перед сравнением.

				Чтобы избежать этого, используйте значение правильного типа в запросе.

			Person.objects.raw('SELECT * FROM myapp_person')

			for p in Person.objects.raw('SELECT * FROM myapp_person'):
				print(p)

			first_person = Person.objects.raw('SELECT * FROM myapp_person')[0]

				Если база данных содержит большое количество записей Person, эффективнее ограничить результат выборки на уровне SQL.

					first_person = Person.objects.raw('SELECT * FROM myapp_person LIMIT 1')[0]

			Отложенная загрузка полей

				Есть только одно поле, которое вы обязаны загрузить - первичный ключ.

					Если вы забудете про первичный ключ, будет вызвано исключение InvalidQuery.

				Это означает, что неуказанные в запросе поля будут загружены при обращении к ним.

					for p in Person.objects.raw('SELECT id, first_name FROM myapp_person'):
						# этого поля не было в запросе и оно загрузилось только сейчас (выполнился ещё один запрос)
						print(p.last_name)

			Используйте %s в строке с запросом для списка параметров, или %(key)s для словаря(где key будет заменен на значение ключа из словаря), независимо от базы данных.

				lname = 'Doe'
				erson.objects.raw('SELECT * FROM myapp_person WHERE last_name = %s', [lname])

			Не используйте форматирование строк в запросе!

				При вставке параметров непосредственно в строку запроса, рано или поздно вы станете жертвой атаки с внедрением SQL-кода. 

				query = 'SELECT * FROM myapp_person WHERE last_name = %s' % lname
				Person.objects.raw(query)

		Выполнение запроса на прямую

			def my_custom_sql(self):
			    cursor = connection.cursor()

			    cursor.execute('SELECT foo FROM bar WHERE baz = %s', [self.baz])

			    return cursor.fetchone()

			Если необходимо вставить символ процента, необходимо его продублировать.

				cursor.execute("SELECT foo FROM bar WHERE baz = '30%%' AND id = %s", [self.id])

			Если вы используете несколько баз данных, вы можете использовать django.db.connections для получения подключения к конкретной базе данных.

				cursor = connections['my_db_alias'].cursor()

			По умолчанию Python DB API вернет результат без названий полей, то есть вы получите список значений, а не словарь.

				За счет небольшой потери производительности вы можете получить словарь следующим образом:

					def dictfetchall(cursor):
					    columns = [col[0] for col in cursor.description]
					    return [
					        dict(zip(columns, row))
					        for row in cursor.fetchall()
					    ]
	Оптимизация

		Первым делом определите какие запросы выполняются и как быстро.

			from django.db import connection

			connection.queries

			или

			Customer.objects.filter(email='kaduk@gmail.com').query

		Вы также можете использовать сторонние приложения, например, django-debug-toolbar, или инструменты, которые мониторят непосредственно базу данных.

		Следует добавить индексы полям, которые используются в filter(), exclude(), order_by() и др., т.к. они ускоряют поиск по полям.

		Понимание, когда выполняется QuerySets - важная часть для написания эффективного простого кода.

		Понимание кэширования атрибутов QuerySets.

		Шаблонизатор не позволяет использовать скобки и автоматом вызывает функции и методы.

		Будьте внимательны с собственными свойствами - вы должны самостоятельно реализовать кэширование, используя, например, декоратор cached_property.

		Для использования кэширования в QuerySet можно использовать шаблонный тэг with.

		Если у вас очень много объектов, кэширование в QuerySet может использовать большой объем памяти. В этом случае может помочь iterator().

		Выполняйте задачи базы данных в базе данных, а не в Python.

			Самое простое: используйте filter и exclude для фильтрации данных в БД.

			Используйте объект F() для фильтрации по другим полям модели.

		Не совсем переносимый между разными БД, но очень мощный метод - RawSQL, который позволяет добавить SQL непосредственно в запрос. 

		Если не помогает RawSQL, то используйте собственный SQL запрос для получения данных и загрузки в модели.

		Загружайте все данные сразу, если уверены, что будете использовать их.

			Обращение несколько раз к базе данных для получения различных частей одного “массива” данных обычно менее эффективно, чем получение всех данных одним запросом.

			Смотреть select_related и prefetch_related.

		Не получайте данные, которые вам не нужны.

			Смотреть в сторону values() и values_list(), а также defer() и only().

		Вместо загрузки данных в объекты, изменения значений и отдельного их сохранения, используйте update() и delete().

		Используйте значения ключей непосредственно.

			Если вам необходимо только значение внешнего ключа, используйте его, а не обращайтесь к объекту.

				То есть лучше так entry.blog_id, чем так entry.blog.id

		Не сортируйте данные, если вам это не требуется.

			Сортировка требует ресурсы.

			Рандомная сортировка, может быть медленным и сильно нагружать базу данных, поэтому лучше явно задавать.

				Invoice.objects.order_by('?')

			Если модель имеет сортировку по умолчанию (Meta.ordering) и она вам не нужна, уберите её из запроса с помощью order_by() без параметров.

		Используйте общее добавление с помощью bulk_create().

			Это относится и к ManyToManyFields. Так лучше my_band.members.add(me, my_friend), чем так:

				my_band.members.add(me)
				my_band.members.add(my_friend)

3.15. Аутентификация

	https://djbook.ru/rel1.9/topics/auth/index.html

	https://djbook.ru/rel1.9/topics/auth/default.html

	https://docs.djangoproject.com/en/2.2/topics/auth/

	https://docs.djangoproject.com/en/2.2/topics/auth/default/

3.16. Кэширование

	Memcached является самый быстрым и эффективным типом кэша доступный Django.

	Memcached полностью располагается в оперативной памяти.

	Настройка
	
		CACHES = {
		    'default': {
		        'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache',
		        'LOCATION': '127.0.0.1:11211',
		    }
		}

4.1. Советы

	Если нужно например приложение на русском, английском, французском языке, то лучше использовать нижнее подчёркивание _('').

	Если не хватает того, что предоставляет django, то пользуемся методами для расширения. Если не хватает и методов для расширения, то только тогда изменяем реализацию самостоятельно.

	Для расширения встроенных классов можно использовать mixin-ы.

	Не использовать mixin-ы для переопределения методов.

	При возникновении ошибок django, связанных с движком, смотрет в сторону значений переменных окружения, которые задаются в settings или local_settings. Так же смотреть всю страницу с ошибками в браузере.

	Помнить о логировании событий и сигналах django.

	В django паттерн наблюдатель можно реализовать с помощью сигналов.

	В django при работе с админкой помнить, что save_model это уже метод после проверки формы, поэтому вся логика для валидации должна быть в методе для работы с формой - get_form.

	При написании тестов лучше не отлавливать ошибки (например ObjectDoesNotExist), потому что тогда тест проходит успешно и другой разраб может подумать, что все хорошо. Лучше пусть падают с ошибкой.