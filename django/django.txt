Оглавление

	Философия дизайна

	Настройки

	Основные настройки

	django-admin и manage.py


	ORM

	Связи

	Наследование

	Атрибуты

	Методы


	QuerySet

	Когда вычисляется QuerySet

	Кэширование и QuerySet


	Выполнение запросов
	

	Как Django обрабатывает запрос

	Как Django хранит пароли

	Развертывание

Философия дизайна

	Фундаментальная основа стека Django - это слабая связанность.

		Отдельным слоям фреймворка не следует “знать” друг о друге, если в этом нет острой необходимости.

		Например, система шаблонов ничего не знает о Web запросах, а базу данных не интересует, как эти данные представлены.

		Django поставляется с пакетом приложений, который представляет из себя кусочки, для удобства независимые настолько, насколько это возможно.

	Меньше кода

		Приложения Django должны использовать настолько мало кода, насколько возможно, следует избегать шаблонных кусков.

	Не повторяйтесь (DRY)

		Каждая отдельная концепция и/или кусок данных следует хранить в одном и лишь одном месте. Избыточность - плохо. Нормализация - хорошо.

	Явное лучше чем неявное

		Это значит, что Django не должен творить слишком много магии.

	Эффективность SQL

		SQL запросы должны выполняться как можно реже, и должны быть оптимизированы.

	Всё должно быть на своих местах

		Например вся информация, описывающая модель и логику ее работы  определена в классе модели.

Настройки

	Файл настроек содержит полную конфигурацию установленного проекта и называется settings.py

	Файл настроек - это просто модуль python с переменными модуля.

	Можно динамически определять настройки, используя обычный синтаксис python.

		settings.MY_SETTING.append['new_param']

	Можно импортировать значения из других файлов настроек.

		from settings_local import *

	Можно явно указать какие настройки должны использоваться.

		export DJANGO_SETTINGS_MODULE=mysite.settings
		django-admin runserver

		----

		django-admin runserver --settings=mysite.settings

	Для настройки на сервере (Apache и mod_wsgi) нужно указать WSGI-приложению какой файл с настройками использовать.

		import os
		os.environ['DJANGO_SETTINGS_MODULE'] = 'mysite.settings'

	Проект Django не обязан определять какие-либо настройки, если в этом нет необходимости.

		Каждая настройка содержит значение по умолчанию.

		Эти значния можно найти в модуле django/conf/global_settings.py

		Можно сделать так, чтобы настройки загружались по умолчанию не из модуля django/conf/global_settings.py

	Импорт настроек

		Правильно импортировать так:

			from django.conf import settings

	Вам не следует менять настройки в процессе работы приложения.

	Безопасность

		Файл настроек содержит конфиденциальную информацию, например, как пароль к базе данных, вы должны хранить его в безопасности. 

		Например, поменяйте права доступа к файлу, чтобы только вы и пользователь веб-сервера имел к нему доступ. 

		Это особенно важно для хостингов с общим окружением.

	Добавление собственных настроек

		Названия настроек должны быть в верхнем регистре.

		Не изобретайте заново существующие настройки.

Основные настройки

	Можно посмотреть здесь:

		https://djbook.ru/rel1.9/ref/settings.html#core-settings-topical-index

		https://docs.djangoproject.com/en/2.2/ref/settings/#core-settings-topical-index

	BASE_DIR

		Здесь путь корневой директории с проектом. 

	SECRET_KEY 

		Исользуется для различных механизмов защиты django приложений.

		Используется для криптографической подписи, если не указан другой ключ.

		Используется для всех сессий, кроме django.contrib.sessions.backends.cache.

		Без него проект не запуститься.

		Генерится автоматов при создании проекта.

		Не используется для хранения пароля пользователей и при смене они не будут сломаны.

	DEBUG

		Включает/выключает режим отладки.

		Не использовать True на боевом сервере.

		При DEBUG равном False, необходимо правильно указать ALLOWED_HOSTS, а иначе все запросы будут возвращать Bad Request (400).

	ALLOWED_HOSTS

		Список хостов/доменов, для которых может работать текущий сайт.

		Это сделано для безопасности, чтобы обезопасить от внедрения в куки или письма для сброса пароля ссылок на сторонний сайт подменив HTTP заголовок Host.

		Проверка обычно нужна только на боевом сервере.

	INSTALLED_APPS

		Здесь список всех приложений Django, используемых в проекте.

		Названия приложения должны быть уникальны.

		Если несколько приложений содержат разные версии одних и тех же ресурсов (шаблоны, статические файлы, команды, файлы перевода), будут использоваться ресурсы из приложения, которое указано выше.

	MIDDLEWARE

		Здесь список всех промежуточных слоев проекта.

	ROOT_URLCONF

		Путь для импорта главной конфигурации URL-ов.

	WSGI_APPLICATION

		Полный путь к объекту WSGI приложения, которое будет использовать встроенный сервер Django.

		Команда django-admin startproject создаст простой wsgi.py файл с функцией application, и установит значение этой настройки на этот объект application.

	DATABASES

		Здесь настройки подключения к бд.

	    'default': {
	        'ENGINE': 'django.db.backends.postgresql',
	        'NAME': 'magic',
	        'USER': 'root',
	        'PASSWORD': 'asdf1234',
	        'HOST': '127.0.0.1',
	        'PORT': '5432',
	    },

	AUTH_PASSWORD_VALIDATORS

		Здесь список валидаторов, которые проверяют надежность пароля пользователя.

	LANGUAGE_CODE

		Здесь установка языка, который используется в проекте.

	TIME_ZONE

		Засовой пояс, который будет использоваться в проекте.

	USE_I18N

		Указывает, используется ли механизм перевода Django.

		Если выключен, то повышает производительность.

	USE_L10N

		Указывает, использовать ли локализованный формат даты.

	USE_TZ

		При True, Django будет использовать объекты даты и времени с указанным часовым поясом. 

		Иначе Django будет использовать объекты даты и времени без учета часового пояса.

	CACHES

		Настройки механизма кэширования.

	DATABASE_ROUTERS

		Здесь список маршрутизаторов, которые будут использоваться для определения какую базу данных использовать при выполнении запроса.

	ADMINS

		Здесь список людей, которые будут получать уведомления об ошибках.

	EMAIL_BACKEND

		Бэкенд, используемый для отправки электронных писем.

	STATIC_ROOT

		Здесь путь к каталогу, из которого будут раздаваться статические файлы.

		Выполнив команду python manage.py collectstatic, все статические файлы проекта будут скопированы в указанную директорию.

		STATIC_ROOT и MEDIA_ROOT должны отличаться.

	STATIC_URL

		URL, указывающий на каталог со статическими файлами.

		Если не пустой, то должен оканчиваться косой чертой.

		Например '/static/'

			Будет работать, как http://exmaple.com/static/

	STATICFILES_DIRS

		Здесь общие статические файлы, которые не относятся ни к одному из приложений.

	MEDIA_ROOT

		Абсолютный путь к каталогу, в котором хранятся медиа-файлы.

		MEDIA_ROOT и STATIC_ROOT должны отличаться.

	MEDIA_URL

		URL который указывает на каталог MEDIA_ROOT.

		Например '/media/'

			Будет работать, как http://exmaple.com/media/

		Если вы хотите использовать {{ MEDIA_URL }} в шаблонах, добавьте 'django.template.context_processors.media' в опцию 'context_processors' настройки TEMPLATES.

	LOGGING

		Здесь настройки логгирования.

	APPEND_SLASH

		Настройка APPEND_SLASH используется только вместе с CommonMiddleware.

		Если урл не найден и в конце нет слэша, то будет добавлен и сделано перенаправление.

		Заметим что такое перенаправление может привести к потере всех данных при POST запросе.

	LOGIN_REDIRECT_URL

		URL куда перенаправляется пользователь поле авторизации пользователя в представлении (если не передан параметр next).

	LOGIN_URL

		URL, на который перенаправляются пользователи для авторизации.

	LOGOUT_URL

		URL, на который перенаправляются пользователи после выхода.

	PASSWORD_RESET_TIMEOUT_DAYS

		Количество дней, в течении которых действует ссылка для сброса пароля.

	SESSION_COOKIE_AGE

		По умолчанию: 1209600 (2 недели в секундах)

		Время хранения сесионной куки в секундах.

	SITE_ID

		id сайта в таблице django_site базы данных.

		Используется для привязки данных к конкретному сайту, что позволяет использовать один установленный проект для нескольких сайтов.

django-admin и manage.py

	Это консольные инструменты.

	Во всех примерах в этом разделе используется django-admin, но вы можете использовать manage.py


	django-admin help

		help --commands

		help <command>


	django-admin startproject

	./manage.py version - выводит текущую версию django

	./manage.py startapp name_app (принято именовать во множественном числе)


	./manage.py makemigrations

		--empty - создает пустую миграцию для последующего редактирования вручную

		--merge - решает конфликты с миграциями

		--name - задает имя миграции

	./manage.py migrate

		<app_label>

		<app_label> <migrationname>

		--database

		--fake - помечает миграции, как невыполненные (может “сломать” автоматическое применение миграций)

		--fake-initial - помечает миграции, как выполненные

	./manage.py showmigrations

	./manage.py migrate my_app zero


	./manage.py check - анализирует проект Django на наличие распространенных проблем

		check auth admin othre_app - анализирует только заданные приложения

		check --tag security - проверяет приложения только на безопастность

			--list-tags

		djanog-admin check --deploy - проверяет настройки для продакшена

			djanog-admin check --deploy --settings=production_settings


	./manage.py diffsettings - показывает разницу между текущими настройками и настройками Django по умолчанию

		--all - выводит все настройки, даже если они не отличаются от настроек по умолчанию


	./manage.py changepassword user_name (работает только, если установлена система авторизации)

	./manage.py createsuperuser (работает только, если установлена система авторизации)


	./manage.py runserver

		0.0.0.0:8000


	./manage.py dbshell

		--database

	./manage.py shell - запускает интерактивный интерпретатор Python


	./manage.py loaddata mydata.json - ищет и загружает указанные фикстуры в базу данных


	./manage.py inspectdb - выводит сгенерированные модели Django основе таблиц из бд (может пригодиться, когда есть бд, но нет моделей)

		Если inspectdb не может подобрать подходящий тип поля модели, будет использоваться поле TextField с комментарием в коде 'This field type is a guess.' возле этого поля.

		Если название колонки в таблице входит в зарезервированные слова Python (такие как 'pass', 'class' или 'for'), inspectdb добавит '_field' к названию атрибута.


	./manage.py sendtestemail foo@example.com bar@example.com - отправляет тестовое электронное письмо

		--managers

		--admins


	./manage.py clearsessions - удаляет устаревшие данные сессий


	./manage.py collectstatic - собирает статические файлы приложений в одно место (директория collectstatic)


	Можно посмотреть здесь:

		https://djbook.ru/rel1.9/ref/django-admin.html?highlight=django-admin

		https://docs.djangoproject.com/en/2.2/ref/django-admin/

ORM

    ORM (object relational mapping) - технология программирования, которая обеспечивает работу с базой данных без необходимости писать чистые sql запросы. 

    	В orm класс описывает таблицу в бд.

    	Созданный на основе класса объект представляет собой одну запись в таблице.

    	На основе класса создаётся объект и кладём в бд.

	    Плюсы: скорость разработки

	    Минусы: скорость работы

	Общее

		За работу с базой данных отвечает модель.

		Модели определяются в файле models.py каждого приложения.

		Обычно одна модель представляет одну таблицу в бд.

		В сообществе принято называть таблицы и модели в единственном числе. Например Product.

		После выполнения миграций на основе моделей в базе данных создаются таблица в формате appname_modelname (cards_product).

			Название таблицы можно переопределить с помощью параметра db_table, который нужно добавить в класс Meta, который находится внутри класса модели.

				Настоятельно рекомендуем использовать нижний регистр при переопределении названия таблицы через db_table, особенно при использовании MySQL.

		После определения моделей необходимо указать Django что необходимо их использовать. Это можно сделать, добавив в INSTALLED_APPS имя приложения.

		Нельзя использовать имена конфликтующие с API моделей, такие как clean, save или delete.

		Cамые используемые настройки полей:

			null 

				Если True, Django сохранит пустое значение как NULL в базе данных. По умолчанию - False.

			blank

				Если поле содержит blank=True, форма позволит передать пустое значение. При blank=False - поле обязательно.

			choices

				При определении, виджет формы использует select вместо стандартного текстового поля и ограничит значение поля указанными значениями.

			    SHIRT_SIZES = (
			        ('S', 'Small'),
			        ('M', 'Medium'),
			        ('L', 'Large'),
			    )
			    shirt_size = models.CharField(max_length=1, choices=SHIRT_SIZES)

			default

				Значение по умолчанию для этого поля.

			primary_key

				При True поле будет первичным ключом.

				При этом Django не добавит поле id по умолчанию.

			unique

				При True поле будет уникальным.

		По умолчанию Django для каждой модели добавляет такое поле: 

			id = models.AutoField(primary_key=True)

			Это автоинкрементный первичный ключ.

		Каждое поле, кроме ForeignKey, ManyToManyField и OneToOneField, первым аргументом принимает необязательное читабельное название.

			first_name = models.CharField('User name')

		ForeignKey, ManyToManyField и OneToOneField первым аргументом принимает класс модели, поэтому для читабельного названия используется аргумент verbose_name.

			sites = models.ForeignKey(Site, verbose_name='list of sites')

		Желательно, чтобы название поля ForeignKey связанной было названием модели в нижнем регистре.

		Для поля ForeignKey можно задать имя для обратной связи.

			class Dealer(models.Model):
				name = models.CharField(max_length=255)

			class Car(models.Model):
				dealer = models.ForeignKey(Dealer, related_name='super_cars')

			Dealer.objects.first().super_cars.all()

		Название поля не может быть слово зарезервированное Python, т.к. это приведет к синтаксической ошибке.

		Зарезервированные SQL слова, такие как join, where или select, можно использовать как название поля

		Название поля не может содержать несколько нижних подчеркиваний подряд, т.к. такой подход Django использует для формирования запросов.

		Можно создавать собственные типы полей.

		Дополнительные настройки для модели можно определить через class Meta.

			class Ox(models.Model):
			    horn_length = models.IntegerField()

			    class Meta:
			        ordering = ['horn_length']
			        verbose_name_plural = 'oxen'

		Можно создать неуправляемую модель, указав в meta, managed=False.

			Таблицы для этой модели не будет создаваться или удаляться.

			Это полезно, если модель отображает существующую таблицу или “VIEW” в базе данных, которая была создана другим способом.

Связи бд

	Один к одному

		class People(models.Model):
			name = models.CharField(max_length=255)

		class Pasport(models.Model):
			people = models.OneToOneField(People, on_delete=models.CASCADE)
			code = models.IntegerField()

		На основе этих моделей создадутся 2 таблицы в бд - appname_people, appname_pasport.

		В таблице appname_pasport будет связь один к одному - people_id.

	Один ко многим

		class Dealer(models.Model):
			name = models.CharField(max_length=255)

		class Car(models.Model):
			dealer = models.ForeignKey(Dealer, on_delete=models.CASCADE)

	Связь на модель, которая еще не определена

		class Car(models.Model):
			dealer = models.ForeignKey('Dealer', on_delete=models.CASCADE)

		class Dealer(models.Model):
			name = models.CharField(max_length=255)

		Для связи на модель из другого приложения используйте название модели и приложения.

			class Car(models.Model):
				dealer = models.ForeignKey('app_name.Dealer', on_delete=models.CASCADE)

	Многие ко многим

		class Topping(models.Model):
		    pass

		class Pizza(models.Model):
		    toppings = models.ManyToManyField(Topping)

		Желательно, чтобы название поля ManyToManyField было множественным называнием связанных объектов.

		Не имеет значения какая модель содержит поле ManyToManyField, но его может содержать только одна из моделей.

		Обычно, ManyToManyField необходимо добавить в модель, которая будет редактироваться в форме. 

			И потому что обычно думают о пицце с ингредиентами, а не об ингредиентах в различных пиццах.

		В итоге на основе данной модели в бд создастся таблица appname_pizza_toppings.

		Иногда необходимо хранить дополнительную информацию о связи.

			Например музыкальные группы, музыканты и когда музыкант вступил в группу.

			Для таких случаев Django позволяет определить модель для хранения связи многие ко многим и дополнительной информации.

				class Person(models.Model):
				    name = models.CharField(max_length=128)

				class Group(models.Model):
				    name = models.CharField(max_length=128)
				    members = models.ManyToManyField(Person, through='Membership')

				class Membership(models.Model):
				    person = models.ForeignKey(Person, on_delete=models.CASCADE)
				    group = models.ForeignKey(Group, on_delete=models.CASCADE)
				    date_joined = models.DateField()
				    invite_reason = models.CharField(max_length=64)

				На основе этих моделей создадутся таблицы appname_person, appname_group, appname_membership (здесь и будет находиться связи - person_id, group_id)

				По сути эта такая же связь многие ко многим только с дополнительными полями в таблице, где хранится связь.

Наследование

	Базовый класс должен наследоваться от models.Model.

	Нужно определить, это должна ли родительская модель быть независимой моделью (с собственной таблицей в базе данных), или же родительская модель просто контейнер для хранения информации, доступной только через дочерние модели.

	Запрещено переопределять атрибуты класса родителя в дочернем классе.

		То есть если родительская модель имеет поле author, вы не можете создать поле с именем author в дочерних моделях.

		Эти ограничения относятся только для атрибутов, которые являются экземплярами Field. Остальные атрибуты могут быть переопределены.

	Абстрактные модели

		Удобны при определении общих, для нескольких моделей, полей.

		Для этой модели не будет создана таблица в базе данных.

		Поля в абстрактной модели будут в той модели, которая наследуется от неё.

		Нельзя использовать поля с одинаковыми названиями в дочерней и родительской моделях.

		Абстрактная модель не имеет менеджера.

		Если дочерний класс не определяет собственный класс Meta, он унаследует родительский класс Meta.

		Можно расширить родительский класс Meta.

		class CommonInfo(models.Model):
		    name = models.CharField(max_length=100)
		    age = models.PositiveIntegerField()

		    class Meta:
		        abstract = True

		class Student(CommonInfo):
		    home_group = models.CharField(max_length=5)

		    class Meta(CommonInfo.Meta):
		        db_table = 'student_info'

		Используя атрибут related_name для ForeignKey или ManyToManyField, вы должны всегда определять уникальное название для обратной связи.

			Потому что поля абстрактной модели будут добавлены в каждой из дочерних моделей, с теми же значениями аргументов.

			Не указав related_name для абстрактной модели, для обратной связи будет использовано название дочерней модели плюс '_set'.

	Multi-table

		Каждая модель имеет собственную таблицу в базе данных и может быть использована независимо.

		Наследование использует связь между родительской и дочерней моделью через автоматически созданное поле OneToOneField.

		Все поля родительской модели будут доступны в дочерней при том, что значения будут храниться в разных таблицах.

		Дочерняя модель не имеет доступа к родительскому классу Meta.

		Можно не наследовать настроеки Meta родительской модели.

		При использовании ForeignKey и ManyToManyField в дочерней модели по отношении к родительской обязательно нужно указать related_name

		class Place(models.Model):
		    name = models.CharField(max_length=50)
		    address = models.CharField(max_length=80)

		class Restaurant(Place):
		    serves_hot_dogs = models.BooleanField(default=False)
		    serves_pizza = models.BooleanField(default=False)

		    class Meta:
		    	ordering = []

		class Guest(Place):
			customers = models.ManyToManyField(Place, related_name='guests')

	Proxy модели

		Используются для переопределения поведения модели (например сортировка, менеджер и т.д.) не меняя структуры базы данных.

		Указать что это proxy модель можно установив атрибут proxy в классе Meta в True.

		Если вы не определите ни один менеджер для proxy модели, он будет унаследован от родительской модели.

		Proxy модель использует ту же таблицу в базе данных, что и оригинальная.

		Должна наследоваться от одной модели.

		class Person(models.Model):
		    first_name = models.CharField(max_length=30)
		    last_name = models.CharField(max_length=30)

		class ProxyPerson(Person):
			objects = NewManager()

		    class Meta:
		        proxy = True

	Множественное наследование

		Если есть несколько родительских объектов с классом Meta, в таком случае будет использован атрибут первой родительской модели, остальные будут проигнорированы.

		Наследование от нескольких моделей, которые содержат первичное поле id, вызовет ошибку.

			Чтобы избежать этой проблемы, можно явно указать AutoField поля в базовых моделях.

		class Article(models.Model):
		    article_id = models.AutoField(primary_key=True)

		class Book(models.Model):
		    book_id = models.AutoField(primary_key=True)

		class BookReview(Book, Article):
		    pass

Атрибуты

	Самый важный это objects, который является менеджером модели.

	Менеджер это интерфейс, через который Django выполняет запросы к базе данных и получает объекты.

	Менеджеры доступны только через класс модели, они не доступны в экземплярах (объектах) модели.

Методы

	__str__ - возращает строковое представление объекта

	__eq__ - ?

	__hash__ - возращает хэш объекта

	get_absolute_url - возвращает строку-url для объекта (используется в интерфейсе администратора для "Показать на сайте")

		<a href="{{ object.get_absolute_url }}">{{ object.name }}</a>

	get_FOO_display - возвращает значение поля из choices, который определен в модели. FOO нужно заменить на имя choices

		class Person(models.Model):
		    SHIRT_SIZES = (
		        ('S', 'Small'),
		        ('M', 'Medium'),
		        ('L', 'Large'),
		    )

		p = Person(name="Fred")
		p.get_shirt_size_display()

	get_next_by_FOO - возвращает следующее значение поля из choices от текущего

	get_previous_by_FOO - возвращает предыдущее значение поля из choices от текущего

	Переопределение методов модели

		Чаще всего вы захотите переопределить метод save() и delete().

		Переопределенные методы модели не вызываются при множественных операциях с bulk.

		Учтите, метод delete() не обязательно вызывается при массовом удалении объектов через QuerySet или как результат каскадного удаления.

		class Blog(models.Model):
		    name = models.CharField(max_length=100)

		    def save(self, *args, **kwargs):
		        # action before

		        super().save(*args, **kwargs)

		        # action after

	Свои методы модели

		Для добавления функционала работы с экземпляром модели, необходимо добавить метод в модель.

		Методы модели работают с конкретной записью в таблице.

		class Person(models.Model):
		    def get_full_name(self):
		    	return '{name] {surname}'.format(name=self.name, surname=self.surname)

	Все параметры мета можно посмотреть здесь:

		https://djbook.ru/rel1.9/ref/models/options.html

		https://docs.djangoproject.com/en/2.2/ref/models/options/

	Типы полей можно посмотреть здесь:

		https://djbook.ru/rel1.9/ref/models/fields.html#model-field-types

		https://docs.djangoproject.com/en/2.2/ref/models/fields/#field-types

QuerySet

	Для получения объектов из базы данных, создается QuerySet.

	QuerySet представляет выборку объектов из базы данных.

	Обратиться к менеджерам можно только через класс модели и нельзя через экземпляр.

	После каждого изменения QuerySet, вы получаете новый QuerySet, который никак не связан с предыдущим.

	Создание QuerySet не выполняет запросов к базе данных, пока QuerySet не вычислен.

	Если используется срез, больше нельзя изменять queryset (например, добавлять фильтры, менять сортировку и т.д.).

Когда вычисляется QuerySet
	
	При первом выполнении итерации

		for e in Entry.objects.all():
    		print(e.headline)

    Если будет указан шаг среза

    	Entry.objects.all()[1:10:2]

    	Срез без шага возвращает новый не вычисленный QuerySet.

    Если используется pickle для QuerySet

    При обращении к св-ву объекта

    	entry = Entry.objects.all()
    	entry.first().name

    При использовании repr()

    	repr() используется для строкового представления объекта.

    При использовании len()

    	entry_count = len(Entry.objects.all())

    При использовании list()

    	entry_list = list(Entry.objects.all())

    При вычислении булевого значения

    	if Entry.objects.filter(headline='Test'):

Кэширование и QuerySet

	Каждый QuerySet содержит кэш, для уменьшения количества запросов.

	В только что созданном QuerySet кеш пустой.

	После вычисления QuerySet Django сохраняет результат запроса в кеше и возвращает необходимый результат.

	Последующие вычисления QuerySet используют кеш.

	Использование print с queryset не заполнит кэш т.к. будет вызван __repr__(), который показывает только часть объектов.

	Этот код создаст два экземпляра QuerySet и вычислит их не сохраняя. Это означает, что один и тот же запрос будет выполнен дважды, удваивая нагрузку на бд.

		a = [e.headline for e in Entry.objects.all()]

		b = [e.pub_date for e in Entry.objects.all()]

	Чтобы избежать этой проблемы, просто сохраните QuerySet и используйте его повторно:

		queryset = Entry.objects.all()

		# выполнился запрос
		a = [p.headline for p in queryset]

		# был использован кэш
		b = [p.pub_date for p in queryset]

	Или загрузите весь QuerySet:

		queryset = Entry.objects.all()

		[entry for entry in queryset]

		# берет из кэша
		a = queryset[5]

		# берет из кэша
		b = queryset[5]

	QuerySet не кэшируется при использовании индекса или среза.

		queryset = Entry.objects.all()

		# запрос к базе
		a = queryset[5]

		# запрос к базе
		b = queryset[5]

Сравнение объектов

	some_entry = Entry.objects.first()

	other_entry = Entry.objects.first()

	# будут сравнены первичные ключи
	some_entry == other_entry

	Если первичный ключ назван не id - это не проблема. Сравнение всегда использует первичный ключ.

Выполнение запросов

	Создание

		Вы можете использовать get_or_create() с атрибутами ManyToManyField и обратными внешними связями, но это может вызвать некоторые проблемы при создании объектов.

		При использовании bulk_create метод save() не будет вызван, и сигналы pre_save и post_save тоже.

		bulk_create не работает с дочерними моделями при multi-table наследовании и со связями многое-ко-многим.


		Person.objects.create(first_name='Ilya', last_name='Kaduk')

		obj, created = Person.objects.get_or_create(first_name='Ilya', last_name='Kaduk')

		obj, created = Person.objects.update_or_create(first_name='Ilya', last_name='Kaduk')

		Person.objects.bulk_create([
			Person(first_name='Vika', last_name='Baranova'),
			Person(first_name='Ilya', last_name='Kaduk'),
		])

	Копирование

		blog = Blog(name='My blog')
		blog.save()

		blog.pk = None
		blog.save()

		Примечание! Связанные объекты не копируются.

		Если используем наследование моделей, то так:

			class ThemeBlog(Blog):
			    theme = models.CharField(max_length=200)

			blog = ThemeBlog(name='Django')
			blog.save()

			blog.pk = None
			blog.id = None
			blog.save()

			Примечание! Связанные объекты не копируются.

		Для копирования связанных объектов:

			entry = Entry.objects.all()[0]

			old_authors = entry.authors.all()

			entry.pk = None
			entry.save()
			entry.authors = old_authors

	Обновление

		Django не выполняет запросов к базе данных, пока не будет вызван метод save().


		offer = Offer.objects.get(name='old_name')
		offer.name = 'new_name'
		offer.save()

		Обновление связанных объектов

			joe = Author.objects.create(name="Joe")
			entry.authors.add(joe)


			john = Author.objects.create(name="John")
			paul = Author.objects.create(name="Paul")
			entry.authors.add(john, paul)

		Обновление нескольких объектов, которые соотвествуют условию

			Entry.objects.filter(
				pub_date__year=2007
			).update(
				headline='New value'
			)

		Обновление в связанном объекте

			b = Blog.objects.get(pk=1)
			Entry.objects.all().update(blog=b)

		Обновление с сохранением каждого объекта в QuerySet и методом save()

			for item in my_queryset:
			    item.save()

	Выборка всех

		Entry.objects.all()

	Выборка одного

		Entry.objects.get()

		Entry.objects.first()

	Фильтрация 

		Entry.objects.filter(pk__in=[1,4,7])

		Фильтры по связанным объектам

			Entry.objects.filter(blog__name='Beatles Blog')

			Все работает и в другую сторону. Чтобы обратиться к обратной связи, просто используйте имя модели в нижнем регистре или имя указанное в related_name.

				Blog.objects.filter(entry__authors__name='Lennon')

			Если вы используйте фильтр через несколько связей и одна из промежуточных моделей не содержит подходящей связи, Django расценит это как пустое значение

		Фильтрация по связям многие ко многим

			# возьми все с ...=2006, а также с ...='What'

			Entry.objects.filter(
				pub_date__year=2006
			).filter(
				headline__startswith='What'
			)

			# запись должна удовлетворять оба условия

			Entry.objects.filter(
				pub_date__year=2006, 
				headline__startswith='What', 
				pub_date__gte=datetime(2005, 1, 30)
			)

		Exclude по связям многие ко многим

			Blog.objects.exclude(
			    entry__headline__contains='Lennon',
			    entry__pub_date__year=2008,
			)

		Фильтры могут ссылаться на поля модели

			Entry.objects.filter(n_comments__gt=F('n_pingbacks'))

		Если необходимо всего лишь узнать содержит ли результат, то эффективнее использовать метод exists()

			Entry.objects.filter(pk=22).exists()

		Для получения одного объекта, а не списка, используйте индекс вместо среза

			Entry.objects.all()[0]

		Другие условия выборки

			# точное совпадение
			Entry.objects.get(headline__exact="Cat bites dog")

			# точное регистро-независимое, совпадение
			Entry.objects.filter(name__iexact='beatles blog')

			# проверка на вхождение, как Like
			Entry.objects.filter(headline__contains='Lennon')

			# знак % экранировать не нужно
			Entry.objects.filter(headline__contains='%')

			# регистронезависимая проверка на вхождение
			Entry.objects.filter(headline__icontains='Lennon')

			# больше чем
			Entry.objects.filter(id__gt=4)

			# больше чем или равно
			Entry.objects.filter(id__gte=4)

			# меньше чем
			Entry.objects.filter(id__lt=4)

			# меньше чем или равно
			Entry.objects.filter(id__lte=4)

			# начинается ли поле с указанного значения
			Entry.objects.filter(id__startswith=4)

			# регистронезависимая проверка начинается ли поле с указанного значения
			Entry.objects.filter(id__istartswith=4)

			# проверка оканчивается ли поле с указанного значения
			Entry.objects.filter(id__endswith=4)

			# регистронезависимая проверка оканчивается ли поле с указанного значения
			Entry.objects.filter(id__iendswith=4)

			# проверка на вхождение в диапазон (включающий)
			Entry.objects.filter(pub_date__range=(start_date, end_date))

			# проверка на дату
			Entry.objects.filter(pub_date__date=datetime.date(2005, 1, 1))

			# проверяет на IS NULL
			Entry.objects.filter(pub_date__isnull=True)

			# проверяет на IS NOT NULL
			Entry.objects.filter(pub_date__isnull=False) 

			# полнотекстовый поиск, который использует преимущества полнотекстового индекса. Работает как и contains но значительно быстрее.
			Entry.objects.filter(headline__search="+Django -jazz Python")

			# проверка регулярным выражением
			Entry.objects.filter(title__regex=r'^(An?|The) +')

			# регистронезависимая проверка регулярным выражением
			Entry.objects.filter(title__iregex=r'^(an?|the) +')

	F()

		Экземпляр F() рассматривается как ссылка на другое поле модели.

		Эти ссылки могут быть использованы например для сравнения значений двух разных полей одного объекта модели.

		Так же с помощью экземпляра F() можно получить значение не из кэша queryset.

		Entry.objects.filter(n_comments__gt=F('n_pingbacks'))

	Q()

		Используется для составления сложных выборок с множественными операторами OR, AND.

		Объекты Q могут быть объединены операторами & и |.

		from django.db.models import Q

		Poll.objects.get(
		    Q(question__startswith='Who'),
		    Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6))
		)

			SELECT 
				* 
			FROM 
				polls 
			WHERE 
				question 
			LIKE 
				'Who%' 
			AND 
				(pub_date = '2005-05-02' OR pub_date = '2005-05-06')

	Удаление

		entry = Entry.objects.first()
		entry.delete()

		Entry.objects.filter(pub_date__year=2005).delete()

Как Django обрабатывает запрос

	Определяет какой файл конфигурации урлов считывать.

		Обычно, это значение настройки ROOT_URLCONF.

	Ищет переменную urlpatterns внутри файла с урлами.

	Перебирает каждый URL-шаблон по порядку, и останавливается при первом совпадении.

	Вызывает соответствующее представление.

		При вызове передается объект HttpRequest (параметры запроса), позиционные аргументы (если они есть), именованные аргументы (если они есть)

	Если нет совпадений или на одном из этапов возникла ошибка, то вызывается соответствующий обработчик ошибок.

Как Django хранит пароли

	По умолчанию использует хэширующий алгоритм PBKDF2 (стандарт формирования ключа на основе пароля).

	<algorithm>$<algorithm_count_iterations>$<salt>$<password_hash>

		Это хэширующий алгоритм, количество применений (итераций) алгоритма, случайная соль и полученный хэш пароля.

	Можно выбрать другой хэширующий алгоритм, указав его в PASSWORD_HASHERS.

		Первая запись этого списка будет использоваться для сохранения паролей

		Все остальные записи являются проверенными средствами, которые могут быть применены для проверки существующих паролей.

	Bcrypt является популярным алгоритмом для хранения паролей.

		Данный алгоритм не выбран в качестве стандартного в Django.

		Как установить смотреть здесь:

			https://docs.djangoproject.com/en/2.2/topics/auth/passwords/

				Using bcrypt with Django

	Алгоритмы PBKDF2 и bcrypt используют ряд итераций или округлений для хэшей. 

		Это значительно замедляют действия атакующих, усложняя выполнение атаки на хэшированные пароли. 

		Однако, по мере увеличения вычислительной мощности, количество этих итераций следует увеличивать. 

			С каждой новой версией Django разработчики будут делать это самостоятельно, но также это можно сделать вручную.

			Для самостоятельного увеличения кол-во итерация смотреть:

				https://docs.djangoproject.com/en/2.2/topics/auth/passwords/

					Increasing the work factor

	Управление паролями из кода

		check_password(password, encoded)

		make_password(password, salt=None, hasher='default')

		is_password_usable(encoded_password) - проверяет, является ли переданная строка хэшированным паролем, который имеет шанс пройти проверку с помощью функции check_password()

		validate_password(password, user=None, password_validators=None)

		password_changed(password, user=None, password_validators=None)








	
	



	