Оглавление

	Философия дизайна

	Настройки

	Основные настройки

	django-admin и manage.py

	ORM и работа с базой данных

	Как Django обрабатывает запрос

	Как Django хранит пароли

	Развертывание

Философия дизайна

	Фундаментальная основа стека Django - это слабая связанность.

		Отдельным слоям фреймворка не следует “знать” друг о друге, если в этом нет острой необходимости.

		Например, система шаблонов ничего не знает о Web запросах, а базу данных не интересует, как эти данные представлены.

		Django поставляется с пакетом приложений, который представляет из себя кусочки, для удобства независимые настолько, насколько это возможно.

	Меньше кода

		Приложения Django должны использовать настолько мало кода, насколько возможно, следует избегать шаблонных кусков.

	Не повторяйтесь (DRY)

		Каждая отдельная концепция и/или кусок данных следует хранить в одном и лишь одном месте. Избыточность - плохо. Нормализация - хорошо.

	Явное лучше чем неявное

		Это значит, что Django не должен творить слишком много магии.

	Эффективность SQL

		SQL запросы должны выполняться как можно реже, и должны быть оптимизированы.

	Всё должно быть на своих местах

		Например вся информация, описывающая модель и логику ее работы  определена в классе модели.

Настройки

	Файл настроек содержит полную конфигурацию установленного проекта и называется settings.py

	Файл настроек - это просто модуль python с переменными модуля.

	Можно динамически определять настройки, используя обычный синтаксис python.

		settings.MY_SETTING.append['new_param']

	Можно импортировать значения из других файлов настроек.

		from settings_local import *

	Можно явно указать какие настройки должны использоваться.

		export DJANGO_SETTINGS_MODULE=mysite.settings
		django-admin runserver

		----

		django-admin runserver --settings=mysite.settings

	Для настройки на сервере (Apache и mod_wsgi) нужно указать WSGI-приложению какой файл с настройками использовать.

		import os
		os.environ['DJANGO_SETTINGS_MODULE'] = 'mysite.settings'

	Проект Django не обязан определять какие-либо настройки, если в этом нет необходимости.

		Каждая настройка содержит значение по умолчанию.

		Эти значния можно найти в модуле django/conf/global_settings.py

		Можно сделать так, чтобы настройки загружались по умолчанию не из модуля django/conf/global_settings.py

	Импорт настроек

		Правильно импортировать так:

			from django.conf import settings

	Вам не следует менять настройки в процессе работы приложения.

	Безопасность

		Файл настроек содержит конфиденциальную информацию, например, как пароль к базе данных, вы должны хранить его в безопасности. 

		Например, поменяйте права доступа к файлу, чтобы только вы и пользователь веб-сервера имел к нему доступ. 

		Это особенно важно для хостингов с общим окружением.

	Добавление собственных настроек

		Названия настроек должны быть в верхнем регистре.

		Не изобретайте заново существующие настройки.

Основные настройки

	Можно посмотреть здесь:

		https://djbook.ru/rel1.9/ref/settings.html#core-settings-topical-index

		https://docs.djangoproject.com/en/2.2/ref/settings/#core-settings-topical-index

	BASE_DIR

		Здесь путь корневой директории с проектом. 

	SECRET_KEY 

		Исользуется для различных механизмов защиты django приложений.

		Используется для криптографической подписи, если не указан другой ключ.

		Используется для всех сессий, кроме django.contrib.sessions.backends.cache.

		Без него проект не запуститься.

		Генерится автоматов при создании проекта.

		Не используется для хранения пароля пользователей и при смене они не будут сломаны.

	DEBUG

		Включает/выключает режим отладки.

		Не использовать True на боевом сервере.

		При DEBUG равном False, необходимо правильно указать ALLOWED_HOSTS, а иначе все запросы будут возвращать Bad Request (400).

	ALLOWED_HOSTS

		Список хостов/доменов, для которых может работать текущий сайт.

		Это сделано для безопасности, чтобы обезопасить от внедрения в куки или письма для сброса пароля ссылок на сторонний сайт подменив HTTP заголовок Host.

		Проверка обычно нужна только на боевом сервере.

	INSTALLED_APPS

		Здесь список всех приложений Django, используемых в проекте.

		Названия приложения должны быть уникальны.

		Если несколько приложений содержат разные версии одних и тех же ресурсов (шаблоны, статические файлы, команды, файлы перевода), будут использоваться ресурсы из приложения, которое указано выше.

	MIDDLEWARE

		Здесь список всех промежуточных слоев проекта.

	ROOT_URLCONF

		Путь для импорта главной конфигурации URL-ов.

	WSGI_APPLICATION

		Полный путь к объекту WSGI приложения, которое будет использовать встроенный сервер Django.

		Команда django-admin startproject создаст простой wsgi.py файл с функцией application, и установит значение этой настройки на этот объект application.

	DATABASES

		Здесь настройки подключения к бд.

	    'default': {
	        'ENGINE': 'django.db.backends.postgresql',
	        'NAME': 'magic',
	        'USER': 'root',
	        'PASSWORD': 'asdf1234',
	        'HOST': '127.0.0.1',
	        'PORT': '5432',
	    },

	AUTH_PASSWORD_VALIDATORS

		Здесь список валидаторов, которые проверяют надежность пароля пользователя.

	LANGUAGE_CODE

		Здесь установка языка, который используется в проекте.

	TIME_ZONE

		Засовой пояс, который будет использоваться в проекте.

	USE_I18N

		Указывает, используется ли механизм перевода Django.

		Если выключен, то повышает производительность.

	USE_L10N

		Указывает, использовать ли локализованный формат даты.

	USE_TZ

		При True, Django будет использовать объекты даты и времени с указанным часовым поясом. 

		Иначе Django будет использовать объекты даты и времени без учета часового пояса.

	CACHES

		Настройки механизма кэширования.

	DATABASE_ROUTERS

		Здесь список маршрутизаторов, которые будут использоваться для определения какую базу данных использовать при выполнении запроса.

	ADMINS

		Здесь список людей, которые будут получать уведомления об ошибках.

	EMAIL_BACKEND

		Бэкенд, используемый для отправки электронных писем.

	STATIC_ROOT

		Здесь путь к каталогу, из которого будут раздаваться статические файлы.

		Выполнив команду python manage.py collectstatic, все статические файлы проекта будут скопированы в указанную директорию.

		STATIC_ROOT и MEDIA_ROOT должны отличаться.

	STATIC_URL

		URL, указывающий на каталог со статическими файлами.

		Если не пустой, то должен оканчиваться косой чертой.

		Например '/static/'

			Будет работать, как http://exmaple.com/static/

	STATICFILES_DIRS

		Здесь общие статические файлы, которые не относятся ни к одному из приложений.

	MEDIA_ROOT

		Абсолютный путь к каталогу, в котором хранятся медиа-файлы.

		MEDIA_ROOT и STATIC_ROOT должны отличаться.

	MEDIA_URL

		URL который указывает на каталог MEDIA_ROOT.

		Например '/media/'

			Будет работать, как http://exmaple.com/media/

		Если вы хотите использовать {{ MEDIA_URL }} в шаблонах, добавьте 'django.template.context_processors.media' в опцию 'context_processors' настройки TEMPLATES.

	LOGGING

		Здесь настройки логгирования.

	APPEND_SLASH

		Настройка APPEND_SLASH используется только вместе с CommonMiddleware.

		Если урл не найден и в конце нет слэша, то будет добавлен и сделано перенаправление.

		Заметим что такое перенаправление может привести к потере всех данных при POST запросе.

	LOGIN_REDIRECT_URL

		URL куда перенаправляется пользователь поле авторизации пользователя в представлении (если не передан параметр next).

	LOGIN_URL

		URL, на который перенаправляются пользователи для авторизации.

	LOGOUT_URL

		URL, на который перенаправляются пользователи после выхода.

	PASSWORD_RESET_TIMEOUT_DAYS

		Количество дней, в течении которых действует ссылка для сброса пароля.

	SESSION_COOKIE_AGE

		По умолчанию: 1209600 (2 недели в секундах)

		Время хранения сесионной куки в секундах.

	SITE_ID

		id сайта в таблице django_site базы данных.

		Используется для привязки данных к конкретному сайту, что позволяет использовать один установленный проект для нескольких сайтов.

django-admin и manage.py

	Это консольные инструменты.

	Во всех примерах в этом разделе используется django-admin, но вы можете использовать manage.py

	django-admin help

		help --commands

		help <command>

	django-admin startproject

	django-admin version - выводит текущую версию django

	django-admin startapp name_app (принято именовать во множественном числе)

	django-admin makemigrations

		--empty - создает пустую миграцию для последующего редактирования вручную

		--merge - решает конфликты с миграциями

		--name - задает имя миграции

	django-admin migrate

		<app_label>

		<app_label> <migrationname>

		--database

		--fake - помечает миграции, как невыполненные (может “сломать” автоматическое применение миграций)

		--fake-initial - помечает миграции, как выполненные

	django-admin showmigrations

	django-admin check - анализирует проект Django на наличие распространенных проблем

		check auth admin othre_app - анализирует только заданные приложения

		check --tag security - проверяет приложения только на безопастность

			--list-tags

		djanog-admin check --deploy - проверяет настройки для продакшена

			djanog-admin check --deploy --settings=production_settings

	django-admin diffsettings - показывает разницу между текущими настройками и настройками Django по умолчанию

		--all - выводит все настройки, даже если они не отличаются от настроек по умолчанию

	django-admin changepassword user_name (работает только, если установлена система авторизации)

	django-admin createsuperuser (работает только, если установлена система авторизации)

	django-admin runserver

		0.0.0.0:8000

	django-admin dbshell

		--database

	django-admin shell - запускает интерактивный интерпретатор Python

	django-admin loaddata mydata.json - ищет и загружает указанные фикстуры в базу данных

	django-admin inspectdb - выводит сгенерированные модели Django основе таблиц из бд (может пригодиться, когда есть бд, но нет моделей)

		Если inspectdb не может подобрать подходящий тип поля модели, будет использоваться поле TextField с комментарием в коде 'This field type is a guess.' возле этого поля.

		Если название колонки в таблице входит в зарезервированные слова Python (такие как 'pass', 'class' или 'for'), inspectdb добавит '_field' к названию атрибута.

	django-admin sendtestemail foo@example.com bar@example.com - отправляет тестовое электронное письмо

		--managers

		--admins

	django-admin clearsessions - удаляет устаревшие данные сессий

	django-admin collectstatic - собирает статические файлы приложений в одно место (директория collectstatic)

	Можно посмотреть здесь:

		https://djbook.ru/rel1.9/ref/django-admin.html?highlight=django-admin

		https://docs.djangoproject.com/en/2.2/ref/django-admin/

ORM и работа с базой данных

    ORM (object relational mapping) - технология программирования, которая обеспечивает работу с базой данных без необходимости писать чистые sql запросы. 

    	В orm класс описывает таблицу в бд.

    	Созданный на основе класса объект представляет собой одну запись в таблице.

    	На основе класса создаётся объект и кладём в бд.

	    Плюсы: скорость разработки

	    Минусы: скорость работы

	Общее

		За работу с базой данных отвечает модель.

		Модели определяются в файле models.py каждого приложения.

		Обычно одна модель представляет одну таблицу в бд.

		В сообществе принято называть таблицы и модели в единственном числе. Например Product.

		После выполнения миграций на основе моделей в базе данных создаются таблица в формате appname_modelname (cards_product).

			Название таблицы можно переопределить с помощью параметра db_table, который нужно добавить в класс Meta, который находится внутри класса модели.

				Настоятельно рекомендуем использовать нижний регистр при переопределении названия таблицы через db_table, особенно при использовании MySQL.

		После определения моделей необходимо указать Django что необходимо их использовать. Это можно сделать, добавив в INSTALLED_APPS имя приложения.

		Нельзя использовать имена конфликтующие с API моделей, такие как clean, save или delete.

		Cамые используемые настройки полей:

			null 

				Если True, Django сохранит пустое значение как NULL в базе данных. По умолчанию - False.

			blank

				Если поле содержит blank=True, форма позволит передать пустое значение. При blank=False - поле обязательно.

			choices

				При определении, виджет формы использует select вместо стандартного текстового поля и ограничит значение поля указанными значениями.

			    SHIRT_SIZES = (
			        ('S', 'Small'),
			        ('M', 'Medium'),
			        ('L', 'Large'),
			    )
			    shirt_size = models.CharField(max_length=1, choices=SHIRT_SIZES)

			default

				Значение по умолчанию для этого поля.

			primary_key

				При True поле будет первичным ключом.

				При этом Django не добавит поле id по умолчанию.

			unique

				При True поле будет уникальным.

		По умолчанию Django для каждой модели добавляет такое поле: 

			id = models.AutoField(primary_key=True)

			Это автоинкрементный первичный ключ.

		Каждое поле, кроме ForeignKey, ManyToManyField и OneToOneField, первым аргументом принимает необязательное читабельное название.

			first_name = models.CharField('User name')

		ForeignKey, ManyToManyField и OneToOneField первым аргументом принимает класс модели, поэтому для читабельного названия используется аргумент verbose_name.

			sites = models.ForeignKey(Site, verbose_name='list of sites')

		Желательно, чтобы название поля ForeignKey связанной было названием модели в нижнем регистре.

		Для поля ForeignKey можно задать имя для обратной связи.

			class Dealer(models.Model):
				name = models.CharField(max_length=255)

			class Car(models.Model):
				dealer = models.ForeignKey(Dealer, related_name='super_cars')

			Dealer.objects.first().super_cars.all()

		Название поля не может быть слово зарезервированное Python, т.к. это приведет к синтаксической ошибке.

		Зарезервированные SQL слова, такие как join, where или select, можно использовать как название поля

		Название поля не может содержать несколько нижних подчеркиваний подряд, т.к. такой подход Django использует для формирования запросов.

		Можно создавать собственные типы полей.

		Дополнительные настройки для модели можно определить через class Meta.

			class Ox(models.Model):
			    horn_length = models.IntegerField()

			    class Meta:
			        ordering = ['horn_length']
			        verbose_name_plural = 'oxen'

	Один к одному

		class People(models.Model):
			name = models.CharField(max_length=255)

		class Pasport(models.Model):
			people = models.OneToOneField(People, on_delete=models.CASCADE)
			code = models.IntegerField()

		На основе этих моделей создадутся 2 таблицы в бд - appname_people, appname_pasport.

		В таблице appname_pasport будет связь один к одному - people_id.

	Один ко многим

		class Dealer(models.Model):
			name = models.CharField(max_length=255)

		class Car(models.Model):
			dealer = models.ForeignKey(Dealer, on_delete=models.CASCADE)

	Связь на модель, которая еще не определена

		class Car(models.Model):
			dealer = models.ForeignKey('Dealer', on_delete=models.CASCADE)

		class Dealer(models.Model):
			name = models.CharField(max_length=255)

		Для связи на модель из другого приложения используйте название модели и приложения.

			class Car(models.Model):
				dealer = models.ForeignKey('app_name.Dealer', on_delete=models.CASCADE)

	Многие ко многим

		class Topping(models.Model):
		    pass

		class Pizza(models.Model):
		    toppings = models.ManyToManyField(Topping)

		Желательно, чтобы название поля ManyToManyField было множественным называнием связанных объектов.

		Не имеет значения какая модель содержит поле ManyToManyField, но его может содержать только одна из моделей.

		Обычно, ManyToManyField необходимо добавить в модель, которая будет редактироваться в форме. 

			И потому что обычно думают о пицце с ингредиентами, а не об ингредиентах в различных пиццах.

		В итоге на основе данной модели в бд создастся таблица appname_pizza_toppings.

		Иногда необходимо хранить дополнительную информацию о связи.

			Например музыкальные группы, музыканты и когда музыкант вступил в группу.

			Для таких случаев Django позволяет определить модель для хранения связи многие ко многим и дополнительной информации.

				class Person(models.Model):
				    name = models.CharField(max_length=128)

				class Group(models.Model):
				    name = models.CharField(max_length=128)
				    members = models.ManyToManyField(Person, through='Membership')

				class Membership(models.Model):
				    person = models.ForeignKey(Person, on_delete=models.CASCADE)
				    group = models.ForeignKey(Group, on_delete=models.CASCADE)
				    date_joined = models.DateField()
				    invite_reason = models.CharField(max_length=64)

				На основе этих моделей создадутся таблицы appname_person, appname_group, appname_membership (здесь и будет находиться связи - person_id, group_id)

				По сути эта такая же связь многие ко многим только с дополнительными полями в таблице, где хранится связь.

	Наследование

		Базовый класс должен наследоваться от models.Model.

		Нужно определить, это должна ли родительская модель быть независимой моделью (с собственной таблицей в базе данных), или же родительская модель просто контейнер для хранения информации, доступной только через дочерние модели.

		Абстрактные модели

			Удобны при определении общих, для нескольких моделей, полей.

			Для этой модели не будет создана таблица в базе данных.

			Поля в абстрактной модели будут в той модели, которая наследуется от неё.

			Нельзя использовать поля с одинаковыми названиями в дочерней и родительской моделях.

			Абстрактная модель не имеет менеджера.

			Если дочерний класс не определяет собственный класс Meta, он унаследует родительский класс Meta.

			Можно расширить родительский класс Meta.

			class CommonInfo(models.Model):
			    name = models.CharField(max_length=100)
			    age = models.PositiveIntegerField()

			    class Meta:
			        abstract = True

			class Student(CommonInfo):
			    home_group = models.CharField(max_length=5)

			    class Meta(CommonInfo.Meta):
			        db_table = 'student_info'

			Используя атрибут related_name для ForeignKey или ManyToManyField, вы должны всегда определять уникальное название для обратной связи.

				Потому что поля абстрактной модели будут добавлены в каждой из дочерних моделей, с теми же значениями аргументов.

				Не указав related_name для абстрактной модели, для обратной связи будет использовано название дочерней модели плюс '_set'.

		Multi-table

			Каждая модель имеет собственную таблицу в базе данных и может быть использована независимо.

			Наследование использует связь между родительской и дочерней моделью через автоматически созданное поле OneToOneField.

			Все поля родительской модели будут доступны в дочерней при том, что значения будут храниться в разных таблицах.

			class Place(models.Model):
			    name = models.CharField(max_length=50)
			    address = models.CharField(max_length=80)

			class Restaurant(Place):
			    serves_hot_dogs = models.BooleanField(default=False)
			    serves_pizza = models.BooleanField(default=False)

	Атрибуты модели

		Самый важный это objects, который является менеджером модели.

		Менеджер это интерфейс, через который Django выполняет запросы к базе данных и получает объекты.

		Менеджеры доступны только через класс модели, они не доступны в экземплярах (объектах) модели.

	Методы модели

		__str__ - возращает строковое представление объекта

		__eq__ - ?

		__hash__ - возращает хэш объекта

		get_absolute_url - возвращает строку-url для объекта (используется в интерфейсе администратора для "Показать на сайте")

			<a href="{{ object.get_absolute_url }}">{{ object.name }}</a>

		get_FOO_display - возвращает значение поля из choices, который определен в модели. FOO нужно заменить на имя choices

			class Person(models.Model):
			    SHIRT_SIZES = (
			        ('S', 'Small'),
			        ('M', 'Medium'),
			        ('L', 'Large'),
			    )

			p = Person(name="Fred")
			p.get_shirt_size_display()

		get_next_by_FOO - возвращает следующее значение поля из choices от текущего

		get_previous_by_FOO - возвращает предыдущее значение поля из choices от текущего

	Переопределение методов модели

		Чаще всего вы захотите переопределить метод save() и delete().

		Переопределенные методы модели не вызываются при множественных операциях с bulk.

		Учтите, метод delete() не обязательно вызывается при массовом удалении объектов через QuerySet или как результат каскадного удаления.

		class Blog(models.Model):
		    name = models.CharField(max_length=100)

		    def save(self, *args, **kwargs):
		        # action before

		        super().save(*args, **kwargs)

		        # action after

	Свои методы модели

		Для добавления функционала работы с экземпляром модели, необходимо добавить метод в модель.

		Методы модели работают с конкретной записью в таблице.

		class Person(models.Model):
		    def get_full_name(self):
		    	return '{name] {surname}'.format(name=self.name, surname=self.surname)

	Все параметры мета можно посмотреть здесь:

		https://djbook.ru/rel1.9/ref/models/options.html

		https://docs.djangoproject.com/en/2.2/ref/models/options/

	Типы полей можно посмотреть здесь:

		https://djbook.ru/rel1.9/ref/models/fields.html#model-field-types

		https://docs.djangoproject.com/en/2.2/ref/models/fields/#field-types

Как Django обрабатывает запрос

	Определяет какой файл конфигурации урлов считывать.

		Обычно, это значение настройки ROOT_URLCONF.

	Ищет переменную urlpatterns внутри файла с урлами.

	Перебирает каждый URL-шаблон по порядку, и останавливается при первом совпадении.

	Вызывает соответствующее представление.

		При вызове передается объект HttpRequest (параметры запроса), позиционные аргументы (если они есть), именованные аргументы (если они есть)

	Если нет совпадений или на одном из этапов возникла ошибка, то вызывается соответствующий обработчик ошибок.

Как Django хранит пароли

	По умолчанию использует хэширующий алгоритм PBKDF2 (стандарт формирования ключа на основе пароля).

	<algorithm>$<algorithm_count_iterations>$<salt>$<password_hash>

		Это хэширующий алгоритм, количество применений (итераций) алгоритма, случайная соль и полученный хэш пароля.

	Можно выбрать другой хэширующий алгоритм, указав его в PASSWORD_HASHERS.

		Первая запись этого списка будет использоваться для сохранения паролей

		Все остальные записи являются проверенными средствами, которые могут быть применены для проверки существующих паролей.

	Bcrypt является популярным алгоритмом для хранения паролей.

		Данный алгоритм не выбран в качестве стандартного в Django.

		Как установить смотреть здесь:

			https://docs.djangoproject.com/en/2.2/topics/auth/passwords/

				Using bcrypt with Django

	Алгоритмы PBKDF2 и bcrypt используют ряд итераций или округлений для хэшей. 

		Это значительно замедляют действия атакующих, усложняя выполнение атаки на хэшированные пароли. 

		Однако, по мере увеличения вычислительной мощности, количество этих итераций следует увеличивать. 

			С каждой новой версией Django разработчики будут делать это самостоятельно, но также это можно сделать вручную.

			Для самостоятельного увеличения кол-во итерация смотреть:

				https://docs.djangoproject.com/en/2.2/topics/auth/passwords/

					Increasing the work factor

	Управление паролями из кода

		check_password(password, encoded)

		make_password(password, salt=None, hasher='default')

		is_password_usable(encoded_password) - проверяет, является ли переданная строка хэшированным паролем, который имеет шанс пройти проверку с помощью функции check_password()

		validate_password(password, user=None, password_validators=None)

		password_changed(password, user=None, password_validators=None)








	
	



	