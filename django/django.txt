Оглавление

	1. Общее

		1.1. Философия дизайна

		1.2. Как Django обрабатывает запрос

		1.3. Как Django хранит пароли

	Настройки

		Основные настройки

		django-admin и manage.py

	Структура проекта

		Структура проекта из Two scoops of Django

	Приложения проекта

		Приложения проекта из Two scoops of Django

	Базы данных

		Настройка

		Транзакции 

		Несколько баз данных

		Табличные пространства

		Нюансы бд

	Миграции

		Основы работы

		Тестирование работы в бою

	ORM

		Связи

		Наследование

		Атрибуты

		Методы

		Менеджеры

		Queryset-ы

	QuerySet

		Когда вычисляется QuerySet

		Кэширование и QuerySet

	Выполнение запросов

		Создание

		Копирование

		Обновление

		Выборка

		Фильтрация

		F()

		Q()

		Агрегация

		Удаление

		Использование чистого SQL

		Оптимизация

	Представления

		HTTP ответы

		Представления классы

		Встроенные (generic) представления классы

		Обработка форм в представлениях классах

		Миксины

		Декорирование представлений классов

	Шаблоны

		Структура by "two scoops of django"

		Контекст

	Формы

		Наборы форм - 

		Модельные формы -

	Управление файлами

	Url-ы

	Статика

	Валидаторы

	Безопасность

		Защита от межсайтового скриптинга (XSS)

		Защита от подделки межсайтового запроса (CSRF)

		Защита от внедрения SQL

		Защита от скликивания

		SSL/HTTPS

		Проверка заголовка хоста

		Безопасность сессии

		Контент, загружаемый пользователями

	Интерфейс администратора

		Нюансы интерфейс администратора

	Shell

	Debug toolbar

	Unit тесты

		Нюансы

		Команды

	Логгирование

	Вливание новых данных на проект

	Перезапуск проекта

	Книги

	Нюансы

	Создание и настройка проекта

	Развёртывание (docker + nginx + gunicorn + django)

1. Общее

	1.1. Философия дизайна

		Фундаментальная основа стека Django - это слабая связанность.

			Отдельным слоям фреймворка не следует знаь друг о друге, если в этом нет острой необходимости.

			Например, система шаблонов ничего не знает о Web запросах, а базу данных не интересует, как эти данные представлены.

			Django поставляется с пакетом приложений, который представляет из себя кусочки, для удобства независимые настолько, насколько это возможно.

		Меньше кода

			Приложения Django должны использовать настолько мало кода, насколько возможно, следует избегать шаблонных кусков.

		Не повторяйтесь (DRY)

			Каждая отдельная концепция и/или кусок данных следует хранить в одном и лишь одном месте. Избыточность - плохо. Нормализация - хорошо.

		Явное лучше чем неявное

			Это значит, что Django не должен творить слишком много магии.

		Эффективность SQL

			SQL запросы должны выполняться как можно реже, и должны быть оптимизированы.

		Всё должно быть на своих местах

			Например вся информация, описывающая модель и логику ее работы  определена в классе модели.

	1.2. Как Django обрабатывает запрос

		Определяет какой файл конфигурации урлов считывать.

			Обычно, это значение настройки ROOT_URLCONF.

		Ищет переменную urlpatterns внутри файла с урлами.

		Перебирает каждый URL-шаблон по порядку, и останавливается при первом совпадении.

		Вызывает соответствующее представление.

			При вызове передается объект HttpRequest (параметры запроса), позиционные аргументы (если они есть), именованные аргументы (если они есть)

		Если нет совпадений или на одном из этапов возникла ошибка, то вызывается соответствующий обработчик ошибок.

	1.3. Как Django хранит пароли

		По умолчанию использует хэширующий алгоритм PBKDF2 (стандарт формирования ключа на основе пароля).

		<algorithm>$<algorithm_count_iterations>$<salt>$<password_hash>

			Это хэширующий алгоритм, количество применений (итераций) алгоритма, случайная соль и полученный хэш пароля.

		Можно выбрать другой хэширующий алгоритм, указав его в PASSWORD_HASHERS.

			Первая запись этого списка будет использоваться для сохранения паролей

			Все остальные записи являются проверенными средствами, которые могут быть применены для проверки существующих паролей.

		Bcrypt является популярным алгоритмом для хранения паролей.

			Данный алгоритм не выбран в качестве стандартного в Django.

			Как установить смотреть здесь:

				https://docs.djangoproject.com/en/2.2/topics/auth/passwords/

					Using bcrypt with Django

		Алгоритмы PBKDF2 и bcrypt используют ряд итераций или округлений для хэшей. 

			Это значительно замедляют действия атакующих, усложняя выполнение атаки на хэшированные пароли. 

			Однако, по мере увеличения вычислительной мощности, количество этих итераций следует увеличивать. 

				С каждой новой версией Django разработчики будут делать это самостоятельно, но также это можно сделать вручную.

				Для самостоятельного увеличения кол-во итерация смотреть:

					https://docs.djangoproject.com/en/2.2/topics/auth/passwords/

						Increasing the work factor

		Управление паролями из кода

			check_password(password, encoded)

			make_password(password, salt=None, hasher='default')

			is_password_usable(encoded_password) - проверяет, является ли переданная строка хэшированным паролем, который имеет шанс пройти проверку с помощью функции check_password()

			validate_password(password, user=None, password_validators=None)

			password_changed(password, user=None, password_validators=None)

Настройки

	Файл настроек содержит полную конфигурацию установленного проекта и называется settings.py

	Файл настроек - это просто модуль python с переменными модуля.

	Можно динамически определять настройки, используя обычный синтаксис python.

		settings.MY_SETTING.append['new_param']

	Можно импортировать значения из других файлов настроек.

		from settings_local import *

	Можно перед запуском явно указать какие настройки должны использоваться.

		export DJANGO_SETTINGS_MODULE=mysite.settings
		django-admin runserver

		----

		django-admin runserver --settings=mysite.settings

	Для настройки на сервере (Apache и mod_wsgi) нужно указать WSGI-приложению какой файл с настройками использовать.

		import os
		os.environ['DJANGO_SETTINGS_MODULE'] = 'mysite.settings'

	Проект Django не обязан определять какие-либо настройки, если в этом нет необходимости.

		Каждая настройка содержит значение по умолчанию.

		Эти значния можно найти в модуле django/conf/global_settings.py

		Можно сделать так, чтобы настройки загружались по умолчанию не из модуля django/conf/global_settings.py

	Импорт настроек

		Правильно импортировать так, потому что так django сам находит файл конфигурации и не возникнет проблем если поменялась структура:

			from django.conf import settings

	Вам не следует менять настройки в процессе работы приложения.

	Безопасность

		Файл настроек содержит конфиденциальную информацию, например, как пароль к базе данных, вы должны хранить его в безопасности. 

		Например, поменяйте права доступа к файлу, чтобы только вы и пользователь веб-сервера имел к нему доступ. 

		Это особенно важно для хостингов с общим окружением.

	Добавление собственных настроек

		Названия настроек должны быть в верхнем регистре.

		Не изобретайте заново существующие настройки.

	Основные настройки

		Можно посмотреть здесь:

			https://djbook.ru/rel1.9/ref/settings.html#core-settings-topical-index

			https://docs.djangoproject.com/en/2.2/ref/settings/#core-settings-topical-index

		BASE_DIR

			Здесь путь корневой директории с проектом. 

		SECRET_KEY 

			Исользуется для различных механизмов защиты django приложений.

			Используется для криптографической подписи, если не указан другой ключ.

			Используется для всех сессий, кроме django.contrib.sessions.backends.cache.

			Без него проект не запуститься.

			Генерится автоматов при создании проекта.

			Не используется для хранения пароля пользователей и при смене они не будут сломаны.

		DEBUG

			Включает/выключает режим отладки.

			Не использовать True на боевом сервере.

			При DEBUG равном False, необходимо правильно указать ALLOWED_HOSTS, а иначе все запросы будут возвращать Bad Request (400).

		ALLOWED_HOSTS

			Список хостов/доменов, для которых может работать текущий сайт.

			Это сделано для безопасности, чтобы обезопасить от внедрения в куки или письма для сброса пароля ссылок на сторонний сайт подменив HTTP заголовок Host.

			Проверка обычно нужна только на боевом сервере.

		INSTALLED_APPS

			Здесь список всех приложений Django, используемых в проекте.

			Названия приложения должны быть уникальны.

			Если несколько приложений содержат разные версии одних и тех же ресурсов (шаблоны, статические файлы, команды, файлы перевода), будут использоваться ресурсы из приложения, которое указано выше.

		MIDDLEWARE

			Здесь список всех промежуточных слоев проекта.

		ROOT_URLCONF

			Путь для импорта главной конфигурации URL-ов.

		WSGI_APPLICATION

			Полный путь к объекту WSGI приложения, которое будет использовать встроенный сервер Django.

			Команда django-admin startproject создаст простой wsgi.py файл с функцией application, и установит значение этой настройки на этот объект application.

		DATABASES

			Здесь настройки подключения к бд.

		    'default': {
		        'ENGINE': 'django.db.backends.postgresql',
		        'NAME': 'magic',
		        'USER': 'root',
		        'PASSWORD': 'asdf1234',
		        'HOST': '127.0.0.1',
		        'PORT': '5432',
		    },

		AUTH_PASSWORD_VALIDATORS

			Здесь список валидаторов, которые проверяют надежность пароля пользователя.

		LANGUAGE_CODE

			Здесь установка языка, который используется в проекте.

		TIME_ZONE

			Засовой пояс, который будет использоваться в проекте.

		USE_I18N

			Указывает, используется ли механизм перевода Django.

			Если выключен, то повышает производительность.

		USE_L10N

			Указывает, использовать ли локализованный формат даты.

		USE_TZ

			При True, Django будет использовать объекты даты и времени с указанным часовым поясом. 

			Иначе Django будет использовать объекты даты и времени без учета часового пояса.

		CACHES

			Настройки механизма кэширования.

		DATABASE_ROUTERS

			Здесь список маршрутизаторов, которые будут использоваться для определения какую базу данных использовать при выполнении запроса.

		ADMINS

			Здесь список людей, которые будут получать уведомления об ошибках.

		EMAIL_BACKEND

			Бэкенд, используемый для отправки электронных писем.

		STATIC_ROOT

			Здесь путь к каталогу, из которого будут раздаваться статические файлы.

			Выполнив команду python manage.py collectstatic, все статические файлы проекта будут скопированы в указанную директорию.

			STATIC_ROOT и MEDIA_ROOT должны отличаться.

		STATIC_URL

			URL, указывающий на каталог со статическими файлами.

			Если не пустой, то должен оканчиваться косой чертой.

			Например '/static/'

				Будет работать, как http://exmaple.com/static/

		STATICFILES_DIRS

			Здесь общие статические файлы, которые не относятся ни к одному из приложений.

		MEDIA_ROOT

			Абсолютный путь к каталогу, в котором хранятся медиа-файлы.

			MEDIA_ROOT и STATIC_ROOT должны отличаться.

		MEDIA_URL

			URL который указывает на каталог MEDIA_ROOT.

			Например '/media/'

				Будет работать, как http://exmaple.com/media/

			Если вы хотите использовать {{ MEDIA_URL }} в шаблонах, добавьте 'django.template.context_processors.media' в опцию 'context_processors' настройки TEMPLATES.

		LOGGING

			Здесь настройки логгирования.

		APPEND_SLASH

			Настройка APPEND_SLASH используется только вместе с CommonMiddleware.

			Если урл не найден и в конце нет слэша, то будет добавлен и сделано перенаправление.

			Заметим что такое перенаправление может привести к потере всех данных при POST запросе.

		LOGIN_REDIRECT_URL

			URL куда перенаправляется пользователь поле авторизации пользователя в представлении (если не передан параметр next).

		LOGIN_URL

			URL, на который перенаправляются пользователи для авторизации.

		LOGOUT_URL

			URL, на который перенаправляются пользователи после выхода.

		PASSWORD_RESET_TIMEOUT_DAYS

			Количество дней, в течении которых действует ссылка для сброса пароля.

		SESSION_COOKIE_AGE

			По умолчанию: 1209600 (2 недели в секундах)

			Время хранения сесионной куки в секундах.

		SITE_ID

			id сайта в таблице django_site базы данных.

			Используется для привязки данных к конкретному сайту, что позволяет использовать один установленный проект для нескольких сайтов.

	django-admin и manage.py

		Это консольные инструменты.

		Во всех примерах в этом разделе используется django-admin, но вы можете использовать manage.py


		django-admin help

			help --commands

			help <command>


		django-admin startproject

		./manage.py version - выводит текущую версию django

		./manage.py startapp name_app (принято именовать во множественном числе)


		./manage.py makemigrations

			--empty - создает пустую миграцию для последующего редактирования вручную

			--merge - решает конфликты с миграциями

			--name - задает имя миграции

		./manage.py migrate

			<app_label>

			<app_label> <migrationname>

			--database

			--fake - помечает миграции, как невыполненные (может “сломать” автоматическое применение миграций)

			--fake-initial - помечает миграции, как выполненные

		./manage.py showmigrations

		./manage.py migrate my_app zero


		./manage.py check - анализирует проект Django на наличие распространенных проблем

			check auth admin othre_app - анализирует только заданные приложения

			check --tag security - проверяет приложения только на безопастность

				--list-tags

			djanog-admin check --deploy - проверяет настройки для продакшена

				djanog-admin check --deploy --settings=production_settings


		./manage.py diffsettings - показывает разницу между текущими настройками и настройками Django по умолчанию

			--all - выводит все настройки, даже если они не отличаются от настроек по умолчанию


		./manage.py changepassword user_name (работает только, если установлена система авторизации)

		./manage.py createsuperuser (работает только, если установлена система авторизации)


		./manage.py runserver

			0.0.0.0:8000


		./manage.py dbshell

			--database

		./manage.py shell - запускает интерактивный интерпретатор Python


		./manage.py loaddata mydata.json - ищет и загружает указанные фикстуры в базу данных


		./manage.py inspectdb - выводит сгенерированные модели Django основе таблиц из бд (может пригодиться, когда есть бд, но нет моделей)

			Если inspectdb не может подобрать подходящий тип поля модели, будет использоваться поле TextField с комментарием в коде 'This field type is a guess.' возле этого поля.

			Если название колонки в таблице входит в зарезервированные слова Python (такие как 'pass', 'class' или 'for'), inspectdb добавит '_field' к названию атрибута.


		./manage.py sendtestemail foo@example.com bar@example.com - отправляет тестовое электронное письмо

			--managers

			--admins


		./manage.py clearsessions - удаляет устаревшие данные сессий


		./manage.py collectstatic - собирает статические файлы приложений в одно место (директория collectstatic)


		Можно посмотреть здесь:

			https://djbook.ru/rel1.9/ref/django-admin.html?highlight=django-admin

			https://docs.djangoproject.com/en/2.2/ref/django-admin/

Структура проекта
	
	Структура проекта из Two scoops of Django

		<repository_root>/
			<configuration_root>/
			<django_project_root>/

		repository_root - корневая директория проекта с README.rst, manage.py, .gitignore, requirements.txt и т.д.

		configuration_root - здесь settings, базовый urls.py

		django_project_root - тут проект

		icecreamratings
		├── config/
		│   ├── settings/
		|	|  		__init__.py
		|   |		local.py
		|	|		...
		│   ├── __init__.py
		│   ├── urls.py
		│   └── wsgi.py
		├── docs/
		├── icecreamratings/
		│   ├── media/ # Development only!
		│   ├── products/
		│   ├── profiles/
		│   ├── ratings/
		│   ├── static/
		│   └── templates/
		├── .gitignore
		├── Makefile
		├── README.rst
		├── manage.py
		└── requirements.txt
		└── package.json

		Для корректной работы меняем:

			local.py

				ROOT_URLCONF = 'config.urls'

				WSGI_APPLICATION = 'config.wsgi.application'

		Запуск и встроенные команды

			Теперь к каждой команде добавляем файл с настоойками.

				./manage.py runserver --settings=config.settings.local

		Bootstrap и другие js/css либы

			Ставим через npm и package.json

			В итоге в корне проекта появляется директория node_modules

			При деплое руками переносим нужные файлы в директорию static, потому что команда ./manage collectstatic расчитана только на приложения django, а bootstrapp, jquery и т.д. относятся ко всему проекту, а не к конкретному приложению.

		Установка через npm

			В корне проекта создаем package.json

				У него четкой правил по структуре, поэтому можно не добавлять много.

				{
				  "name": "project_name",
				  "version": "1.0.0",
				  "private": true,
				  "dependencies": {
				    "bootstrap": "",
				    "jquery": "",
				    "popper.js": ""
				  }
				}

			В терминале выполняем команду npm i

			Для просмотра установленных пакетов в терминале выполняем npm ls

		Подключение общей статики в шаблонах

			Добавляет путь к общей статике в STATICFILES_DIRS

				STATICFILES_DIRS = [
				    os.path.join(PROJECT_ROOT, 'node_modules')
				]

Приложения проекта

	Приложения проекта из Two scoops of Django

		Приложения должны делать только одну вещь и делать её хорошо.

		Приложения могут быть взаимосвязанны между собой.

		Название приложений могут быть, как в единственном, так и во множественном числе. Это завист от того, что делает приложение, например blog и shop будут в единственном числе, потому что на сайте один блог и один магазин, а например events и tickets будут во множественном, потому что отвечают за работу со множеством событий и билетов.

Базы данных

	Транзакции

		По умолчанию Django использует режим автоматической фиксации ('autocommit'). 

			Каждый запрос сразу фиксируется в базе данных, если не используется транзакция.

			То есть транзакция для каждого запроса не только создается, но и автоматически фиксируется, если запросы был успешно выполнен.

		Вы можете отключить управление транзакциями Django для определенной базы данных, установив AUTOCOMMIT в False в её настройках.

		Django не позволит выключить autocommit, если активен блок atomic(), т.к. это нарушит атомарность.

		Перед включением autocommit вы должны убедиться, что транзакция не активна, обычно выполнив commit() или rollback().

		Чтобы обернуть каждое представление в транзакцию нужно установить ATOMIC_REQUESTS в True.

			Декоратор @transaction.non_atomic_requests отключает это поведение для конкретного представления.

				@transaction.non_atomic_requests
				def my_view(request):
				    do_stuff()

		Промежуточные слои(middleware) выполняются вне транзакции, аналогично выполняется и рендеринг ответа.

		Создание транзакции требует определенных операций от базы данных. Чтобы минимизировать нагрузку на сервер базы данных, делайте транзакции минимально короткими.

		Явное управление транзакциями

			Можно использовать декоратор @transaction.atomic

				@transaction.atomic
				def viewfunc(request):
				    do_stuff()

			Можно использовать внутри кода вместе с менеджером контекста.

				def viewfunc(request):
				    with transaction.atomic():
				        do_more_stuff()

			Обернув atomic в блок try/except, можно выполнить обработку ошибок.

				Избегайте перехвата ошибок внутри atomic, потому что если перехватить исключение и обработать его в блоке atomic, можно скрыть от Django наличие проблемы.

				Правильный способ обработать ошибки базы данных - перехватить их за блоком atomic.

			    try:
			        with transaction.atomic():
			            generate_relationships()
			    except IntegrityError:
			        pass

			Чтобы создать транзакцию, отключите autocommit с помощью set_autocommit().

				set_autocommit(autocommit=True/False, using=None/db_name)

				Если этот аргумент using не указан, то все действия идут относительно стандартной (default) базы данных.

				Оказавшись в транзакции, можно зафиксировать выполненные изменения, используя функцию commit(), или отменить их через функцию rollback().

					a.save()
					try:
					    b.save()
					except IntegrityError:
					    transaction.rollback()

					В этом примере изменения, сделанные с помощью a.save() будут потеряны, несмотря на то, что эта операция прошла без ошибок.

				Откат до точки сохранения

					a.save()

					sid = transaction.savepoint()
					try:
					    b.save()
					    transaction.savepoint_commit(sid)
					except IntegrityError:
					    transaction.savepoint_rollback(sid)

		Выполнение операции после коммита

			Django предоставляет функцию on_commit(), которая позволяет добавить обработчик, вызываемый после успешного коммита транзакции.

				def do_something():
	    			pass
				transaction.on_commit(do_something)


				transaction.on_commit(lambda: some_celery_task.delay('arg1'))

			Ваши обработчики вызываются после успешного коммита, и ошибка в обработчике не приведет к отмене транзакции, потому что они не являются частью транзакции.

		Точки сохранения

			Точкой сохранения называют маркер внутри транзакции, который позволяет вам отменить лишь часть транзакции, а не всю.

			Точки сохранения предоставляют возможность выполнять частичный откат, вместо выполнения полного отката, который делается с помощью transaction.rollback().

			Важно понимать, что точки сохранения делаются postgresql автоматически и позволяют например при отключении, а потом включении света продолжить транзакцию с последней точки сохранения.

			Помимо этого нужно понимать, что если произошёл какой то сбой и транзакция не завершилась, то никаких изменений в бд не будет, не смотря на то что были точки сохранения.

			Точки сохранения доступны при использовании бэкендов SQLite (≥ 3.6.8), PostgreSQL 8, Oracle и MySQL(при использовании InnoDB).

			При вложенных блоках atomic() создаются точки сохранения, которые позволяют выполнить частичную фиксацию или откат изменений. Мы настоятельно рекомендуем использовать atomic() вместо функций указанных ниже.

				Каждая из этих функция принимает аргумент using, который обозначает имя базы данных с которой производится работа (если не передать аргумент, то будет использована дефолтная база).

					savepoint(using=None)

					savepoint_commit(sid, using=None)

					savepoint_rollback(sid, using=None)

					clean_savepoints(using=None)

					@transaction.atomic
					def viewfunc(request):

					    a.save()

					    sid = transaction.savepoint()

					    b.save()

					    if want_to_keep_b:
					        transaction.savepoint_commit(sid)
					    else:
					        transaction.savepoint_rollback(sid)

						get_rollback(using=None)

						set_rollback(rollback, using=None)

	Несколько баз данных

		Первым шагом к использованию нескольких баз данных с Django будет определение серверов БД, которые вы планируете использовать.

			DATABASES = {
				# default - это псевдоним
			    'default': {
			        'NAME': 'app_data',
			        'ENGINE': 'django.db.backends.postgresql',
			        'USER': 'postgres_user',
			        'PASSWORD': 's3krit'
			    },
			    'users': {
			        'NAME': 'user_data',
			        'ENGINE': 'django.db.backends.mysql',
			        'USER': 'mysql_user',
			        'PASSWORD': 'priv4te'
			    }
			}

			Базам данных можно назначать любой псевдоним. 

				Псевдоним default имеет особое значение, потому что Django использует базу данных с псевдонимом default, если явно не указано использование другой базы данных.

			Команда migrate работает единовременно только с одной базой данных.

				Если добавить аргумент --database, можно указать команде, что надо работать с другой базой данных.

					./manage.py migrate --database=users

			Простейшим способом использования нескольких баз данных является настройка схемы роутинга.

				Настройка производится путем подключения всех роутеров в DATABASE_ROUTERS.

					DATABASE_ROUTERS = ['routers.Routers', 'sales_base_models.routers.Router']

						routers - это название файла routers.py

						Routers - это название класса с настройками в файле routers.py

						sales_base_models - это имя пакета в котором есть свои настройки роутера 

				Стандартная схема роутинга проверяет, что объект, полученный из базы данных dealer_price, будет сохранён в эту же бд.

			Если нужно реализовать поведение, когда не нужно конкретно указывать в какую бд делать запрос, то можно определить и установить собственные роутеры.

				См. https://djbook.ru/rel1.9/topics/db/multi-db.html#database-routers

				См. https://docs.djangoproject.com/en/2.2/topics/db/multi-db/#automatic-database-routing

			Можно каждый раз указывать бд в ручную

				Author.objects.using('alias_db').all()

				my_object.save(using='legacy_users')

				u = User.objects.using('legacy_users').get(username='fred')
				u.delete()

				user_obj.save(using='new_users')
				user_obj.delete(using='legacy_users')

			Ручное указание бд и multiple save()

				p = Person(name='Fred')
				p.save(using='first')
				p.save(using='second')

					В первом операторе создаётся новый объект Person в базе данных first. В этот момент p не обладает первичным ключом, поэтому Djangо выполняет SQL запрос INSERT. Запрос создаёт первичный ключ и Django назначает его для p.

					При сохранении объекта во втором операторе, p уже обладает первичным ключом и Django попытается использовать его для новой базы данных. Если значение первичного ключа ещё не было использовано в базе данных second, то вы не заметите никаких проблем, объект будет скопирован в новую базу данных.

					Но если первичный ключ p уже используется в базе данных second, то произойдёт перезапись объекта с таким ключом данными объекта p.

						Этого можно избежать двумя способами:

							Первый, вы можете очищать значение первичного ключа в экземпляре. Если объект не имеет первичного ключа, Django считает его новым, не позволяя потерь данных в базе second.

								p = Person(name='Fred')
								p.save(using='first')
								p.pk = None
								p.save(using='second') 

							Вторым способом будет использование параметра force_insert метода save(), чтобы явно заставить Django использовать SQL запрос INSERT.

								p = Person(name='Fred')
								p.save(using='first')
								p.save(using='second', force_insert=True)

		В настоящее время Django не предоставляет поддержки для внешних ключей и связей многие-ко-многим между множеством баз данных.

	Табличные пространства

		Использовать, когда действительно ничего больше не помогает. Например репликация.

		Общая парадигма для оптимизации производительности в системах баз данных заключается в использовании tablespaces для распределения данных по дискам.

		Django не создаёт табличные пространства для вас. Пожалуйста, обратитесь к документации на вашу базу данных насчёт подробностей по созданию и управлению табличными пространствами. То есть если в настройках бд используются табличные пространства, то в Django можно привязать к ним.

			PostgreSQL и Oracle поддерживают табличные пространства. SQLite и MySQL не поддерживают.

			При использовании бэкэнда, который не обеспечивает поддержку табличных пространств, Django будет игнорировать все атрибуты для табличных пространств.

		Для таблицы, созданной по модели, может быть указано табличное пространство с помощью атрибута db_tablespace внутри класса Meta.

			Вы можете использовать параметр конфигурации DEFAULT_TABLESPACE для указания значения по-умолчанию для атрибута db_tablespace.

		Вы можете передать атрибут db_tablespace в конструктор Field, чтобы указать табличное пространство для индекса данного поля.

			Вы можете использовать параметр конфигурации DEFAULT_INDEX_TABLESPACE для указания значения по-умолчанию для атрибута db_tablespace.

	Нюансы бд

		Установка кодировки и подсистемы для mysql 

			DATABASES = {
			    'default': {
			    	...
			        'OPTIONS': {
			            'charset': 'utf8',
			            'init_command': 'SET default_storage_engine=INNODB',
			        }
			    },
			}

Миграции

	Основы работы

		Создали и описали модель.

		Выполнили ./manage.py makemigrations

		В приложении в директории migrations создался файл.

		Выполнили ./manage.py migrate

		В базе создались таблицы.

		Добавили в модель новое поле.

		Выполнили ./manage.py makemigrations

		В приложении в директории migrations создался новый файл.

		Выполнили ./manage.py migrate

		В базе в нужной таблице создалось поле, которое добавили в модель.

		Удалили новое поле из модели.

		Выполнили ./manage.py makemigrations

		В приложении в директории migrations создался еще один файл. При этом предыдущие два остались.

		Выполнили ./manage.py migrate

		В базе в нужной таблице удалилось поле, которое удалили из модели.
	
	Тестирование работы в бою

		Заливаем актуальный дамп в бд.

		Создаем новое поле в модели.

		Выполняем ./manage.py makemigrations

		Выполняем ./manage.py migrate

		Должно успешно создасться новое поле в бд.	

ORM

    ORM (object relational mapping) - технология программирования, которая обеспечивает работу с базой данных без необходимости писать чистые sql запросы. 

    	В orm класс описывает таблицу в бд.

    	Созданный на основе класса объект представляет собой одну запись в таблице.

    	На основе класса создаётся объект и кладём в бд.

	    Плюсы: скорость разработки

	    Минусы: скорость работы

	Общее

		За работу с базой данных отвечает модель.

		Модели определяются в файле models.py каждого приложения.

		Обычно одна модель представляет одну таблицу в бд.

		В сообществе принято называть таблицы и модели в единственном числе. Например Product.

		После выполнения миграций на основе моделей в базе данных создаются таблица в формате appname_modelname (cards_product).

			Название таблицы можно переопределить с помощью параметра db_table, который нужно добавить в класс Meta, который находится внутри класса модели.

				Настоятельно рекомендуем использовать нижний регистр при переопределении названия таблицы через db_table, особенно при использовании MySQL.

		После определения моделей необходимо указать Django что необходимо их использовать. Это можно сделать, добавив в INSTALLED_APPS имя приложения.

		Нельзя использовать имена конфликтующие с API моделей, такие как clean, save или delete.

		Cамые используемые настройки полей:

			null 

				Если True, Django сохранит пустое значение как NULL в базе данных. По умолчанию - False.

			blank

				Если поле содержит blank=True, форма позволит передать пустое значение. При blank=False - поле обязательно.

			choices

				При определении, виджет формы использует select вместо стандартного текстового поля и ограничит значение поля указанными значениями.

			    SHIRT_SIZES = (
			        ('S', 'Small'),
			        ('M', 'Medium'),
			        ('L', 'Large'),
			    )
			    shirt_size = models.CharField(max_length=1, choices=SHIRT_SIZES)

			default

				Значение по умолчанию для этого поля.

			primary_key

				При True поле будет первичным ключом.

				При этом Django не добавит поле id по умолчанию.

			unique

				При True поле будет уникальным.

		По умолчанию Django для каждой модели добавляет такое поле: 

			id = models.AutoField(primary_key=True)

			Это автоинкрементный первичный ключ.

		Каждое поле, кроме ForeignKey, ManyToManyField и OneToOneField, первым аргументом принимает необязательное читабельное название.

			first_name = models.CharField('User name')

		ForeignKey, ManyToManyField и OneToOneField первым аргументом принимает класс модели, поэтому для читабельного названия используется аргумент verbose_name.

			sites = models.ForeignKey(Site, verbose_name='list of sites')

		Желательно, чтобы название поля ForeignKey связанной было названием модели в нижнем регистре.

		Для поля ForeignKey можно задать имя для обратной связи.

			class Dealer(models.Model):
				name = models.CharField(max_length=255)

			class Car(models.Model):
				dealer = models.ForeignKey(Dealer, related_name='super_cars')

			Dealer.objects.first().super_cars.all()

		Название поля не может быть слово зарезервированное Python, т.к. это приведет к синтаксической ошибке.

		Зарезервированные SQL слова, такие как join, where или select, можно использовать как название поля

		Название поля не может содержать несколько нижних подчеркиваний подряд, т.к. такой подход Django использует для формирования запросов.

		Можно создавать собственные типы полей.

		Дополнительные настройки для модели можно определить через class Meta.

			class Ox(models.Model):
			    horn_length = models.IntegerField()

			    class Meta:
			        ordering = ['horn_length']
			        verbose_name_plural = 'oxen'

		Можно создать неуправляемую модель, указав в meta, managed=False.

			Таблицы для этой модели не будет создаваться или удаляться.

			Это полезно, если модель отображает существующую таблицу или “VIEW” в базе данных, которая была создана другим способом.

		@property - позволяет определить имя функции, как поле модели (значения поля будет выдаваться динамически результатом функции)

Связи бд

	Один к одному

		class People(models.Model):
			name = models.CharField(max_length=255)

		class Pasport(models.Model):
			people = models.OneToOneField(People, on_delete=models.CASCADE)
			code = models.IntegerField()

		На основе этих моделей создадутся 2 таблицы в бд - appname_people, appname_pasport.

		В таблице appname_pasport будет связь один к одному - people_id.

	Один ко многим

		class Dealer(models.Model):
			name = models.CharField(max_length=255)

		class Car(models.Model):
			dealer = models.ForeignKey(Dealer, on_delete=models.CASCADE)

		ForeignKey('Manufacturer', on_delete=models.CASCADE) - позволяет создать связь с моделью, которая еще не определена. Если нужно обратиться к модели из другого приложения, то пишем так 'name_app.Manufacturer'

		ForeignKey.limit_choices_to - позволяет ограничить выбор внешнего ключа для модельной форме в админке, по умолчанию в селект выводится все данные из queryset

	Связь на модель, которая еще не определена

		class Car(models.Model):
			dealer = models.ForeignKey('Dealer', on_delete=models.CASCADE)

		class Dealer(models.Model):
			name = models.CharField(max_length=255)

		Для связи на модель из другого приложения используйте название модели и приложения.

			class Car(models.Model):
				dealer = models.ForeignKey('app_name.Dealer', on_delete=models.CASCADE)

	Многие ко многим

		class Topping(models.Model):
		    pass

		class Pizza(models.Model):
		    toppings = models.ManyToManyField(Topping)

		Желательно, чтобы название поля ManyToManyField было во множественном числе.

		Не имеет значения какая модель содержит поле ManyToManyField, но его может содержать только одна из моделей.

		Обычно, ManyToManyField необходимо добавить в модель, которая будет редактироваться в форме. 

			И потому что обычно думают о пицце с ингредиентами, а не об ингредиентах в различных пиццах.

		В итоге на основе данной модели в бд создастся таблица appname_pizza_toppings.

		Иногда необходимо хранить дополнительную информацию о связи.

			Например музыкальные группы, музыканты и когда музыкант вступил в группу.

			Для таких случаев Django позволяет определить модель для хранения связи многие ко многим и дополнительной информации.

				class Person(models.Model):
				    name = models.CharField(max_length=128)

				class Group(models.Model):
				    name = models.CharField(max_length=128)
				    members = models.ManyToManyField(Person, through='Membership')

				class Membership(models.Model):
				    person = models.ForeignKey(Person, on_delete=models.CASCADE)
				    group = models.ForeignKey(Group, on_delete=models.CASCADE)
				    date_joined = models.DateField()
				    invite_reason = models.CharField(max_length=64)

				На основе этих моделей создадутся таблицы appname_person, appname_group, appname_membership (здесь и будет находиться связи - person_id, group_id)

				По сути эта такая же связь многие ко многим только с дополнительными полями в таблице, где хранится связь.

Наследование

	Базовый класс должен наследоваться от models.Model.

	Нужно определить, это должна ли родительская модель быть независимой моделью (с собственной таблицей в базе данных), или же родительская модель просто контейнер для хранения информации, доступной только через дочерние модели.

	Запрещено переопределять атрибуты класса родителя в дочернем классе.

		То есть если родительская модель имеет поле author, вы не можете создать поле с именем author в дочерних моделях.

		Эти ограничения относятся только для атрибутов, которые являются экземплярами Field. Остальные атрибуты могут быть переопределены.

	Абстрактные модели

		Удобны при определении общих, для нескольких моделей, полей.

		Для этой модели не будет создана таблица в базе данных.

		Поля в абстрактной модели будут в той модели, которая наследуется от неё.

		Нельзя использовать поля с одинаковыми названиями в дочерней и родительской моделях.

		Абстрактная модель не имеет менеджера.

		Если дочерний класс не определяет собственный класс Meta, он унаследует родительский класс Meta.

		Можно расширить родительский класс Meta.

		class CommonInfo(models.Model):
		    name = models.CharField(max_length=100)
		    age = models.PositiveIntegerField()

		    class Meta:
		        abstract = True

		class Student(CommonInfo):
		    home_group = models.CharField(max_length=5)

		    class Meta(CommonInfo.Meta):
		        db_table = 'student_info'

		Используя атрибут related_name для ForeignKey или ManyToManyField, вы должны всегда определять уникальное название для обратной связи.

			Потому что поля абстрактной модели будут добавлены в каждой из дочерних моделей, с теми же значениями аргументов.

			Не указав related_name для абстрактной модели, для обратной связи будет использовано название дочерней модели плюс '_set'.

	Multi-table

		Каждая модель имеет собственную таблицу в базе данных и может быть использована независимо.

		Наследование использует связь между родительской и дочерней моделью через автоматически созданное поле OneToOneField.

		Все поля родительской модели будут доступны в дочерней при том, что значения будут храниться в разных таблицах.

		Дочерняя модель не имеет доступа к родительскому классу Meta.

		Можно не наследовать настроеки Meta родительской модели.

		При использовании ForeignKey и ManyToManyField в дочерней модели по отношении к родительской обязательно нужно указать related_name

		class Place(models.Model):
		    name = models.CharField(max_length=50)
		    address = models.CharField(max_length=80)

		class Restaurant(Place):
		    serves_hot_dogs = models.BooleanField(default=False)
		    serves_pizza = models.BooleanField(default=False)

		    class Meta:
		    	ordering = []

		class Guest(Place):
			customers = models.ManyToManyField(Place, related_name='guests')

	Proxy модели

		Используются для переопределения поведения модели (например сортировка, менеджер и т.д.) не меняя структуры базы данных.

		Указать что это proxy модель можно установив атрибут proxy в классе Meta в True.

		Если вы не определите ни один менеджер для proxy модели, он будет унаследован от родительской модели.

		Proxy модель использует ту же таблицу в базе данных, что и оригинальная.

		Должна наследоваться от одной модели.

		class Person(models.Model):
		    first_name = models.CharField(max_length=30)
		    last_name = models.CharField(max_length=30)

		class ProxyPerson(Person):
			objects = NewManager()

		    class Meta:
		        proxy = True

	Множественное наследование

		Если есть несколько родительских объектов с классом Meta, в таком случае будет использован атрибут первой родительской модели, остальные будут проигнорированы.

		Наследование от нескольких моделей, которые содержат первичное поле id, вызовет ошибку.

			Чтобы избежать этой проблемы, можно явно указать AutoField поля в базовых моделях.

		class Article(models.Model):
		    article_id = models.AutoField(primary_key=True)

		class Book(models.Model):
		    book_id = models.AutoField(primary_key=True)

		class BookReview(Book, Article):
		    pass

Атрибуты

	Самый важный это objects, который является менеджером модели.

	Менеджер это интерфейс, через который Django выполняет запросы к базе данных и получает объекты.

	Менеджеры доступны только через класс модели, они не доступны в экземплярах (объектах) модели.

Методы orm

	__str__ - возращает строковое представление объекта

	__eq__ - ?

	__hash__ - возращает хэш объекта

	get_absolute_url - возвращает строку-url для объекта (используется в интерфейсе администратора для "Показать на сайте")

		<a href="{{ object.get_absolute_url }}">{{ object.name }}</a>

	get_FOO_display - возвращает значение поля из choices, который определен в модели. FOO нужно заменить на имя choices

		class Person(models.Model):
		    SHIRT_SIZES = (
		        ('S', 'Small'),
		        ('M', 'Medium'),
		        ('L', 'Large'),
		    )

		p = Person(name="Fred")
		p.get_shirt_size_display()

	get_next_by_FOO - возвращает следующее значение поля из choices от текущего

	get_previous_by_FOO - возвращает предыдущее значение поля из choices от текущего

	Переопределение методов модели

		Чаще всего вы захотите переопределить метод save() и delete().

		Переопределенные методы модели не вызываются при множественных операциях с bulk.

		Учтите, метод delete() не обязательно вызывается при массовом удалении объектов через QuerySet или как результат каскадного удаления.

		class Blog(models.Model):
		    name = models.CharField(max_length=100)

		    def save(self, *args, **kwargs):
		        # action before

		        super().save(*args, **kwargs)

		        # action after

	Свои методы модели

		Для добавления функционала работы с экземпляром модели, необходимо добавить метод в модель.

		Методы модели работают с конкретной записью в таблице.

		class Person(models.Model):
		    def get_full_name(self):
		    	return '{name] {surname}'.format(name=self.name, surname=self.surname)

	Все параметры мета можно посмотреть здесь:

		https://djbook.ru/rel1.9/ref/models/options.html

		https://docs.djangoproject.com/en/2.2/ref/models/options/

	Типы полей можно посмотреть здесь:

		https://djbook.ru/rel1.9/ref/models/fields.html#model-field-types

		https://docs.djangoproject.com/en/2.2/ref/models/fields/#field-types

Менеджеры

	Это интерфейс, через который создаются запросы.

	Каждая модель имеет хотя бы один менеджер.

	По умолчанию Django добавляет Manager с именем objects для каждого класса модели.

		Author.objects.first()

	Чтобы переименовать Manager

		class Person(models.Model):
		    people = models.Manager()

	Методы Manager могут возвращать что угодно. И это не обязательно должен быть QuerySet.

	Базовый QuerySet менеджера возвращает все объекты модели.

		Book.objects.all()

	Вы можете изменить базовый QuerySet, переопределив метод Manager.get_queryset()

		class DahlBookManager(models.Manager):
		    def get_queryset(self):
		        return super(DahlBookManager, self).get_queryset().filter(author='Roald Dahl')

		class Book(models.Model):
		    title = models.CharField(max_length=100)
		    author = models.CharField(max_length=50)

		    objects = models.Manager()
		    dahl_objects = DahlBookManager()

		Book.dahl_objects.all()

		Конечно же, т.к. get_queryset() возвращает экземпляр QuerySet, вы можете использовать filter(), exclude() и остальные методы QuerySet.

	Вы можете добавить столько экземпляров Manager(), сколько вы пожелаете.

	Можно добавлять собственные методы в переопределенный QuerySet

		class PersonManager(models.Manager):
		    def get_queryset(self):
		        return PersonQuerySet(self.model, using=self._db)

		    def authors(self):
		        return self.get_queryset().authors()

		    def editors(self):
		        return self.get_queryset().editors()

	При использовании собственного объекта Manager, помните, что первый Manager, который заметит Django будет Manager по умолчанию.

		Менеджеры из не абстрактной базовой модели не наследуются дочерними.

		Менеджеры абстрактного класса наследуются дочерними (имена дочернего класса переопределяют имена родительского).

		Менеджером по умолчанию становится первый менеджер, определенный в модели. 

			Если он отсутствует, используется менеджер по умолчанию первого абстрактного класса среди родительских моделей, если он существует. 

			Если таким образом не удалось определить менеджер по умолчанию, используется стандартный менеджер Django.

	Обычно менеджеры предназначены для работы с моделью, к которой принадлежат, поэтому наследовать их в дочерних моделях - не всегда хорошая идея.

Queryset-ы

	Queryset-ы модели более гибче, чем менеджеры модели и похожи на фильтры. 

	Используются не вместо Book.objects, а вместе с Book.objects.queryset_method()

		class ProductCardQuerySet:
			def get_actual(self):
				return self.filter(is_actual=True)

		objects = ProductCardQuerySet.as_manager()

	В кастомном queryset-е не переопределяется метод get_queryset, только в кастомном менеджере.

QuerySet

	Для получения объектов из базы данных, создается QuerySet.

	QuerySet представляет выборку объектов из базы данных.

	Обратиться к менеджерам можно только через класс модели и нельзя через экземпляр.

	После каждого изменения QuerySet, вы получаете новый QuerySet, который никак не связан с предыдущим.

	Создание QuerySet не выполняет запросов к базе данных, пока QuerySet не вычислен.

	Если используется срез, больше нельзя изменять queryset (например, добавлять фильтры, менять сортировку и т.д.).

Когда вычисляется QuerySet
	
	При первом выполнении итерации

		for e in Entry.objects.all():
    		print(e.headline)

    Если будет указан шаг среза

    	Entry.objects.all()[1:10:2]

    	Срез без шага возвращает новый не вычисленный QuerySet.

    Если используется pickle для QuerySet

    При обращении к св-ву объекта

    	entry = Entry.objects.all()
    	entry.first().name

    При использовании repr()

    	repr() используется для строкового представления объекта.

    При использовании len()

    	entry_count = len(Entry.objects.all())

    При использовании list()

    	entry_list = list(Entry.objects.all())

    При вычислении булевого значения

    	if Entry.objects.filter(headline='Test'):

Кэширование и QuerySet

	Каждый QuerySet содержит кэш, для уменьшения количества запросов.

	В только что созданном QuerySet кеш пустой.

	После вычисления QuerySet Django сохраняет результат запроса в кеше и возвращает необходимый результат.

	Последующие вычисления QuerySet используют кеш.

	Использование print с queryset не заполнит кэш т.к. будет вызван __repr__(), который показывает только часть объектов.

	Этот код создаст два экземпляра QuerySet и вычислит их не сохраняя. Это означает, что один и тот же запрос будет выполнен дважды, удваивая нагрузку на бд.

		a = [e.headline for e in Entry.objects.all()]

		b = [e.pub_date for e in Entry.objects.all()]

	Чтобы избежать этой проблемы, просто сохраните QuerySet и используйте его повторно:

		queryset = Entry.objects.all()

		# выполнился запрос
		a = [p.headline for p in queryset]

		# был использован кэш
		b = [p.pub_date for p in queryset]

	Или загрузите весь QuerySet:

		queryset = Entry.objects.all()

		[entry for entry in queryset]

		# берет из кэша
		a = queryset[5]

		# берет из кэша
		b = queryset[5]

	QuerySet не кэшируется при использовании индекса или среза.

		queryset = Entry.objects.all()

		# запрос к базе
		a = queryset[5]

		# запрос к базе
		b = queryset[5]

Сравнение объектов

	some_entry = Entry.objects.first()

	other_entry = Entry.objects.first()

	# будут сравнены первичные ключи
	some_entry == other_entry

	Если первичный ключ назван не id - это не проблема. Сравнение всегда использует первичный ключ.

Выполнение запросов

	Создание

		Вы можете использовать get_or_create() с атрибутами ManyToManyField и обратными внешними связями, но это может вызвать некоторые проблемы при создании объектов.

		При использовании bulk_create метод save() не будет вызван, и сигналы pre_save и post_save тоже.

		bulk_create не работает с дочерними моделями при multi-table наследовании и со связями многое-ко-многим.


		Person.objects.create(first_name='Ilya', last_name='Kaduk')

		obj, created = Person.objects.get_or_create(first_name='Ilya', last_name='Kaduk')

		obj, created = Person.objects.update_or_create(first_name='Ilya', last_name='Kaduk')

		Person.objects.bulk_create([
			Person(first_name='Vika', last_name='Baranova'),
			Person(first_name='Ilya', last_name='Kaduk'),
		])

	Копирование

		blog = Blog(name='My blog')
		blog.save()

		blog.pk = None
		blog.save()

		Примечание! Связанные объекты не копируются.

		Если используем наследование моделей, то так:

			class ThemeBlog(Blog):
			    theme = models.CharField(max_length=200)

			blog = ThemeBlog(name='Django')
			blog.save()

			blog.pk = None
			blog.id = None
			blog.save()

			Примечание! Связанные объекты не копируются.

		Для копирования связанных объектов:

			entry = Entry.objects.all()[0]

			old_authors = entry.authors.all()

			entry.pk = None
			entry.save()
			entry.authors = old_authors

	Обновление

		Django не выполняет запросов к базе данных, пока не будет вызван метод save().


		offer = Offer.objects.get(name='old_name')
		offer.name = 'new_name'
		offer.save()

		Обновление связанных объектов

			joe = Author.objects.create(name="Joe")
			entry.authors.add(joe)


			john = Author.objects.create(name="John")
			paul = Author.objects.create(name="Paul")
			entry.authors.add(john, paul)

		Обновление нескольких объектов, которые соотвествуют условию

			Entry.objects.filter(
				pub_date__year=2007
			).update(
				headline='New value'
			)

		Обновление в связанном объекте

			b = Blog.objects.get(pk=1)
			Entry.objects.all().update(blog=b)

		Обновление с сохранением каждого объекта в QuerySet и методом save()

			for item in my_queryset:
			    item.save()

	Выборка 

		Одного

			Entry.objects.get()

			Entry.objects.first()

			Для получения одного объекта, а не списка, используйте индекс вместо среза.

				Entry.objects.all()[0]

		Одного и всех связанных с ним

			blog = Blog.objects.get(pk=1)

			blog.entry__set.all()

			Берет все связанные объекты.

		Всех

			Entry.objects.all()

		Одного/нескольких и связанных с ними

			Entry.objects.select_related('blog').get(pk=5)

			Entry.objects.filter(pub_date__gt=timezone.now()).select_related('blog')

			select_related('foo', 'bar')


			select_related включает в выборку данные связанных объектов.

			Это повышает производительность, потому что потом при обращении к связанным объектам они берутся из кэша.

			Работает только со связями один к одному. То есть берет данные только для одного объекта за раз.

			Чтобы очистить список полей указанных ранее select_related для QuerySet, предайте None.


			pizza = Pizza.objects.all().prefetch_related('toppings')

			Будет выполнено 2 запроса.

			pizza.toppings.all()

			Этот код аналогичен выполнению self.toppings.all() для каждого объекта Pizza, но будут использоваться данные, из кэша QuerySet.


			prefetch_related выбирает данные для каждой связи отдельно.

			Работает со связями один к одному, один ко многим и имногие ко многим.

			Обратите внимание, что будет закэширован также результат выполнения основного QuerySet, а также будут загружены все связанные объекты. Это отличается от стандартного поведения QuerySets, при котором Django старается не загружать связанные данные как можно дольше.

	Фильтрация 

		Entry.objects.filter(pk__in=[1,4,7])

		По связанным объектам

			Entry.objects.filter(blog__name='Beatles Blog')

			Все работает и в другую сторону. Чтобы обратиться к обратной связи, просто используйте имя модели в нижнем регистре или имя указанное в related_name.

				Blog.objects.filter(entry__authors__name='Lennon')

			Если вы используйте фильтр через несколько связей и одна из промежуточных моделей не содержит подходящей связи, Django расценит это как пустое значение

		По связям многие ко многим

			# возьми все с ...=2006, а также с ...='What'

			Entry.objects.filter(
				pub_date__year=2006
			).filter(
				headline__startswith='What'
			)

			# запись должна удовлетворять оба условия

			Entry.objects.filter(
				pub_date__year=2006, 
				headline__startswith='What', 
				pub_date__gte=datetime(2005, 1, 30)
			)

		Exclude по связям многие ко многим

			Blog.objects.exclude(
			    entry__headline__contains='Lennon',
			    entry__pub_date__year=2008,
			)

		Фильтры могут ссылаться на поля модели

			Entry.objects.filter(n_comments__gt=F('n_pingbacks'))

		Если необходимо всего лишь узнать содержит ли результат, то эффективнее использовать метод exists()

			Entry.objects.filter(pk=22).exists()

		Другие варианты

			# точное совпадение
			Entry.objects.filter(headline__exact="Cat bites dog")

			# точное регистро-независимое, совпадение
			Entry.objects.filter(name__iexact='beatles blog')

			# проверка на вхождение, как Like
			Entry.objects.filter(headline__contains='Lennon')
			
			# знак % экранировать не нужно
			Entry.objects.filter(headline__contains='%')

			# регистронезависимая проверка на вхождение
			Entry.objects.filter(headline__icontains='Lennon')

			# больше чем
			Entry.objects.filter(id__gt=4)

			# больше чем или равно
			Entry.objects.filter(id__gte=4)

			# меньше чем
			Entry.objects.filter(id__lt=4)

			# меньше чем или равно
			Entry.objects.filter(id__lte=4)

			# начинается ли поле с указанного значения
			Entry.objects.filter(id__startswith=4)

			# регистронезависимая проверка начинается ли поле с указанного значения
			Entry.objects.filter(id__istartswith=4)

			# проверка оканчивается ли поле с указанного значения
			Entry.objects.filter(id__endswith=4)

			# регистронезависимая проверка оканчивается ли поле с указанного значения
			Entry.objects.filter(id__iendswith=4)

			# проверка на вхождение в диапазон (включающий)
			Entry.objects.filter(pub_date__range=(start_date, end_date))

			# проверка на дату
			Entry.objects.filter(pub_date__date=datetime.date(2005, 1, 1))

			# проверяет на IS NULL
			Entry.objects.filter(pub_date__isnull=True)

			# проверяет на IS NOT NULL
			Entry.objects.filter(pub_date__isnull=False) 

			# полнотекстовый поиск, который использует преимущества полнотекстового индекса. Работает как и contains но значительно быстрее.
			Entry.objects.filter(headline__search="+Django -jazz Python")

			# проверка регулярным выражением
			Entry.objects.filter(title__regex=r'^(An?|The) +')

			# регистронезависимая проверка регулярным выражением
			Entry.objects.filter(title__iregex=r'^(an?|the) +')

	F()

		Экземпляр F() рассматривается как ссылка на другое поле модели.

		Эти ссылки могут быть использованы например для сравнения значений двух разных полей одного объекта модели.

		Так же с помощью экземпляра F() можно получить значение не из кэша queryset.

		Entry.objects.filter(n_comments__gt=F('n_pingbacks'))

	Q()

		Используется для составления сложных выборок с множественными операторами OR, AND.

		Объекты Q могут быть объединены операторами & и |.

		from django.db.models import Q

		Poll.objects.get(
		    Q(question__startswith='Who'),
		    Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6))
		)

			SELECT 
				* 
			FROM 
				polls 
			WHERE 
				question 
			LIKE 
				'Who%' 
			AND 
				(pub_date = '2005-05-02' OR pub_date = '2005-05-06')

	Агрегация

		Позволяют вычислить одно значение из группы значений одного столбца в таблице. 

		Например мы хотим узнать кол-во книг всех авторов или кол-во книг одного автора.


		Для всех объектов в целом

			Используется .aggregate()

			aggregate() завершающая инструкция для QuerySet, которая возвращает словарь с результатом.


			Book.objects.all().aggregate(Avg('price'))

			Book.objects.aggregate(Avg('price'))

			# Оба запроса выше вычислят результат, который будет доступен по ключу price__avg

			Book.objects.aggregate(Avg('price'), Max('price'), Min('price'))

			# average_price - имя ключа по которому можно получить результат
			Book.objects.aggregate(average_price=Avg('price'))

		Для каждого объекта

			Используется .annotate()


			book = Book.objects.annotate(Count('authors'))

			book[0].authors__count

			book[1].authors__count

			Book.objects.annotate(num_authors=Count('authors'))

			Book.objects.annotate(Count('authors'), Count('chapters'))


			Объединение нескольких агрегаций через annotate() может привести к неправильному результату, т.к. объединяются несколько таблиц. Из-за использования LEFT OUTER JOIN могут создаваться дублирующиеся записи, если объединенные таблицы содержат разное количество записей. Однако, агрегация Count принимает аргумент distinct, который может помочь.

				Book.objects.annotate(Count('authors', distinct=True), Count('chapters', distinct=True))

		По связанным моделям

			Store.objects.aggregate(min_price=Min('books__price'))

			Store.objects.annotate(min_price=Min('books__price'))


			Store.objects.aggregate(youngest_age=Min('books__authors__age'))

		Обратные связи

			Publisher.objects.annotate(Count('book'))

			# получаем самую старую книгу издателя
			Publisher.objects.aggregate(oldest_pubdate=Min('book__pubdate'))

		Другие методы и агрегация

			При исользовании будет использовататься тот порядок, который задан, то есть если сначала идет агрегация, а потом фильтрация, то так и будет. И на оборот.


			Фильтр ограничит выборку объектов, для которых необходимо выполнить агрегацию.

			Фильтры и exclud-ы можно использовать после агрегации.


			Book.objects.filter(name__startswith="Django").annotate(num_authors=Count('authors'))

			Book.objects.annotate(num_authors=Count('authors')).filter(num_authors__gt=1)

		Аннотация и сортировка order_by()

			При исользовании будет использовататься тот порядок, который задан, то есть если сначала идет агрегация, а потом фильтрация, то так и будет. И на оборот.

			Book.objects.annotate(num_authors=Count('authors')).order_by('num_authors')

		Аннотация и values()

			При исользовании будет использовататься тот порядок, который задан, то есть если сначала идет агрегация, а потом фильтрация, то так и будет. И на оборот.


			Вместо того, чтобы вычислить значение для каждого объекта QuerySet, сначала все объекты результата будут разделены на группы по уникальному значению полей, указанных в values().

			А аннотация будет использована для каждой группы и будут использованы значения всех объектов группы.



			Author.objects.values('name').annotate(average_rating=Avg('book__rating'))

				В примере выше, авторы будут сгруппированы по имени, поэтому вы получите средний рейтинг для уникального имени автора. 

				Это означает, что, если в базе есть два автора с одинаковым именем, их результаты будут объединены вместе, а среднее значение будет вычислено, как среднее значение книг обоих авторов.

				Однако, если annotate() используется перед values(), аннотация будет вычислена для каждого объекта и values() просто ограничит возвращаемые поля.

		Влияние сортировки по-умолчанию и order_by()

			Если в модели задана сортировка по умолчанию, то она будет влиять.

				class Meta:
					ordering = ['name']

				Чтобы решить проблему нужно убрать сортировку из запроса и добавить нужные поля в values().

					Item.objects.values("data").annotate(Count("id")).order_by()

		Аннотация для агрегации

			Можно использовать если нужно посчитать среднее количество авторов для каждой книги.

				Book.objects.annotate(num_authors=Count('authors')).aggregate(Avg('num_authors'))

	Удаление

		entry = Entry.objects.first()
		entry.delete()

		Entry.objects.filter(pub_date__year=2005).delete()

	Использование чистого SQL

		Использование модели

			Этот вариант выполняет запрос и возвращает RawQuerySet.

			RawQuerySet может быть проитерирован (как и обычный QuerySet) для получения объектов.

				Хотя RawQuerySet и можно проитерировать как QuerySet, RawQuerySet не предоставляет все методы QuerySet.

			SQL Запрос переданный в .raw() не проверяется.

			Если запрос возвращает не набор записей, вы получите ошибку.


			Выполняя запрос в MySQL, обратите внимание на преобразование типов. 

				Если вы выполняете запрос по текстовому полю, но используете числовое значение, MySQL преобразует все значения поля в число перед сравнением.

				Чтобы избежать этого, используйте значение правильного типа в запросе.


			Person.objects.raw('SELECT * FROM myapp_person')

			for p in Person.objects.raw('SELECT * FROM myapp_person'):
				print(p)

			first_person = Person.objects.raw('SELECT * FROM myapp_person')[0]

				Если база данных содержит большое количество записей Person, эффективнее ограничить результат выборки на уровне SQL.

					first_person = Person.objects.raw('SELECT * FROM myapp_person LIMIT 1')[0]

			Отложенная загрузка полей

				Есть только одно поле, которое вы обязаны загрузить - первичный ключ.

					Если вы забудете про первичный ключ, будет вызвано исключение InvalidQuery.

				Это означает, что неуказанные в запросе поля будут загружены при обращении к ним.

					for p in Person.objects.raw('SELECT id, first_name FROM myapp_person'):
						# этого поля не было в запросе и оно загрузилось только сейчас (выполнился ещё один запрос)
						print(p.last_name)

			Используйте %s в строке с запросом для списка параметров, или %(key)s для словаря(где key будет заменен на значение ключа из словаря), независимо от базы данных.

				lname = 'Doe'
				erson.objects.raw('SELECT * FROM myapp_person WHERE last_name = %s', [lname])

			Не используйте форматирование строк в запросе!

				При вставке параметров непосредственно в строку запроса, рано или поздно вы станете жертвой атаки с внедрением SQL-кода. 

				query = 'SELECT * FROM myapp_person WHERE last_name = %s' % lname
				Person.objects.raw(query)

		Выполнение запроса на прямую

			def my_custom_sql(self):
			    cursor = connection.cursor()

			    cursor.execute('SELECT foo FROM bar WHERE baz = %s', [self.baz])

			    return cursor.fetchone()

			Если необходимо вставить символ процента, необходимо его продублировать.

				cursor.execute("SELECT foo FROM bar WHERE baz = '30%%' AND id = %s", [self.id])

			Если вы используете несколько баз данных, вы можете использовать django.db.connections для получения подключения к конкретной базе данных.

				cursor = connections['my_db_alias'].cursor()

			По умолчанию Python DB API вернет результат без названий полей, то есть вы получите список значений, а не словарь.

				За счет небольшой потери производительности вы можете получить словарь следующим образом:

					def dictfetchall(cursor):
					    columns = [col[0] for col in cursor.description]
					    return [
					        dict(zip(columns, row))
					        for row in cursor.fetchall()
					    ]

	Оптимизация

		Первым делом определите какие запросы выполняются и как быстро.

			from django.db import connection

			connection.queries

			или

			Customer.objects.filter(email='kaduk@gmail.com').query

		Вы также можете использовать сторонние приложения, например, django-debug-toolbar, или инструменты, которые мониторят непосредственно базу данных.

		Следует добавить индексы полям, которые используются в filter(), exclude(), order_by() и др., т.к. они ускоряют поиск по полям.

		Понимание, когда выполняется QuerySets - важная часть для написания эффективного простого кода.

		Понимание кэширования атрибутов QuerySets.

		Шаблонизатор не позволяет использовать скобки и автоматом вызывает функции и методы.

		Будьте внимательны с собственными свойствами - вы должны самостоятельно реализовать кэширование, используя, например, декоратор cached_property.

		Для использования кэширования в QuerySet можно использовать шаблонный тэг with.

		Если у вас очень много объектов, кэширование в QuerySet может использовать большой объем памяти. В этом случае может помочь iterator().

		Выполняйте задачи базы данных в базе данных, а не в Python.

			Самое простое: используйте filter и exclude для фильтрации данных в БД.

			Используйте объект F() для фильтрации по другим полям модели.

		Не совсем переносимый между разными БД, но очень мощный метод - RawSQL, который позволяет добавить SQL непосредственно в запрос. 

		Если не помогает RawSQL, то используйте собственный SQL запрос для получения данных и загрузки в модели.

		Загружайте все данные сразу, если уверены, что будете использовать их.

			Обращение несколько раз к базе данных для получения различных частей одного “массива” данных обычно менее эффективно, чем получение всех данных одним запросом.

			Смотреть select_related и prefetch_related.

		Не получайте данные, которые вам не нужны.

			Смотреть в сторону values() и values_list(), а также defer() и only().

		Вместо загрузки данных в объекты, изменения значений и отдельного их сохранения, используйте update() и delete().

		Используйте значения ключей непосредственно.

			Если вам необходимо только значение внешнего ключа, используйте его, а не обращайтесь к объекту.

				То есть лучше так entry.blog_id, чем так entry.blog.id

		Не сортируйте данные, если вам это не требуется.

			Сортировка требует ресурсы.

			Рандомная сортировка, может быть медленным и сильно нагружать базу данных, поэтому лучше явно задавать.

				Invoice.objects.order_by('?')

			Если модель имеет сортировку по умолчанию (Meta.ordering) и она вам не нужна, уберите её из запроса с помощью order_by() без параметров.

		Используйте общее добавление с помощью bulk_create().

			Это относится и к ManyToManyFields. Так лучше my_band.members.add(me, my_friend), чем так:

				my_band.members.add(me)
				my_band.members.add(my_friend)

Представления

	Определяются в файле views.py

	Это функция или метод класса, которая принимает запрос и возвращает ответ.

	Чтобы представление работало его нужно привязать к определенному URL-у.

		def get_response(request):
			return HttpResponse('response')

	HTTP ответы

		Существует ряд подклассов HttpResponse для распространенных HTTP-состояний. Смотреть:

			https://djbook.ru/rel1.9/ref/request-response.html#ref-httpresponse-subclasses

			https://docs.djangoproject.com/en/2.2/ref/request-response/#ref-httpresponse-subclasses

		Просто верните экземпляр необходимого подкласса вместо HttpResponse.

			return HttpResponseNotFound('<h1>Page not found</h1>')

		Не существует подкласса для всех HTTP-состояний, так как многие из них редко используются.

			Но можно передать нужный статус код в HttpResponse.

				return HttpResponse(status=201)

		Если вы возвращаете ошибку HttpResponseNotFound, вы должны добавить HTML содержимое страницы с ошибкой.

			Для удобства и чтобы все страницы для ошибки 404 выглядели одинаково, Django предоставляет исключение Http404.

			Если вы вызываете исключение Http404 в любой момент обработки запроса, Django перехватит его и вернет стандартную страницу 404 ошибки вашего проекта вместе с 404 кодом состояния HTTP.

				def detail(request, poll_id):
				    try:
				        p = Poll.objects.get(pk=poll_id)
				    except Poll.DoesNotExist:
				        raise Http404("Poll does not exist")
				    return render_to_response('polls/detail.html', {'poll': p})

			Чтобы переопределить страницу, которую Django возвращает для 404 ошибки, вы можете создать HTML шаблон с названием 404.html в корне каталога с шаблонами.

			Этот шаблон будет использоваться, если настройка DEBUG равна False.

	Настройка представления обрабатывающего ошибки

		Если нужно переопределить встроенные представления для обработки ошибок, то это нужно сделать в настройке url-ов.

			# по умолчанию page_not_found()
			handler404 = 'mysite.views.my_custom_page_not_found_view'

			# по умолчанию server_error()
			handler500 = 'mysite.views.my_custom_error_view'

			# по умолчанию permission_denied()
			handler403 = 'mysite.views.my_custom_permission_denied_view'

			# по умолчанию bad_request()
			handler400 = 'mysite.views.my_custom_bad_request_view'

	Представления классы

		Все классы представления наследуют класс View.

		Класс View обрабатывает привязку представления с соответствующими урлу и вызывает нужные методы в зависимости от метода запроса не делая ветвление внутри одной функции.

			# пример, когда нужно городить проверки методов
			def my_view(request):
			    if request.method == 'GET':
			        return HttpResponse('result')

			# пример, когда не нужно городить проверки методов
			class MyView(View):
			    def get(self, request):
			        return HttpResponse('result')

		Поскольку роутинг Django отправляет запрос и ассоциированные с ним аргументы в вызываемую функцию, а не класс, все классы имеют статичный метод as_view(), который указан как точка входа при вызове этого класса.

			В нём создаётся экземпляр вашего класса и вызывается метод dispatch(), в котором определяется тип запроса (GET, POST и др.) и вызывается соответствующий метод. Если такового не нашлось, то происходит исключение HttpResponseNotAllowed.

		Можно переопределять или устанавливать свои атрибуты.

			class MorningGreetingView(GreetingView):
    			greeting = "Morning"

    		url(r'^about/', GreetingView.as_view(greeting="day"))

	Встроенные (generic) представления классы

		Это представления для решения наиболее часто встречаемых задач.

		Можно расширять. 

		Попытка скрестить более чем один обобщённый класс, например, ProcessFormView и ListView, не будет работать так, как вы ожидаете.

		Общие CBV автоматически создают класс ModelForm при работе с моделями. 

			Если указано значение атрибута model, то будет использоваться этот класс модели.

			models.py

				class Author(models.Model):
    				name = models.CharField(max_length=200)

    		views.py

				class AuthorCreate(CreateView):
				    model = Author
				    fields = ['name']

		TemplateView

			Обрабатывает заданный шаблон.

			class HomePageView(TemplateView):
			    template_name = "home.html"

			Методы для расширения:

				get_context_data

		RedirectView

			Редирект на заданный URL.

			Если переданный URL равен None, Django вернет исключение HttpResponseGone (410).

			class ArticleCounterRedirectView(RedirectView):
				# должно ли перенаправление быть постоянным
			    permanent = False

			    # передавать ли строку GET запроса в новую локацию
			    query_string = True

			    # название URL-шаблона на который перенаправлять
			    pattern_name = 'article-detail'

			Методы для расширения:

				get_redirect_url

		Аргумент model, определяющий модель базы данных, с которой работает данное представление, доступен во всех общих представлениях-классах, которые предназначены для отображения единичного объекта или списка объектов.

			Тем не менее, аргумент model это не единственный способ, указать представлению с какими данными оно должно работать и можно использовать queryset.

			queryset = Publisher.objects.all() == model = Publisher

		ListView

			Берет из бд и отображает список объектов.

			class PublisherList(ListView):
    			model = Publisher
    			template_name = "books/publisher_list.html"

    			# имя list объектов для доступа в шаблоне
    			context_object_name = 'my_favorite_publishers'

    		При обработке шаблона, будет использоваться контекст, содержащий переменную object_list. Это переменная хранит список всех объектов издателей.

    			В дополнение к стандартному значению object_list содержит то же самое значение в publisher_list (имя модели в нижнем регистре + list).

    		Другой часто встречающейся задачей является необходимость отфильтровать список объектов по переданному в URL ключу. Ранее мы жестко прописывали имя издателя в URLconf, но что если нам необходимо написать представление, отображающее все книги некоторого произвольного издателя?

    			class PublisherBookList(ListView):
				    template_name = 'books/books_by_publisher.html'

				    def get_queryset(self):
				        self.publisher = get_object_or_404(Publisher, name=self.args[0])
				        return Book.objects.filter(publisher=self.publisher)

			Методы для расширения:

				get_context_data

				get_queryset

    	DetailView

    		Берет из бд и отображает детальную информацию одного объекта.

    		class PublisherDetail(DetailView):
			    model = Publisher

			Методы для расширения:

				get_context_data

				get_queryset

				get_object

		FormView

			Для работы с формой (инициализирующий GET запрос, POST с верными данными неверными данными).

			forms.py

				from django import forms

				class ContactForm(forms.Form):
				    name = forms.CharField()
				    message = forms.CharField(widget=forms.Textarea)

			views.py

				class ContactView(FormView):
				    template_name = 'contact.html'
				    form_class = ContactForm
				    success_url = '/thanks/'

			Методы для расширения:

				form_valid

				form_invalid

		CreateView

			Для создания объекта.

			Если вы указали и fields и form_class, будет вызвано исключение ImproperlyConfigured.

			class AuthorCreate(CreateView):
			    model = Author

			    # поля формы
			    fields = ['name']

			Вместе с CreateView используется форма

				<form action="" method="post">
					{% csrf_token %}
				    {{ form.as_p }}
				    <input type="submit" value="Create"/>
				</form>

				Django ожидает увидеть эту форму в name_app и с названием namemodel_form.html

					Чтобы изменить это поведение можно использовать:

						template_name - для полного указания шаблона и его местоположения

							class AuthorCreate(CreateView):
								

						template_name_suffix - для добавления суффикса к стандартному имени шаблона

			Пример с использованием AJAX

				views.py

					class AjaxableResponseMixin(object):
					    def form_invalid(self, form):
					        response = super(AjaxableResponseMixin, self).form_invalid(form)
					        if self.request.is_ajax():
					            return JsonResponse(form.errors, status=400)
					        else:
					            return response

					    def form_valid(self, form):
					        response = super(AjaxableResponseMixin, self).form_valid(form)
					        if self.request.is_ajax():
					            data = {
					                'pk': self.object.pk,
					            }
					            return JsonResponse(data)
					        else:
					            return response

					class AuthorCreate(AjaxableResponseMixin, CreateView):
					    model = Author
					    fields = ['name']

		UpdateView

			Для редактирования объекта.

			Если вы указали и fields и form_class, будет вызвано исключение ImproperlyConfigured.

			class AuthorUpdate(UpdateView):
			    model = Author

			    # поля формы
			    fields = ['name']

		DeleteView

			Для удаления объекта.

			Если вы указали и fields и form_class, будет вызвано исключение ImproperlyConfigured.

			reverse_lazy используется, потому что urls не загружаются при импорте файла.

			class AuthorDelete(DeleteView):
			    model = Author
			    success_url = reverse_lazy('author-list')

		Как выполнить дополнительную работу до или после вызова общего представления класса

			class AuthorDetailView(DetailView):
			    queryset = Author.objects.all()

			    # это метод, который получает и возвращает рабочий объект представления
			    def get_object(self):
			        object = super().get_object()
			        object.last_accessed = timezone.now()
			        object.save()
			        return object

		Поддержка других методов HTTP

			class BookListView(ListView):
			    model = Book

			    def head(self, *args, **kwargs):
			        last_book = self.get_queryset().latest('publication_date')
			        response = HttpResponse('')
			        response['Last-Modified'] = last_book.publication_date.strftime('%a, %d %b %Y %H:%M:%S GMT')
			        return response

	Generic date views

		Существуют общие классы представления для работы с датами (см. api).

	Миксины классов представлений

		Для более подробной информации см. api.

		ContextMixin

		TemplateResponseMixin

		SingleObjectMixin

		SingleObjectTemplateResponseMixin

		MultipleObjectMixin

		MultipleObjectTemplateResponseMixin

		FormMixin

		ModelFormMixin

		ProcessFormView

		DeletionMixin

	Api

		https://djbook.ru/rel1.9/ref/class-based-views/index.html

		https://docs.djangoproject.com/en/2.2/ref/class-based-views/

	Обработка форм в представлениях классах

		class MyFormView(View):
		    form_class = MyForm
		    initial = {'key': 'value'}
		    # будет искать в app_name/
		    template_name = 'form_template.html'

		    def get(self, request, *args, **kwargs):
		        form = self.form_class(initial=self.initial)
		        return render(request, self.template_name, {'form': form})

		    def post(self, request, *args, **kwargs):
		        form = self.form_class(request.POST)
		        if form.is_valid():
		            # <process form cleaned data>
		            return HttpResponseRedirect('/success/')

		        return render(request, self.template_name, {'form': form})

	Миксины

		Миксины - это классы для повторного использования общего кода.

		Например, в Django есть примесь под названием TemplateResponseMixin, основной задачей которой является определение метода render_to_response(). 

			Когда она будет объединена с поведением базового класса View, получится класс TemplateView, который обрабатывает запрос соответствующим методом (реализация находится в классе View), а затем передаётся в render_to_response(), который, используя атрибут template_name, возвращает объект TemplateResponse (реализовано в TemplateResponseMixin).

		Чем больше реализация методов будет размазана по примесям, тем сложнее будет читать дочерний класс и понимать что же он всё-таки делает, какие методы откуда берутся и какие методы уже перекрыты в родительских классах.

		class AjaxableResponseMixin(object):
		    def form_invalid(self, form):
		        response = super(AjaxableResponseMixin, self).form_invalid(form)
		        if self.request.is_ajax():
		            return JsonResponse(form.errors, status=400)
		        else:
		            return response

		    def form_valid(self, form):
		        response = super(AjaxableResponseMixin, self).form_valid(form)
		        if self.request.is_ajax():
		            data = {
		                'pk': self.object.pk,
		            }
		            return JsonResponse(data)
		        else:
		            return response

		class AuthorCreate(AjaxableResponseMixin, CreateView):
		    model = Author
		    fields = ['name']

	Обработка форм с помощью представлений классов

		class MyFormView(View):
		    form_class = MyForm
		    initial = {'key': 'value'}
		    template_name = 'form_template.html'

		    def get(self, request, *args, **kwargs):
		        form = self.form_class(initial=self.initial)
		        return render(request, self.template_name, {'form': form})

		    def post(self, request, *args, **kwargs):
		        form = self.form_class(request.POST)

		        if form.is_valid():
		            return HttpResponseRedirect('/success/')
		        return render(request, self.template_name, {'form': form})

	Декорирование представлений классов

		Расширение представлений-классов не ограничивается использованием миксинов, также можно подключить декораторы.

		Для декорирования каждого метода представления класса, нужно декорировать метод dispatch().

			Метод класса не то же самое, что и обычная функция, к нему просто так применить декоратор не получится.

			Нужно сначала преобразовать его в метод декоратор. Для этого существует декоратор method_decorator.

				@method_decorator(login_required)
				def dispatch(self, *args, **kwargs):
				    return super(ProtectedView, self).dispatch(*args, **kwargs)

				Также вы можете декорировать класс, указав название методы, которые необходимо декорировать, в аргументе name.

					@method_decorator(login_required, name='dispatch')
					class ProtectedView(TemplateView):
					    template_name = 'secret.html'

				Если у вас есть список декораторов, которые используются в нескольких местах, вы можете указать список или кортеж декораторов и использовать его в method_decorator() несколько раз. При этом декораторы обрабатывают запрос в указанном порядке.

					decorators = [never_cache, login_required]

					@method_decorator(decorators, name='dispatch')
					class ProtectedView(TemplateView):
					    template_name = 'secret.html'

Шаблоны

	Ребята из "two scoops of django" предлагают использовать Jinja2.

	Структура by "two scoops of django"

		2-ух уровневая

			templates/

				base.html

				profiles/

					profile_detail.html # extends base.html

					profile_form.html # extends base.html

		3-х уровневая

			Подходит для сайтов с совершенно разными макетами для каждой страницы.

			templates/

				base.html

				profiles/

					base_profiles.html # extends base.html

					profile_detail.html # extends base_profiles.html

					profile_form.html # extends base_profiles.html

	Контекст

		from django.template import Template, Context

		tmpl = 'Country: {{ my }}'

		context = {'my': 'myvar'}

		Template(tmpl).render(Context(context))

		Выведет 'Country: myvar'

Формы

	Класс Django Form

		Сердце всего механизма – класс Form.

		Form описывает форму, как она работает и показывается пользователю.

		Поля формы сами являются классами. Они управляют данными формы и выполняют их проверку при отправке формы.

		Каждый тип поля представлен по умолчанию определенным классом Widget.

		При работе с формой мы обычно создаем экземпляр формы в представлении.

	Создание формы

		Создаем в файле forms.py

			from django import forms

			class NameForm(forms.Form):
			    your_name = forms.CharField(label='Your name', max_length=100)

		Экземпляр Form содержит метод is_valid(), который выполняет проверку всех полей формы

			form = ContactForm(data)
			form.is_valid()

		Если все данные правильные, это метод:

			вернет True

			добавит данные формы в атрибут cleaned_data

				form.cleaned_data

				Также вы можете напрямую обратиться к непроверенным данным через request.POST, но лучше использовать проверенные данные.

		После рендеринга наша форма будет выглядеть следующим образом:

			<label for="your_name">Your name: </label>
			<input id="your_name" type="text" name="your_name" maxlength="100">

			Тег <form> и кнопку отправки нужно добавить самостоятельно.

				<form action="/your-name/" method="post">
				    {% csrf_token %}
				    {{ form }}
				    <button type="submit" value="Submit" />
				</form>

			Все поля формы и их атрибуты будут добавлены в HTML из {{ form }} при рендеринге шаблона.

	Работа с формой в представлении

		def create(request):
		    if request.method == 'POST':
		        form = NameForm(request.POST)
		        if form.is_valid():
		            return HttpResponseRedirect('/thanks/')
		    else:
		        form = NameForm()

		    return render(request, 'name.html', {'form': form})

		Если в представление пришел GET запрос, будет создана пустая форма и добавлена в контекст шаблона для последующего рендеринга.

		Если форма отправлена через POST запрос, представление создаст форму с данными из запроса: form = NameForm(request.POST). Это называется привязать данные к форме.

	Связанные и не связанные с данными формы

		Незаполненная форма не содержит данных, привязанных к её полям и является не связанной.

		Заполненная форма содержит переданную информацию и, следовательно, может быть использована для проверки введённых данных и является связанной.

		Атрибут формы is_bound позволяет узнать связана форма с данными или нет.

	Виджеты

		Каждое поле формы содержит соответствующий класс Widget, который отвечает за создание HTML кода.

		В большинстве случаев поле уже содержит подходящий виджет. Например, по умолчанию поле CharField представлено виджетом TextInput, который создает тег <input type="text"> в HTML.

		Можно переопределить виджет для поля

			class ContactForm(forms.Form):
			    message = forms.CharField(widget=forms.Textarea)

	Настройки рендеринга формы

		{{ form.as_table }} - выведет поля в таблице

		{{ form.as_p }} - обернет поля в тег p

		{{ form.as_ul }} - выведет поля теге <ul>

	Рендеринг полей вручную

		# возвращает список ошибок, которые не привязаны к конкретному полю
		{{ form.non_field_errors }}

		<div class="fieldWrapper">
		    {{ form.message.errors }}
		    <label for="{{ form.message.id_for_label }}">Your message:</label>
		    {{ form.message }}
		</div>
		<div class="fieldWrapper">
		    {{ form.sender.errors }}
		    <label for="{{ form.sender.id_for_label }}">Your email address:</label>
		    {{ form.sender }}
		</div>

		Для более гибкой работы с ошибками можно делать так

			{% if form.message.errors %}
			    <ol>
			    {% for error in form.message.errors %}
			        <li><strong>{{ error|escape }}</strong></li>
			    {% endfor %}
			    </ol>
			{% endif %}

	Повторное использование шаблонов форм

		Сохраняем цикл по полям формы в отдельном шаблоне и подключаем его в другие шаблоны с помощью тега include

			form_snippet.html

				{% for field in form %}
				    <div class="fieldWrapper">
				        {{ field.errors }}
				        {{ field.label_tag }} {{ field }}
				    </div>
				{% endfor %}

			template_name.html

				{% include "form_snippet.html" %}

		Если объект формы, переданный в шаблон, имеет другое имя в контексте, вы можете создать для него псевдоним.

			{% include "form_snippet.html" with form=comment_form %}

	Наборы форм

		Позволяют работать с множеством форм на одной странице

			class ArticleForm(forms.Form):
				title = forms.CharField()
				pub_date = forms.DateField()

			# extra задает кол-во пустых форм
			# max_num ограничивает кол-во пустых форм
			# validate_max проверяет, что общее количество форм, без учета помеченных для удаления, не больше чем max_num 
			# (будет ошибка даже если количество инициализированных форм превышает max_num)
			# Независимо от validate_max, если количество форм превышает max_num на более чем 1000, будет ошибка валидации
			# validate_min проверяет, что общее количество форм, без учета помеченных для удаления, больше или равно min_num
			ArticleFormSet = formset_factory(ArticleForm, extra=2, max_num=1, validate_max=True, min_num=1 validate_min=True)

			formset = ArticleFormSet()
			for form in formset:
				print(form.as_table())

		Использование начальных данных с наборами форм

			formset = ArticleFormSet(
				initial=[
					{
						'title': 'Django is now open source',
			     		'pub_date': datetime.date.today(),
			     	}
				]
			)

		Проверка набора форм

			Набор форм обладает методом is_valid().

				formset = ArticleFormSet(data)
				formset.is_valid()

			Другие методы набора форм при проверке

				formset.errors
				formset.total_error_count()
				# изменились ли данные относительно начальных значений
				formset.has_changed()
				formset.total_form_count
				# возвращает количество предварительно заполненных форм в наборе,
				# а также используется для определения количества форм, обязательных для заполнения
				formset.initial_form_count

		Собственная проверка набора форм

			Для этого набор форм имеет метод clean.

				class BaseArticleFormSet(BaseFormSet):
					def clean(self):
						if any(self.errors):
							return

	Дополнительные возможности Django Form

		Если ваша форма будет использоваться для создания или редактирования объекта модели, вы можете использовать ModelForm.

	Стоп на Сортировка и удаление форм

	Модельные формы

		...

Управление файлами

	Django хранит файлы локально, используя настройки MEDIA_ROOT и MEDIA_URL.

		MEDIA_ROOT - абсолютный путь к каталогу, в котором хранятся медиа-файлы

			MEDIA_ROOT и STATIC_ROOT должны отличаться

		MEDIA_URL - путь, который указывает на каталог MEDIA_ROOT

			Нужен для использования в шаблонах.

			Если вы хотите использовать {{ MEDIA_URL }} в шаблонах, добавьте 'django.template.context_processors.media' в опцию 'context_processors' настройки TEMPLATES.

	Когда вы используете классы FileField или ImageField, Django предоставляет интерфейс программирования, чтобы открыть вам доступ к файлам.

		Аргумент upload_to говорит куда сохранять картинку или файл. При этом будет взять путь из MEDIA_ROOT, внутри него создана директория из upload_to и туда сохранен файл.

		class Car(models.Model):
		    name = models.CharField(max_length=255)
		    price = models.DecimalField(max_digits=5, decimal_places=2)
		    photo = models.ImageField(upload_to='cars')

		car.photo
		car.photo.name
		car.photo.path
		car.photo.url

	Файл сохраняется в базе данных как часть модели, поэтому фактическое название файла не может быть использовано до того момента, пока не будет сохранена модель, включающая его.

	Если вам вдруг понадобится создать объект File самостоятельно, проще всего использовать для этого указанный выше встроенный файловый объект языка Python:

		from django.core.files import File

		with open('/tmp/hello.world', 'w') as f:
			myfile = File(f)
			myfile.write('Hello World')

		Теперь у вас есть возможность использовать любой из атрибутов и методов стандартного класса File.

	Выбор места для хранения файлов задаётся в настройках DEFAULT_FILE_STORAGE.

	Хотя большую часть времени вам, скорее всего, будет достаточно объекта File (который осуществляет надлежащее хранение файлов), вы можете обращаться к файловой системе напрямую.

		from django.core.files.storage import default_storage
		from django.core.files.base import ContentFile

		path = default_storage.save('/path/to/file', ContentFile('new content'))

		default_storage.size(path)
		default_storage.open(path).read()
		default_storage.delete(path)
		default_storage.exists(path)

	Django поставляется со встроенным классом django.core.files.storage.FileSystemStorage, который реализует основное локальное файловое хранилище.

		К примеру, следующий код будет хранить загруженные файлы в /media/photos, игнорируя настройки MEDIA_ROOT.

		from django.db import models
		from django.core.files.storage import FileSystemStorage

		fs = FileSystemStorage(location='/media/photos')

		class Car(models.Model):
		    photo = models.ImageField(storage=fs)


Url-ы

	Two scoops of Django

		app_name/views.py

			class UpdateView(UpdateView):
				model = Tasting

		app_name/urls.py

			1.11

				urlpatterns = [
					path(
						route='update/',
						view=views.UpdateView.as_view(),
						name='update'
					)
				]

			2.2
			
				app_name = 'main'
				urlpatterns = [
					path(
						route='update/',
						view=views.UpdateView.as_view(),
						name='update'
					)
				]

		config/urls.py

			1.11

				urlpatterns = [
					path(
						route='app_name/', 
						include(
							'app_name.urls', 
							namespace='app_name'
						)
					),
				]

			2.2

				urlpatterns = [
					path(route='app_name/', include('app_name.urls'))
				]

		templates/app_name/index.html

			<form action="{% url 'app_name:update' %}" method='POST'>

Статика

	Описанное ниже подходит только для локальной разработки при DEBUG = True.

	Для production используем nginx.

	Убедитесь что django.contrib.staticfiles добавлено INSTALLED_APPS.

	STATIC_URL = '/static/'

		Путь до каталога со статическими файлами.

	STATIC_ROOT = os.path.join(PROJECT_ROOT, 'project_name/static')

		Абсолютный путь к каталогу, в который collectstatic соберет все статические файлы.

		Это должен быть пустой каталог, куда будут скопированы все статические файлы командой collectstatic.

		Вы должны создавать статические файлы в каталогах, которые будут найдены модулями поиска статических файлов. 

			По умолчанию это подкаталоги 'static/' в приложениях и каталоги, указанные в STATICFILES_DIRS.

	STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static')]

		Каталоги, которые проверяются на наличие статических файлов.

		Нужно для работы с общей статикой, которая не относится ни к одному из приложений.

	Сохраните статические файлы в каталоге static вашего приложения. 

		Например my_app/static/my_app/css

		Если после static не создать каталог my_app, то Django использует первый найденный по имени файл и, если есть файлы с одинаковым названием в разных приложениях, то не будет возможности использовать оба.

	Загрузим шаблонный тэг, который строит url для статики

		{% load static %}
		<img src="{% static "my_app/example.jpg" %}

Валидаторы

	Это функции для валидации значений, которые вешаются на поля модели.

	Обычно храняться в приложении в файле validators.py

Безопасность

	Защита от межсайтового скриптинга (XSS)

		XSS атаки позволяют вставить собственные JS скрипты в браузеры других пользователей и запустить их.

		Это достигается с помощью:

			Предложения пользователю нажать на какую-нибудь кнопку или ссылку.

			Добавить этот скрипт в куки при переходе пользователя на сайт злоумышленника.

		XSS атаки могут происходить из любого недоверенного источника данных, такого как куки или веб сервисы.

		Шаблоны Django экранируют специальные символы, которые обычно создают проблемы для HTML.

		Django не защищает от подобного кода: <style class={{ var }}>...</style>

			Если var содержит 'class1 onmouseover=javascript:func()', то это может вылиться в неавторизованный запуск JavaScript

	Защита от подделки межсайтового запроса (CSRF)

		CSRF атаки позволяют недобросовестному пользователю выполнять действия от имени другого пользователя, без ведома последнего или его согласия.

		Схема работы такая:

			Пользователь прошел аутентификация на сайте платежной системы.

			Пользователь окрыл новую вкладку в браузере и перешел на другой сайт (сайт злоумышленника).

			Сайт злоумышленника тайно сделал запрос от лица пользователя на сайт платежной системы и перевел деньги со счета пользователя на счет злоумышленника.

		CSRF защита проверяет метку с текущим временем в каждом POST запросе.

		Именно поэтому в каждой форме должен быть csrf token.

		При работе через HTTPS, CsrfViewMiddleware будет проверять, что заголовок HTTP Referer установлен на URL того же источника (включая поддомен и порт).

	Защита от внедрения SQL

		Внедрение SQL - это тип атаки, когда недобросовестный пользователь имеет возможность выполнить в базе данных определённый SQL запрос. 

		Результатом выполнения такого запроса может быть удаление или даже утечка данных.

		Такая атака может быть возможна из-за некорректной обработки входных данных, используемых в SQL-запросах.

		Для защиты от данного типа атак необходимо тщательно фильтровать входные параметры.

		Например для MySQL, требуется брать в кавычки все строковые параметры.

		По умолчанию за нас это делает orm, но об этом нужно знать и помнить если мы делаем сырые запросы.

		При использовании Django ORM созданный SQL запрос будет правильно экранирован соответствующим драйвером базы данных.

	Защита от скликивания

		Это тип атаки, когда вредоносный сайт оборачиваем другой сайт фо фрейм и пользователи могут совершать действия на этом сайте ничего не подозревая.

		Django предоставляет защиту от этой атаки в виде модуля X-Frame-Options, который, при использовании соответствующего браузера, может предотвратить отображение сайта внутри фрейма.

	SSL/HTTPS

		При отсутствии HTTPS злоумышленник имеет возможность перехватывать аутентификационные данные или любую другую информацию, передаваемую между клиентом и сервером.

		Настройте перенаправление HTTP запросов на HTTPS.

		Если браузер изначально подключается через HTTP, что характерно для большинства браузеров, есть возможность утечки существующих кук.

	Проверка заголовка хоста

		Клиент отправляет на север заголовок host.

		Поддельный заголовок Host может быть использован для атак CSRF, подмены кэша и для подмены ссылок в сообщениях электронной почты.

		Django использует заголовок Host, предоставляемый клиентом, для создания URL в определённых случаях. 

		Django проверяет этот заголовок относительно параметра конфигурации ALLOWED_HOSTS.

			Но если ваш код получает содержимое заголовка Host напрямую из request.META, то вы игнорируете эту защиту.

	Безопасность сессии

		Поддомены внутри сайта имеют возможность устанавливать куки на клиенте для всего домена.

		Это приводит к возможности управления сессией, если куки принимаются от поддоменов, которые не находятся под управлением доверенных пользователей.

		Например, атакующий может авторизоваться на good.example.com и получить достоверную сессию для своего аккаунта.

		Если у атакующего есть контроль над bad.example.com, он может использовать его для отправки своего ключа сессии вам, так как поддомену разрешено устанавливать куки для *.example.com. 

		Когда вы посетите good.example.com, вы будете авторизован как атакующий и можете непреднамеренно внести важные персональные данные (например, номер кредитной карты) в аккаунт атакующего.

	Контент, загружаемый пользователями

		Если ваш сайт принимает файлы, настоятельно советуем ограничить размер таких загрузок в конфигурации веб сервера для предотвращения атак на отказ сервиса (DOS).


Интерфейс администратора

	Нюансы интерфейс администратора

		response.context['cl'].queryset - доступ к списку сущности

		self.kwargs - доступ к GET параметрам, не работает в actions

		request.get_full_path() - позовляет получить полный путь запроса, вместе с GET параметрами

Shell

	Open pycharm terminal

	./manage.py shell

	from django.db import connection

	from product.models import Product

	Product.objects.count()

	connection.queries - show query to db

Debug toolbar

	pip install django-debug-toolbar

	INSTALLED_APPS = [
	    'debug_toolbar',
	]

	MIDDLEWARE = [
	    'debug_toolbar.middleware.DebugToolbarMiddleware',
	]

	mysite/urls.py ->

		if settings.DEBUG:
		    import debug_toolbar
		    urlpatterns = [
		        path('__debug__/', include(debug_toolbar.urls)),
		    ] + urlpatterns

	settings.py -> INTERNAL_IPS = ('127.0.0.1',)

    settings.py -> DEBUG -> True

	TEMPLATES = [
	    {
	        'DIRS': [os.path.join(BASE_DIR, 'templates')],
	    },
	]

	project -> create folder templates -> base.html

	app -> create folder templates/app_name -> template_name.html

Unit тесты

	Тестируют работу методов, функций и классов.

	Класс для теста должен наследоваться от from django.test import TestCase

	Метод setUp это встроенный метод тестирования, который позволяет создавать тестовые данные в бд в момент. Нужно потому что при прохождении тестов создается пустая бд.

	Именуем в формате PropertyAdminTests. Обратить внимание на то что во множественном числе - Tests.

	Именование делится на форматы:

		QuestionViewTests

		QuestionMethodTests

	Встроенный класс TestCase оборачивает каждый тест в транзакцию и отменяет её после выполнения теста, чтобы обеспечить изолированность тестов.

	Есть класс Client для тестов клиентской части приложения.

	Есть класс RequestFactory для использования в тестах объекта request.

	Нюансы

		Помнить, что при выполнении тестов создается ПУСТАЯ база данных.

		Если класс в котором написаны тесты наследуется от from django.test import TestCase, то при выполнении будет создана новая, пустая и временная база данных.

		Если класс в котором написаны тесты наследуется напрямую от unittest.TestCase (класс чистого python для тестирования), то при выполнении будет использована боевая база данных и это может иметь последствия.

		Помнить, что метод create_user возвращает хэшированный пароль и через него нельзя будет потом залогиниться. Поэтому можно сделать приватное св-во в методе setUp.

		Когда делаем логин и потом последующий запрос помнить, что нужно делать через клиент self.client.login, self.client.post

		Для тестирование кастомных actions в панели администратора используем:

			self.client.post(
	            reverse('admin:cards_productcard_changelist'),
	            {
	                'action': 'mark_cards_as_checked', 
	                '_selected_action': ProductCard.objects.values_list('pk', flat=True)
	            }
	        )

	    Если используем много баз данных, а для тестов должна создаваться одна, то можно при выполнении тестов переопределить DATABASES:

			if 'test' in sys.argv:
			    DATABASES = {
			        'default': {
			            'ENGINE': 'django.db.backends.mysql',
			            'NAME': 'magic',
			            'USER': 'root',
			            'PASSWORD': 'asdf1234',
			            'HOST': '127.0.0.1',
			            'PORT': '3306',
			            'OPTIONS': {
			            	'charset': 'utf8'
			                'init_command': 'SET default_storage_engine=INNODB',
			            }
			        },
			    }

		Работе тестового клиента может мешать debug_toolbar.

		При работе с тестовым клиентом если создаем суперпользователя, то лучше создавать его, как is_staff=True и is_superuser=True.

		При тестировании исключений один из варинтов такой:

			with self.assertRaises(ValidationError):
				# Если внутри этого метода будет выкинуто исключение ValidationError, то тест прошел
				self.helper.validate_product_card_image_indexes(index_list=[0, 1, 1])

		При работе с методом self.assertEqual(), первый аргумент это метод, который тестируем, а второй это значение, которое он должен вернуть

		Для создания общих данных доступных в каждом классе тесте нужно использовать метод setUpModule. Определяется без класса.

		Использовать bulk_create только в случаях, когда действительно много.

		При комментирование тестовых методов писать их в формате:

			"""
			Должен фильтровать queryset и возращать валидные карточки товара.

	        Валидные это те, у которых есть код 1с, бренд, шаблон у 
	        вида-типа и фотографии.
	        """

	        То есть пишем, что должен делать тестовый метод.

	    Каждый метод setUp наполняет базу своими уникальными объектами, которые не зависят от другого метода setUp. То есть если в одном создал 2 объекта, то в этом классе тестов будут доступны только эти два объекта при выборке всех.

	   	Лучше не использовать self в setUp, потому что если потом в методах теста обновляется объект, а мы берем его через self, то обновления не видны.

	   	Лучше дублировать наполнение данных в каждом методе setUp, потому что если выносить это на setUpModule, то можно запутаться + каждый метод setUp изолирован друг от друга и не вызывает проблем.

	   	Лучше разбивать тестирование одного метода на разные методы в тестах. 

	   		Например мы тестируем метод validate_product_card_image_indexes.

	   		Тесты к нему будут вынесены в отдельные методы, каждый из которых будет проверять один юз кейс: test_validate_product_card_image_indexes_with_same, test_validate_product_card_images_indexes_with_different и т.д. 

	   		Во первых один метод делает одно, а во вторых проще понять, где возникла ошибка если тесты упали.

	   	Из объекта Client можно получить текущего пользователя через result.wsgi_request.user

	   	'TEST': { 'CHARSET': 'utf8', 'COLLATION': 'utf8_general_ci',} - позволяет задать кодировку бд при выполнении тестов

	Команды

		self.client.login()

		self.assertEqual()

		self.assertQuerysetEqual()

		sefl.assertRaises(NameError)

		response = self.client.post(reverse('admin:user_invoice_add'), {'num': 'x23md'}) - делает пост запрос на нужный урл с нужными параметрами

		response.wsgi_request.user - выводит пользователя, который сделал запрос

		./manage.py test

		./manage.py test app_name/

Логгирование

	Логгирование от Two scoops of Django

		Делить логи на уровни.

		Использовать traceback при логгировании. logger.exception(e).

		В каждом новом модуле импортировать новый логгер, потому что если захочу поменять систему логирования в одном модуле не затрагивая другой, это не получится.

		Логи уровня INFO лучше писать в файл и хранить на диске, а уровня ERROR отправлять админам проекта на почту (по default в django).

	Если DEBUG равна True:

		django, который перенаправляет все сообщения уровня INFO и выше в консоль.

		Логгер py.warnings, который обрабатывает сообщения от warnings.warn(), отправляет их на консоль.

	Если DEBUG установлен в False:

		По умолчанию логгер django отравляет все сообщения уровня ERROR или CRITICAL в AdminEmailHandler.

	Подключение

		import logging

		logger = logging.getLogger(__name__)

		logger.error('Something went wrong!')

	Для настройки логгирования используется настройка LOGGING

		Если ключ disable_existing_loggers в параметре конфигурации LOGGING установлен в True (по умолчанию это так), тогда все логгеры стандартной конфигурации отключаются.

		Вместо этого, вы можете установить disable_existing_loggers в False и переопределить некоторые или все стандартные логгеры.

		Через параметр email_backend класса AdminEmailHandler, можно переопределить бекенд отправки email. По умолчанию используется экземпляр класса, указанного в EMAIL_BACKEND.

	Пример простой конфигурации

		LOGGING = {
		    'version': 1,
		    'disable_existing_loggers': False,
		    'handlers': {
		        'mail_admins': {
		            'level': 'ERROR',
		            'class': 'django.utils.log.AdminEmailHandler',
		            'email_backend': 'django.core.mail.backends.filebased.EmailBackend'
		        }
		    }
		}

Вливание новых данных на проект

	Сделали git pull

	Если есть изменения в requirements.txt, то обновили зависимости.

	Если есть изменения в моделях, то выполнили миграции.

	Если есть изменения в шаблонах, то выполнили collectstatic.

Перезапуск проекта

	кстати, одна из основных причин всякой магии - это кеш

	pyc - кеш виртуалной машины питона
	кеш, куда кладешь промежуточные значения расчета
	кеш, куда кладешь полученный ответ от API
	и т.п.
	еще как пример - если перезапустить не весь проект, а только, к примеру, gunicorn, без celery, можно до посинения искать, где ж ошибка
	т.к. код вроде новый, ты видишь, что новый и все в нем хорошо должно работать
	а в памяти висит процесс, исполняющий СТАРЫЙ код...
	
Книги

	Two Scoops of Django 1.11: Best Practices for the Django Web Framework.

	Django Design Patterns and Best Practices (Arun Ravindran).

Нюансы

	Декоратор для встроенных методов.

		Например для класса View и его метода get.

			def track_request_count(function_for_decorate):
			    def wrapper(self, request, *args, **kwargs):
			        return function_for_decorate(self, request, *args, **kwargs)
			    return wrapper

	При использовании прокси-модели нужно выполнить все операции миграции.

	Когда используем конструкции с нижним подчёркиванием. Например _('My offer'). Нужно подключать символ нижнего подчёркивания (_).

	При использовании методов has_change_permission и has_delete_permission их аргумент obj может быть None и его методы соответственно не доступны. Это происходит в том случае, когда мы загружаем страницу с выводом всех записей. Поэтому если мы переопределяем эти методы, то проверять obj. 

	Если в модели есть 2 поля с ForeignKey, основанных на одинаковых моделях, то к одному из полей нужно добавить аргумент related_name.

	Если используем шаблоны, то храним их в директории templates, которая в корне проекта. (почитать почему в tutorial)

	Для использования success_url с именованным урлом нужно использовать функцию reverse_lazy().

	Для корректной работы статики на локальной машине debug должен быть в True.

	Если нужно повторить админский редирект, когда объект не существует, то используем встроенную функцию _get_obj_does_not_exist_redirect. Её описание находится в django/django/contrib/admin/options.py

	До этого работало, а на следующий день перестало

		Почистить .pyc файлы

			find . -name "*.pyc" -delete

	Сообщения об ошибках

		Чтобы отправлялись сообщения об ошибках DEBUG должен быть в False и в ADMINS = [('Ilya', 'kaduk@gmail.com')] указана почта куда оптравлять ошибки.

	Старое значение формы

		У формы нельзя взять старое значение (только через базу).

	Использование last, first методов

		Не использовать неявные методы last, first и т.д. Лучше взять одну сущность по условию, например get(pk=3)

	Update

		При выполнение update, если обновляемое значение отличается от уже существующего, то затирает self.queryset, если нет, то возращает.

	Обработка ошибок в транзакциях

		@transaction.atomic
		def viewfunc(request):
		    create_parent()

		    try:
		        with transaction.atomic():
		            generate_relationships()
		    except IntegrityError:
		        handle_exception()

		    add_children()

		Если не написать with transaction.atomic() в блоке try: except, то будет ошибка, потому что generate_relationships() не выполниться и прервёт основную транзакцию

	Distinct с MySQL и values_list

		Отказывается работать без order_by.

		Поэтому пишем так:

			res = ProductCard.objects.filter(ode__isnull=False).order_by('code').distinct()

			И теперь можем использовать values_list

				res.values_list('code', flat=True)

	Создание условий для запросов с Q

		def collect_q_query_conditions(self, is_or_operator, conditions):
	        q_obj = Q()
	        for condition in conditions:
	            if is_or_operator:
	                q_obj |= Q(**{condition: conditions[condition]})
	            else:
	                q_obj &= Q(**{condition: conditions[condition]})
	        return q_obj

	Сравнение Q объектов

		Как один из вариантов сравнить стрковое представление объектов

		a = unicode(Q() | Q(images__isnull=False) | Q(has_invalid_images=True))
		
		b = unicode(Q() | Q(images__isnull=False) | Q(has_invalid_images=True))

		self.assertEqual(first=a, second=b)

	Debug сигналов и тасков

		При дебаге сигналов принты будут выводиться в run, потому что сигналы относятся к django.

		При дебаге тасков принты будут выводить в celery, потому что таски относятся к celery.

	Переопределение шаблонов в панели администратора

		Если написать просто {% block block_name %} my_code {% endblock %}, то будет отображаться только мой код.

		Чтобы исправить данную ситуацию, нужно добавить {{ block.super }}

			{% block block_name %} 

				my_code

				{{ block.super }}

			{% endblock %}

	Переопределение сохранения ImageField

		Для переопределения работы ImageField используем метод save и UploadedFile в модели.

		    def save(self, *args, **kwargs):
		        self.image = UploadedFile(
		            file=self.image,
		            name='{}.png'.format(
		                self.image.name
		            ),
		            content_type='image/png',
		            size=sys.getsizeof(self.image)
		        )

		        super(ProductCardImage, self).save()

	Разница между обычным открытием файла и через BytesIO

		Когда мы используем обычное открытие файла и записываем туда что то, то на диске создается файл с определенным содержимым.

		Объект BytesIO не связан с каким-либо реальным файлом на диске. Это всего лишь кусок оперативной памяти, который ведет себя как файл.

	Работа с тайм зоной.

		Если нужно получить время опираясь на локальное время (например время сервера), то нужно использовать встроенную функцию django.

		from django.utils.timezone import now

		now()

			Если в настройках проекта USE_TZ = True, то будет работать с указанным часовым поясом в параметре TIME_ZONE.

	Если после переопределения какого то параметра в settings.py все ломается

		В таком случае пишем тест и в нем выводим информативное сообщение.

		Это лучше чем писать кучу if-ов в settings.py

		В идеале перед каждый новым push-ом нужно прогонять тесты или это будет автоматом делать ci/cd.

	Перенос строки

		Если при построении условий не хватает символов в строке, то можно воспользоваться \ для переноса.

		    if cache.get(key='need_send_email') and \
                not cache.get(key='is_sent_email'):
            cache.set('is_sent_email', True)

            Желательно после окончания инструкции. В данном случае после and.

    Orm запросы внутри except c IntegrityError

    	Будут падать с ошибкой, потому что каждый запрос обёрнут в транзация а при IntegrityError происходит откат всех транзакций и поэтому все запросы будут падать с ошибкой:

    		TransactionManagementError("An error occurred in the current transaction. You can't execute queries until the end of the 'atomic' block.",)

Создание и настройка проекта

	virtualenv --python=//usr/bin/python3.6 name_venv

	. name_venv/bin/activate

	pip install django

	pip install psycopg2

	Меняем структуру проекта

		project_name
		├── config/
		│   ├── settings/
		|	|  		__init__.py
		|   |		local.py
		|	|		...
		│   ├── __init__.py
		│   ├── urls.py
		│   └── wsgi.py
		├── docs/
		├── project_name/
		│   ├── media/
		│   ├── products/
		│   ├── profiles/
		│   ├── ratings/
		│   ├── static/
		│   └── templates/
		├── .gitignore
		├── Makefile
		├── README.rst
		├── manage.py
		└── requirements.txt

		Для корректной работы меняем:

			manage.py

				os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

			local.py

				ROOT_URLCONF = 'config.urls'

				WSGI_APPLICATION = 'config.wsgi.application'

		Для запуска:

			./manage.py runserver --settings=config.settings.local
	

Развёртывание (docker + nginx + gunicorn + django)

	Local machine
	
		cd /etc

		sudo nano hosts

		Add 127.0.0.1 yetbetter

	Nginx (docker)

		docker run -p 80:80 --name nginx -v ~/nginx:/usr/share/nginx/html -d nginx

		docker exec -it container_name bash

			apt-get update

			apt-get install nano

			nano /etc/nginx/nginx.conf

				user  nginx;
				worker_processes  1;

				error_log  /var/log/nginx/error.log warn;
				pid        /var/run/nginx.pid;

				events {
				    worker_connections  1024;
				}

				http {
				    access_log  /var/log/nginx/access.log;

				    sendfile on;

				    keepalive_timeout 65;

				    upstream app_servers {
				        server 172.17.0.1:8000; - ip адрес докера на локальной машине (только через него можно достучаться)
				    }

				    server {
				        listen 80;
				        server_name yetbetter;

				        location / {
				            root /usr/share/nginx/html; - здесь должен быть путь к нормальной статики django (узнать) 
				            index index.html index.htm;
				            proxy_pass http://app_servers;
				            proxy_set_header Host $host;
				        }
				    }
				}

		http://yetbetter

	Gunicorn + Django (docker)

		docker pull ubuntu

		docker run -i -t -p 8000:8000 --name my_ubuntu ubuntu

		docker start my_ubuntu

		docker exec -it my_ubuntu bash

			apt-get update

			apt-get install -y python3-pip

			pip3 install virtualenv

			pip3 install virtualenvwrapper

			export WORKON_HOME=~/.virtualenvs

			VIRTUALENVWRAPPER_PYTHON='/usr/bin/python3'

			source /usr/local/bin/virtualenvwrapper.sh

			which python3

			mkvirtualenv -p /usr/bin/python3 venv_name

			workon venv_name

			pip3 install django

			cd /home

			mkdir /app

			django-admin startproject project_name

			pip3 install gunicorn

			cd django_project_name

			gunicorn -b 0.0.0.0:8000 project_name.wsgi



	