Не использовать protected и private методы, которые относятся к мозгам фреймворка, потому что их могут изменить и всё упадёт.

Если нужно например приложение на русском, английском, французском языке, то лучше использовать нижнее подчёркивание _('').

Не смешивать 2 вещи, которые предназначенны для разного. Например FormView и admin.ModelAdmin.

Если начал изворачиваться чтобы решить задачу (например использовать множественное наследование с разными по применению сущностями), то скорее всего неправильно выбрана реализация.

Не называть переменные data, value и подобными названиями.

Думать при создании реализации о её замене и расширении. Если не нужно лезть в 5 мест в коде для расширения, то значит всё хорошо, если нет, соответственно нет.

Называть методы, как можно более общими названиями.

По возможности нагружать работу базы. Например нужно посчитать кол-во записей. Можно взять все и использовать метод len(), но это не лучшее решение, потому что записей может быть много и эта проверка будет во многих места. Гораздо лучше использовать метод sql - SUM, которое сделает это гораздо быстрее.

Если не хватает того, что предоставляет django, то пользуемся методами для расширения. Если не хватает и методов для расширения, то только тогда изменяем реализацию самостоятельно.

Для расширения встроенных классов django использовать mixin-ы.

Не использовать mixin-ы для переопределения методов.

Если проверка чего-либо не может существовать без объекта, то это метод должен быть в классе на основе, которого создаётся объект. Например мы проверяем конкретный платеж на доступность с помощью метода is_payment_available и этот метод нужно вынести на уровень класса модели.

Если внутри функции вызываются другие функции и они помогают ей выполнить свою задачу, то эта функция делает одно действие. Если внутри функции вызываются другие функции и они выполняют другие действия (например функция обрабатывает запрос, а внутри неё функции отправляют уведомления пользователям), то это неверные функции, потому что они выполняют несколько действий.

Помнить о конкурентном доступе (состояние гонки). select_for_update, как один из вариантов решения. Для проверки:

	shell_1
		import time
		from django.db import transaction
		from deals.models import Offer
		with transaction.atomic():
		    obj = Offer.objects.select_for_update().get(pk=7)
		    time.sleep(10)

	shell_2
		import time
		from django.db import transaction
		from deals.models import Offer
		with transaction.atomic():
		    obj = Offer.objects.get(pk=7)
		    obj.save()

	Shell2 будет ждать пока не выполнится Shell1

При возникновении ошибок django, связанных с движком, смотрет в сторону значений переменных окружения, которые задаются в settings или local_settings. Так же смотреть всю страницу с ошибками в браузере.

При разработки или исправлении ошибки придумывать различные варианты решения. Например не заливается дамп базы данных, пробуем удалить базу, создать заново и залить.

Помнить о логировании событий и сигналах django.

При составлении запросов сначала придумываем на чистом sql (по схеме, которую я составил), а потом пишем на orm.

При ошибках в ядре делать трассировку и искать все возможные варианты.

check в postgres может очень сильно тормозить.

При оптимизации чего-либо сначала нужно обновить это, потом проверить и если всеравно работает медленно, то начать оптимизацию. Все это делается, потому что в обновлении уже может быть решение проблем с производительностью.

В django паттерн наблюдатель можно реализовать с помощью сигналов.

В django при работе с админкой помнить, что save_model это уже метод после проверки формы, поэтому вся логика для валидации должна быть в методе для работы с формой - get_form.  