Не использовать protected и private методы, которые относятся к мозгам фреймворка, потому что их могут изменить и всё упадёт.

Если нужно например приложение на русском, английском, французском языке, то лучше использовать нижнее подчёркивание _('').

Не смешивать 2 вещи, которые предназначенны для разного. Например FormView и admin.ModelAdmin.

Если начал изворачиваться чтобы решить задачу (например использовать множественное наследование с разными по применению сущностями), то скорее всего неправильно выбрана реализация.

Не называть переменные data, value и подобными названиями.

Думать при создании реализации о её замене и расширении. Если не нужно лезть в 5 мест в коде для расширения, то значит всё хорошо, если нет, соответственно нет.

Называть методы, как можно более общими названиями.

По возможности нагружать работу базы. Например нужно посчитать кол-во записей. Можно взять все и использовать метод len(), но это не лучшее решение, потому что записей может быть много и эта проверка будет во многих места. Гораздо лучше использовать метод sql - SUM, которое сделает это гораздо быстрее.

Если не хватает того, что предоставляет django, то пользуемся методами для расширения. Если не хватает и методов для расширения, то только тогда изменяем реализацию самостоятельно.

Для расширения встроенных классов django использовать mixin-ы.

Не использовать mixin-ы для переопределения методов.

Если проверка чего-либо не может существовать без объекта, то это метод должен быть в классе на основе, которого создаётся объект. Например мы проверяем конкретный платеж на доступность с помощью метода is_payment_available и этот метод нужно вынести на уровень класса модели.

Если внутри функции вызываются другие функции и они помогают ей выполнить свою задачу, то эта функция делает одно действие. Если внутри функции вызываются другие функции и они выполняют другие действия (например функция обрабатывает запрос, а внутри неё функции отправляют уведомления пользователям), то это неверные функции, потому что они выполняют несколько действий.

Помнить о конкурентном доступе (состояние гонки). select_for_update, как один из вариантов решения. Для проверки:

	shell_1
		import time
		from django.db import transaction
		from deals.models import Offer
		with transaction.atomic():
		    obj = Offer.objects.select_for_update().get(pk=7)
		    time.sleep(10)

	shell_2
		import time
		from django.db import transaction
		from deals.models import Offer
		with transaction.atomic():
		    obj = Offer.objects.get(pk=7)
		    obj.save()

	Shell2 будет ждать пока не выполнится Shell1

При возникновении ошибок django, связанных с движком, смотрет в сторону значений переменных окружения, которые задаются в settings или local_settings. Так же смотреть всю страницу с ошибками в браузере.

При разработки или исправлении ошибки придумывать различные варианты решения. Например не заливается дамп базы данных, пробуем удалить базу, создать заново и залить.

Помнить о логировании событий и сигналах django.

При составлении запросов сначала придумываем на чистом sql (по схеме, которую я составил), а потом пишем на orm.

При ошибках в ядре делать трассировку и искать все возможные варианты.

check в postgres может очень сильно тормозить.

При оптимизации чего-либо сначала нужно обновить это, потом проверить и если всеравно работает медленно, то начать оптимизацию. Все это делается, потому что в обновлении уже может быть решение проблем с производительностью.

В django паттерн наблюдатель можно реализовать с помощью сигналов.

В django при работе с админкой помнить, что save_model это уже метод после проверки формы, поэтому вся логика для валидации должна быть в методе для работы с формой - get_form.

При написании тестов лучше не отлавливать ошибки (например ObjectDoesNotExist), потому что тогда тест проходит успешно и другой разраб может подумать, что все хорошо. Лучше пусть падают с ошибкой.

Html сервера может приходить в запакованном формате (zip).

Если нужно протрассировать celery, то запускаем его в debug режиме.

При тестировании админки django можно проверять url после редиректа. Если вернуло на ту же страницу, то валидация сработала.

Прежде чем начинать решать задачу, подумать о том, как это можно сделать. В процессе раздумий перебирать те вещи, которые даёт язык или инструмент. Например задача: "Есть два списка. Значения из одного могут повторяться в другом. Как получить один список без повторяющихся значений?" - склеить 2 списка и преобразовать к set.

Если происходит непонятная хрень с pycharm или python, то можно попробовать почистить пики (file_name.pyc)

Если работаю с python 2 и типом данных unicode, то помнить, что везде, где используются русские символы строка должна начинаться с u''. Обычно если буквы u нет, то вылазить обшибка "UnicodeDecodeError 'ascii' codec can't decode byte 0xd0 in position 0: ordinal not in range(128)"

Название методов

	Пример

		Есть метод который валидирует индексы. На вход метод принимает список индексов. Соответственно он должен называться во множественном числе:

			def validate_indexes(index_list):
				pass

Возврат значений из методов

	Есть метод validate_indexes. Он либо выкидывает исключение, либо ничего не возращает (то есть None).

	Вопрос: он должен ничего не возращать (то есть None) или все-таки True?

	Ответ: если результат вызова где то потом используется, то должен возращать True, если нет, то может ничего не возвращать (то есть None).

Ansible

	Для управления конфигурацией.

Как написать красивое решение

	Выписываем все варианты работы того или иного функционала.

	Смотрим отдаленно от конкретной реализации, что и где можно использовать. Например здесь используем форму для валидации, а эту часть валидации сделаем с помощью выборки валидных данных из базы и их проверки.

Что лучше одна длинная цепочка из and/or if-ов или эти же if-ы отдельно?

	Если после if-а делается одно и то же действие, то лучше длинная цепочка. Нарпимер после каждого if-а выкидывается одно и тоже исключение с одинаковым текстом.

	Соответсвенно если действи после if-ов разные, то лучше их разбить по одному.