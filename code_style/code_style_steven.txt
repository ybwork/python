Оглавление

	Что это

	Переменные

	Операторы

	Методы

	Классы (стоп)

	Комментарии

Что это

	Руководство по написанию кода.

	Данное руководство представляет из себя выжимку из книги "Совершенный код" Стива Макконнелла.

Переменные

	Объявляйте непосредственно перед использованием.

	Имя должно полно и точно описывать сущность, представляемую переменной.

	Используйте каждую переменную только с единственной целью. (?)

	Не используйте магические числа и литералы, делайте константы.
	
	Старайтесь уменьшать область видимости переменной.

	Старайтесь уменьшать время жизни переменной (адекватно, а не плодить кучу других переменных)

	Переменные цикла инициализируйте как можно ближе к самому циклу.

	Группируйте связанные данные:

		# Правильно
		GetOldData(oldData, &numOldData); 
		totalOldData = Sum(oldData, numOldData); 
		PrintOldDataSummary(oldData, totalOldData, numOldData); 
		SaveOldDataSummary(totalOldData, numOldData);
		GetNewData(newData, &numNewData); 
		totalNewData = Sum(newData, numNewData); 
		PrintNewDataSummary(newData, totalNewData, numNewData); 
		SaveNewDataSummary(totalNewData, numNewData);

		# Неправильно 
		GetOldData(oldData, &numOldData); 
		GetNewData(newData, &numNewData); 
		totalOldData = Sum(oldData, numOldData); 
		totalNewData = Sum(newData, numNewData); 
		PrintOldDataSummary(oldData, totalOldData, numOldData); 
		PrintNewDataSummary(newData, totalNewData, numNewData); 
		SaveOldDataSummary(totalOldData, numOldData); 
		SaveNewDataSummary(totalNewData, numNewData);


	Используйте логические переменные:

		# Правильно
		isAllDataRead = (document.AtEndOfStream()) and (Not inputError)
		isLegalLineCount = (MIN_LINES <= lineCount) and (lineCount <= MAX_LINES)
	    if (isAllDataRead) And (isLegalLineCount) and (Not ErrorProcessing()):
	    	pass 

	    # Неправильно
	    if ( ( document.AtEndOfStream() ) and ( Not inputError ) ) and \ 
	        ( ( MIN_LINES <= lineCount ) and ( lineCount <= MAX_LINES ) ) and \ 
	        ( not ErrorProcessing() ): 
	            pass

	Именование

		Имя должно полно и точно описывать сущность.

		Имя должно чаще выражать "что" а не "как".

		Имя не должно быть слишком коротким, увидев такое, следует проверить как имя отражает сущность.

		Есть и исключения, например всякие индексы массивов, но лично я даю и им описательное имя.

		Имя не должно быть овер длинным (примерно до 20 символов).

		Спецификаторы имени указывайте в конце:

			# Правильно
			PRICE_AVG = ... 
			PRICE_MAX = ... 
			PRICE_FORMATTED = ...

			# Неправильно
			AVG_PRICE = ... 
			MAX_PRICE = ... 
			FORMATTED_PRICE = ...

	        как по мне - первый вариант лучше

		Избегайте использования "Num" - вносит неясность. Используйте вместо него count, index.

	Антонимы в именах

		begin/end
		first/last
		locked/unlocked
		min/max
		next/previous
		old/new
		opened/closed
		visible/invisible
		source/target
		source/destination
		up/down

	Относитесь с подозрением к временным переменным, возможно не раскрыта суть самой переменной и ее нужно переименовать.

	Булевы переменные должны предполагать использование true/false.

	Флаги лучше делайте утвердительными (if not notFound - плохая практика)

	Сокращение, если действительно необходимо.

	Удаляйте все гласные, не являющиеся первыми буквами имен.

	Удаляйте артикли и союзы, такие как and, or, the.

	Удаляйте бесполезные суффиксы: ing, ed.

	Проверяйте, чтобы смысл имени переменной в ходе сокращения не искажался
	используйте эти способы, пока не сократите имя каждой переменной до приемлемых размеров.

	Не сокращайте имена только на один символ.

	Используйте одни и те же варианты сокращения.

	Сокращайте имена так, чтобы их можно было произнести: xPos и needsComp намного лучше чем xPstn и ndsCmptg.

	Избегайте имена, имеющие похожие значения: input и inputValue или recordNum и numRecords. Эти имена в одном фрагменте кода не только плохо читаются, но и являются потенциальными источниками проблем и багов.

	Имена, имеющие разную суть, но похожее именование: clientRecs и clientReps.

	Избегайте имен, символы которых очень похожи.

Операторы

	Стараться не делать большую вложенность из if. Максимум одна.

	Если в коде много elif, то подумайте о полиморфизме.

	Пишите инициализирующий код непосредственно перед циклом while (true).

	Если нужен бесконечный цикл, подумайте, нужен ли он вам?

	Предпочитайте цикл for.

	Не используйте for, если while подходит лучше.

	Не играйтесь с итерируемым объектом при итерации по нему же, лучше итерируйтесь по поверхностной копии. (?)

	Не делайте лапшу из break.

	Очень рекомендую использовать в начале цикла проверки и делать continue.

	Предпочитайте осмысленные имена индексов именам типа "i", "j", "k".

	Не делайте циклы слишком длинными, циклы нужно видеть полностью, а не скроллить их.

	Ограничьте вложенность цикла тремя уровнями, если не удается, сделайте метод и вызывайте внутри цикла.

Методы

	Причины создания методов:

		снижение сложности

		формирование понятной промежуточной абстракции

		предотвращение дублирования кода

		поддержка наследования
		
		сокрытие очередности действий
		
		упрощение сложных булевых проверок
		
		повышение быстродействия за счет локализации кода в одном месте

		изоляция сложности
		
		сокрытие деталей реализации
		
		ограничение влияния изменений
		
		сокрытие глобальных данных
		
		создание центральных точек управления
		
		облегчение повторного использования кода
		
		выполнение специфического вида рефакторинга

	Типы связности:
	
		функциональная
		
			Самый сильный и лучший вид связности, потому что метод выполняет одну и только одну операцию.

				sin()
				erase_file()
				get_customer_name()

		последовательная

			Метод содержит операции, которые обязательно выполняются в определенном порядке, используют данные предыдущих этапов и не формируют в целом единую функцию.

			Разбейте такой метод на несколько методов, в обоих получайте необходимые данные из другого метода, тогда будет функциональная связность.

		коммуникационная

			Операции в методе используют одни и те же данные и не связаны между собой.
			
			Разделите код на несколько методов, вызовите их вместо вызова одного метода.
	
		временная

			Операции объединяются в метод на основании выполнения в один интервал времени:

				startup()
				shutdown()
				complete_new_employee()

			Проблема в том что в таких методах много разнообразного кода, в таком методе лучше ничего не выполнять непосредственно, а вызывать другие методы.
	
		процедурная

			Операции выполняются в определенном порядке.
			
			Поместить разные операции в разные методы, корректно переименовать исходный метод.
	
		логическая

			Выбор операции в методе зависит от флага, переданного в метод.
			
			Разбейте метод на несколько методов и вызывайте нужный в зависимости от ситуации. 

			Исключение это например метод обработки событий, получает событие и вызывает другой метод, при этом сам не содержит операций.

		случайная

			Метод выполняет совершенно разнообразные операции.

			Нужно заново проектировать и кодировать удачные имена методов.

	Описывайте все, что метод выполняет
	
	Избегайте невыразительных и неоднозначных глаголов, например:

		handle_calculation()
		process_input()

	Удачно используйте антонимы:

		add/remove
		begin/end
		create/destroy
		first/last
		get/put
		get/set
		increment/decrement
		insert/delete
		lock/unlock
		min/max
		next/previous
		old/new
		open/close
		show/hide
		source/target
		start/stop
		up/down

	Параметры методов

		Используйте все параметры.

		Не используйте параметры метода в качестве рабочих переменных. ?

		Ограничивайте число параметров метода, по опыту знаю, больше шести уже мракобесие.
		
		Передавайте в метод те переменные или объекты, которые нужны ему для поддержания абстракции интерфейса.

		Чаще используйте именованные параметры когда это возможно.

	Рекурсия

		Убедитесь что она вам действительно нужна.

		Убедитесь что рекурсия остановится.

		Избегайте рекурсию с использованием нескольких методов.
		
		Следите за числом вызовов.

		Если есть возможность, используйте циклы вместо рекурсии.

Классы

	Причины создания классов

		моделирование объектов реального мира

		моделирование абстрактных объектов

		снижение сложности

		изоляция сложности

		сокрытие деталей реализации

		ограничение влияния изменений

		сокрытие глобальных данных

		упрощение передачи параметров в методы

		создание центральных точек управления

		облегчение повторного использования кода

		упаковка родственных операций

		выполнение специфического вида рефакторинга

	Выражайте в интерфейсе класса согласованный уровень абстракции.

	Убедитесь что вы понимаете, реализацией какой абстракции является класс.

	Убирайте постороннюю информацию в другие классы.

	Не включайте в класс открытые члены, плохо согласующиеся с абстракцией интерфейса.

	Рассматривайте абстракцию и связность вместе.

	Минимизируйте доступность классов и их членов (protected, private).

	Не делайте данные-члены открытыми.

	Не включайте в интерфейс класса закрытые детали реализации.

	Не делайте предположений о клиентах класса.

	Не делайте метод открытым лишь потому, что он использует только открытые методы.

	Цените легкость кода выше, чем удобство его написания.

	Минимизируйте доступность классов и их членов.

	С подозрением относитесь к классам, которые переопределяют метод, оставляя его пустым
	это неудачно спроектированный класс.

	Подумайте как изменить базовый класс.

	Избегайте многоуровневых иерархий наследования.

	Минимизируйте сотрудничество класса с другими классами.

Комментарии

	Не делайте причудливое форматирование комментариев, это трудно сопровождать.

	Бесполезные, не относящиеся к коду комментарии не нужны.

	Не повторяйте код в комментах.

	Описывайте уровень проблемы, а не решения.

	Описывайте ошибки или недокументируемые возможности языка/среды/библиотеки.

	Описывайте причины, почему нарушен хороший стиль программирования.

	Описывайте модуль, в чем конкретно назначение модуля, кратко что содержит, без излишних деталей.

	Описывайте как работает класс, подход к проектированию, альтернативные варианты, если они были, ограничения класса, пара слов об интерфейсе класса.

	Описывайте что делает метод два, три предложения максимум.