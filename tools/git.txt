Оглавление

	Что это

	Настройка

	SSH

	Git flow

	Merge request

	Rebase

	Commit

	Команды

	Gitignore

Что это

	Система контроля версий

Настройка

	sudo apt update

	sudo apt install git

	git --version

	git config --global user.name "Your Name"

	git config --global user.email "youremail@domain.com"

	git config --list

SSH

	Позволяет делать push без пароля.

	cd ~/.ssh

	ls

	Если не видим файлы id_dsa и id_dsa.pu, то создаём - ssh-keygen (или команда указанная в доке github/gitlab)

	Если видим файлы, то открываем id_rsa.pub 

	Копируем всё содержимое 

	Переходим в github/gitlab -> settings -> ssh keys -> add ssh key

	Вставляем скопированное в поле для ключа и нажимаем создать

Основы работы

	Создаём удалённый репозиторий.

	Клонируем удалённый репозиторий на локальную машину.

		git clone git@gitlab0.km-union.ru:kaduk_ia/marketplace.git

	Теперь имя репозитория на локальной машине - origin.

	Для каждой новой фичи создаём отдельную ветку.

		git checkout -b name_branch

	Делаем коммит на каждое небольшое изменение.

		git status

		git add .

		git commit -m "Overview commit"

	Остаёмся на этой же ветке и заливаем код с фичёй на удалённый репозиторий.

		git push (зальёт в репозиторий ветку на которой сейчас находимся)

	Заходим на удалённый репозиторий и создаём merge или pull request.

	Создаём новую ветку и продолжаем работать.

	Если следующая задача связана с предыдущей, то либо ждём пока проверят код или договариваемся о том как работать дальше.

	Когда код проверили и сделали merge, переходим на ветку master и забираем изменения из удалённого репозитория.

		git pull

	Если на удалённом репозитории возникли конфликты при merge, то выясняем на какой ветке и вытаскиваем её из того что спулили.

		git checkout -r (показывает все ветки на удалённом репозитории)

		git checkout name_branch (заново создаёт ветку, такую же, как и в удалённом репозитории)

		git merge name_branch

	Решаем конфликты.

	Делаем коммит.

	Удаляем ветку в слиянии с которой был конфликт.

		git branch -d branch_name

	Заливаем в мастер.

		git push

Git flow

	Это модель управления ветками.

	Есть 2 основные ветки master и develop.

	В мастер содержиться тот же код, что и в рабочей версии продукта.

	Вся работа делается в ветке develop.

	Во время работы на основе develop создаются так называемые feature-ветки. Их может быть неограниченное количество.

	Закончив работу на feature-ветке, вы сливаете ее с develop.

	Если вы довольны текущей версией, но хотите продолжить работу, создается ветка release, куда перемещается текущая версия develop с новыми фичами. Правка багов будет происходить на этой же ветке.

	Когда с веткой release покончено, время слить ее в master и продолжить работу с develop.

Merge request

	создаём ветку

	делаем коммит

	пушим ветку

	в gitlab или github делаем merge/pull request

	называем ветку и делаем коммиты на английском

	при создании merge/pull request заголовок называем в формате "Исправляет что/Добавляет новый функционал"

Rebase

	Когда создал merge request и продолжил делать коммиты на ветке events, git не видит коммиты после merge request. Чтобы исправить это нужно:

	Сделать коммит на ветке events

	Переключиться на ветку master

	Сделать pull - git pull origin master

	Переключиться на ветку events

	Сделать rebase - git rebase master - добавляет коммиты, которые делались после merge request в ветку master

	Остаться на ветке events

	Сделать push force - git push --force

	Если после review есть ошибки, продолжить исправлять их на ветке events

Commit

	Правила ЭлонСофт:

		Точка в конце не нужна

		Должен называться по форме refactor subsystem X for readability

	Правила КМ:

		В процессе работы делаем микрокоммиты

		Если микрокоммиты относятся к одной задачи, то их можно схлопнуть в один, а потом запущить 

		В заголовке пишем название задачи. Например "Доработка инициализации виджетов Retail Rocket в корзине refs #17310"

		#17310 - это идентификатор задачи

		В рамках одного финального коммита может быть решено много задач. В таком случае мы перечисляем id задач через запятую. Например "...refs #17310, #17311, #17312"

		После заголовка делаем отступ в одну строку и если нужно описываем что конкретно было сделано. Например:

			Доработка инициализации виджетов Retail Rocket в корзине refs #17310

			- изменил отправку события showed_message_box только родителю
			
			- завязался на это событие

		Не добавлять в redmine задачи подобные этим "Создание моделей, оформление въюх и т.д."

Команды

	git branch - показывает все ветки

	git checkout -b name_branch - создаёт ветку и переключает на неё	

	git branch name_branch - создаёт ветку

	git checkout - переключает на ветку

	git branch -v - показывает последний коммит на ветке

	git branch --merged - посмотреть те ветки, которые слил с текущей

	git branch --no-merged - посмотреть те ветки, которые пока ещё не слили в текущую ветку

	git branch -d - удалить ветку если слил всё в мастер

	git branch -D - удалить ветку если не слил всё в мастер, но нужно удалить

	git merge name_branch - делаем с той ветки на которую хотим залить, а имя должно быть той ветки, которую сливаем

	git push name_repo name_branch - заливает данные в репозиторий, имя ветки может быть любое, в том числе и то на которой я сейчас нахожусь

	git log - просмотр коммитов
git branch --set-upstream-to=mp/deal deal

	git clone name_repo - клонирует уже существующий репозиторий

	git remote add short_name_repo link_on_repo - привязывает ссылку репозитория к короткому названию, через которое потом можно обращаться

	git remote -v - показывает привязанные репозитории

	git rebase master - добавляет коммиты, которые делались после merge request в ветку master

	git push --force

	git config --list

	git config user.name

	git reset - сбрасывает все изменения, которые были добавлены с помощью команды git add

	git commit --amend - добавляет существующие изменения в последний коммит (если запушил, то не использовать)

	git reset --hard HEAD^ - удаляет последний коммит

	git branch --set-upstream-to=mp/deal deal - связывает локальную ветку и веткой из репозитория (используется для пула после hard reset)

Gitignore

    type nul > .gitignore (создали файл .gitignore в windows)

    git rm -r --cached .idea (исключаем папку/файл из репозитория, если она там есть)

    добавили в файл .gitignore, то что нужно игнорировать (.idea)