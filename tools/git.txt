Оглавление

	Что это

	Настройка

	SSH

	Git flow

	Merge request

	Rebase

	Commit

	Команды

	Gitignore

	Пустые директории

	Тэги

	Загрузка репозиториев через requirements.txt

	Для работы на production

	Нюансы

Что это

	Система контроля версий

Настройка

	sudo apt update

	sudo apt install git

	git --version

	git config --global user.name "Your Name"

	git config --global user.email "youremail@domain.com"

	git config --list

SSH

	Позволяет делать push без пароля.

	cd ~/.ssh

	ls

	Если не видим файлы id_dsa и id_dsa.pu, то создаём - ssh-keygen (или команда указанная в доке github/gitlab)

	Если видим файлы, то открываем id_rsa.pub 

	Копируем всё содержимое 

	Переходим в github/gitlab -> settings -> ssh keys -> add ssh key

	Вставляем скопированное в поле для ключа и нажимаем создать

Основы работы

	Создаём удалённый репозиторий.

	Клонируем удалённый репозиторий на локальную машину.

		git clone git@gitlab0.km-union.ru:kaduk_ia/marketplace.git

	Теперь имя репозитория на локальной машине - origin.

	Для каждой новой фичи создаём отдельную ветку.

		git checkout -b name_branch

	Делаем коммит на каждое небольшое изменение.

		git status

		git add .

		git commit -m "Overview commit"

	Остаёмся на этой же ветке и заливаем код с фичёй на удалённый репозиторий.

		git push (зальёт в репозиторий ветку на которой сейчас находимся)

	Заходим на удалённый репозиторий и создаём merge или pull request.

	Создаём новую ветку и продолжаем работать.

	Если следующая задача связана с предыдущей, то либо ждём пока проверят код или договариваемся о том как работать дальше.

	Когда код проверили и сделали merge, переходим на ветку master и забираем изменения из удалённого репозитория.

		git pull

	Если на удалённом репозитории возникли конфликты при merge, то выясняем на какой ветке и вытаскиваем её из того что спулили.

		git branch -r (показывает все ветки на удалённом репозитории)

		git checkout name_branch (заново создаёт ветку, такую же, как и в удалённом репозитории)

		или

		git checkout --track origin/deal_start - позволяет вытащить ветку из удалённого репозитория, если привязано несколько

		git merge name_branch

	Решаем конфликты.

	Делаем коммит.

	Удаляем ветку в слиянии с которой был конфликт.

		git branch -d branch_name

	Заливаем в мастер.

		git push

Git flow

	Это модель управления ветками.

	Есть 2 основные ветки master и develop.

	В мастер содержиться тот же код, что и в рабочей версии продукта.

	Вся работа делается в ветке develop.

	Во время работы на основе develop создаются так называемые feature-ветки. Их может быть неограниченное количество.

	Закончив работу на feature-ветке, вы сливаете ее с develop.

	Если вы довольны текущей версией, но хотите продолжить работу, создается ветка release, куда перемещается текущая версия develop с новыми фичами. Правка багов будет происходить на этой же ветке.

	Когда с веткой release покончено, время слить ее в master и продолжить работу с develop.

Merge request

	создаём ветку

	делаем коммит

	пушим ветку

	в gitlab или github делаем merge/pull request

	называем ветку и делаем коммиты на английском

	при создании merge/pull request заголовок называем в формате "Исправляет что/Добавляет новый функционал"

	каждая ветка должна быть рабочей и иметь то состояние кода, которое было. Вплоть до миграций и версии django.

Rebase

	Когда создал merge request и продолжил делать коммиты на ветке events, git не видит коммиты после merge request. Чтобы исправить это нужно:

	Сделать коммит на ветке events

	Переключиться на ветку master

	Сделать pull - git pull origin master

	Переключиться на ветку events

	Сделать rebase - git rebase master - добавляет коммиты, которые делались после merge request в ветку master

	Остаться на ветке events

	Сделать push force - git push --force

	Если после review есть ошибки, продолжить исправлять их на ветке events

Commit

	Правила ЭлонСофт:

		Точка в конце не нужна

		Должен называться по форме refactor subsystem X for readability

	Правила КМ:

		В процессе работы делаем микрокоммиты

		Если микрокоммиты относятся к одной задачи, то их можно схлопнуть в один, а потом запущить 

		В заголовке пишем название задачи. Например "Доработка инициализации виджетов Retail Rocket в корзине refs #17310"

		#17310 - это идентификатор задачи

		В рамках одного финального коммита может быть решено много задач. В таком случае мы перечисляем id задач через запятую. Например "...refs #17310, #17311, #17312"

		После заголовка делаем отступ в одну строку и если нужно описываем что конкретно было сделано. Например:

			Доработка инициализации виджетов Retail Rocket в корзине refs #17310

			- изменил отправку события showed_message_box только родителю
			
			- завязался на это событие

		Не добавлять в redmine задачи подобные этим "Создание моделей, оформление въюх и т.д."

		Если новый код добавляет функционал и этих добавлений много, то пишем:

			"Небольшие изменения refs #17310


				- сделал то то
				- добавил то то
			"

		Если новый код добавляет функционал и это добавление одно, то пишем:

			"Добавил то то refs #17310"

		Если новый код исправляет что то и этих исправлений много, то пишем:

			"Bug fix refs #17310


				- исправил то то
			"
		
		Если новый код добавляет функционал и это добавление одно, то пишем:

			"Bug fix: исправил то то refs #17310"

Команды

	Можно добавить в один коммит например один файл из трех, а другие два добавить в другой коммит. Узнать как.



	git branch - показывает все ветки

	git checkout -b name_branch - создаёт ветку и переключает на неё	

	git branch name_branch - создаёт ветку

	git checkout name_branch - переключает на ветку

	git branch -v - показывает последний коммит на ветке

	git branch --merged - посмотреть те ветки, которые слил с текущей

	git branch --no-merged - посмотреть те ветки, которые пока ещё не слили в текущую ветку

	git branch -d - удалить ветку если слил всё в мастер

	git branch -D - удалить ветку если не слил всё в мастер, но нужно удалить

	git merge name_branch - делаем на той ветки в которую хотим залить, а имя должно быть той ветки, которую вливаем

	git push name_repo name_branch - заливает данные в репозиторий, имя ветки может быть любое, в том числе и то на которой я сейчас нахожусь

	git log - просмотр коммитов

	git branch --set-upstream-to=mp/deal deal

	git clone name_repo - клонирует уже существующий репозиторий

	git remote add short_name_repo link_on_repo - привязывает ссылку репозитория к короткому названию, через которое потом можно обращаться

	git remote -v - показывает привязанные репозитории

	git rebase master - добавляет коммиты, которые делались после merge request в ветку master

	git push --force

	git config --list

	git config user.name

	git reset - сбрасывает все изменения, которые были добавлены с помощью команды git add

	git commit --amend - добавляет существующие изменения в последний коммит и позволяет изменить сообщение коммита (если запушил, то не использовать)

	git remote set-url origin git@gitlab0.km-union.ru:python/magic.git - задает url для origin репозитория

	git reset --hard HEAD^ - удаляет последний коммит на текущей ветки

	git branch --set-upstream-to=mp/deal deal - связывает локальную ветку с веткой из репозитория (используется для пула после hard reset)

	git push --set-upstream origin all_offers - заливает в репозиторий новый код, который был сделан на новой локальной ветке и связывает эту ветку с веткой в удалённом репозитории

	git stash - прячет и сохраняет все изменения рабочей области и возвращет состояние к последнему коммиту

	git stash apply - применяет спрятанные изменения (если есть конфликты всеравно применит и их нужно будет решить)

	git stash save "name_stash" - именованное прятание

	git stash list - выводит все стэши

	git stash apply stash@{n} - применяет стэш с конкретным именем

	git stash pop stash@{n} - применяет и удаляет стэш с конкретным именем

	git stash clear - чистит весь стэш

	git branch -r - показывает связанные ветки на удалённом репозитории

	git checkout hash_code_commit - переключает на нужный коммит

	git reflog - показывает всю историю внутри гита

	git checkout deal_start
	git rebase deal_tmp - перемещает все коммиты с deal_tmp в deal_start
	Если возникли ошибки, то исправляем их, выполняем только команду git add . и выполняем git rebase --continue

	git log --all - выводит все коммиты (для просмотра мотать стрелками клавы вниз)

	git reset --soft HEAD^ - удаляет последний коммит, но оставляет все изменения

	git branch -m new_name - переименовывает ветку

	git branch -f - ...

	git fetch --all --prune - позволяет удалить устаревшие ветки, которые лежат в слепке веток удаленного репозитория

	git checkout --track origin/deal_start - позволяет вытащить ветку из удалённого репозитория, если привязано несколько

	git remote rm name_repo - удаляет привязанный репозиторий

	git diff - показывает полный список сделанных изменений если еще не было коммита 

	git diff HEAD^ - показывает полный список сделанных изменений сравнивая последний коммит с предыдущим (за это отвечает ^, если ^^, то сравнивает последний с предыдущими двумя и т.д. Можно написать HEAD~3, чтобы не писаь много ^)

	git rebase -i HEAD~3 - позволяет схлопнуть 3 коммита в один

		Открывается терминал

			Указываем какие коммиты удалить, а какие оставить

				drop 46e1e67 Исправил скорость поиска по всем заявкам
				drop b3f4ac0 Исправил скорость поиска по всем заявкам refs #18207
				pick a7f3fb5 Исправил скорость поиска по всем заявкам refs #18207

	Могут возникнуть ошибки. Если так, то исправляем их и:

		git rebase --continue

	Дальше делаем git push и скорее всего получаем ошибку

		! [rejected]        master -> master (non-fast-forward)
		error: failed to push some refs to 'git@gitlab0.km-union.ru:php/service.git'
		hint: Updates were rejected because the tip of your current branch is behind
		hint: its remote counterpart. Integrate the remote changes (e.g.
		hint: 'git pull ...') before pushing again.
		hint: See the 'Note about fast-forwards' in 'git push --help' for details.

	Эта обшика происходит, потому что у нас разные история гита, вызванная rebase.

	Чтобы это исправить делаем:

		git push --force

	git tag - выводит список имеющихся тэгов

Gitignore

    type nul > .gitignore (создали файл .gitignore в windows)

    git rm -r --cached .idea (исключаем папку/файл из репозитория, если она там есть)

    добавили в файл .gitignore, то что нужно игнорировать (.idea)

Пустые директории

	Под gitignore не попадают пустые директории.

	Если возникает ситуация, когда нам нужно оставить пустую директорию, то можно положить туда файл .gitkeep

Тэги

	Git имеет возможность помечать (tag) определённые моменты в истории как важные.

	Как правило, эта функциональность используется для отметки моментов выпуска версий (v1.0).

	git tag - выводит список имеющихся тэгов

Загрузка репозиториев через requirements.txt

	Чтобы установить нужную часть кода в качестве зависимости проекта, добавляем в requirements.txt следующую ссылку:

		git+ssh://git.example.com/MyProject#egg=MyProject

		Также можно указать тэг

			git+ssh://git.example.com/MyProject@v1.0#egg=MyProject

			Он задается через собаку

			С помощью #egg=MyProject явно указывается имя проекта.

Для работы на production

	magic/
	tasks.py
	models.py
	...


	git status

		tasks
		models


	git stash
	git stash apply

	vim tasks...
	vim models...
	vim my

	git checkout -- my

	vim tasks...

	git reset --hard
	# git reset == git reset --soft
	git stash pop

Нюансы

	Если не применяются изменения в .gitignore, то: 

		git rm -r --cached .

		git add .

		git commit -m "..."

	Для того, чтобы сохранить пустую директорию (а гит её не сохраняет) можно добавить в нее файл .gitkeep

	Если нужны изменения, а merge request не применили, то можно создать новую ветку от production и смержить в нее ветку с merge request и сделать всю необходимую работу.