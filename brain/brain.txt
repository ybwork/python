Оглавление

	Как подходить к решению задачи

	Как подходить к исправлению ошибки

	Как составлять запрос

	Как выбирать иструмент

	Зачем нужны паттерны

	Советы

Как подходить к решению задачи

	Понимаем задачу

		Если могу описать её простыми словами, значит понял.

	Описываем задачу

		Простыми словами.

	Декомпозируем задачу

		То есть разбиваем её на более мелкие задачи.

		Если это мелкая задача, то переходим к следующему этапу.

	Продумываем все возможные варианты использования (use cases) для каждой задачи

	Выстроить порядок выполнения задач

		Некоторые задачи нельзя полноценно выполнить, потому что они зависят от готовности других. 

		Например нельзя выполнить задачу "продумать новую логику для системы синхронизации" пока не выполнена задача "изучить существующую логику системы синхронизации".
	
	Придумываем решение каждой задачи в рамках простых вещей

		Например пользователь звонит в магазин и спрашивает о наличии товара. Ему сообщают, что товара сейчас нет и перезвонят, когда появится.

			Этот пример описывает в рамках простых вещей такое понятие, как ассинхронность.

		Если задача не предполагает конкретного алгоритма решения, то не продумываем

			Например "Найти текущее место синхронизации дерева каталогов" или "Разобрать правила синхронизации дерева каталогов"

		Если для того, чтобы придумать решение нужно выполнить задачу по изучению уже существующего функционала, то сначал выполняем её, а потом уже переходим к продумыванию решения.

	Придумываем решение каждой задачи в рамках кода

		Помним о принципах SOLID, DRY, выделении бизнес логики, слабой связанности, паттернах.

		Если задача не предполагает конкретного алгоритма решения, то не продумываем

			Например "Найти текущее место синхронизации дерева каталогов" или "Разобрать правила синхронизации дерева каталогов"

	Продумываем все возможные варианты проверки правильности выполнения задачи

	Выбираем инструмент, который решает каждую задачу

		Если это работа с массивами данных, то выбираем аллгоритм.

	Пишем тест на основе юз кейса

	Пишем код на основе юз кейса

Как подходить к исправлению ошибки

	Внимательно читаем ошибку.

	Пытаемся понять, в чем может быть причина.

	Придумываем, как мы её исправим.

	Придумываем варианты проверки правильности исрпавления.

	Исправляем.

	Если не поняли в чем может быть причина, то идём гуглить описание ошибки.

	Если нагуглили правильное решение, то обязательно его разобрали и поняли прежде чем применить.

Как проектировать бд

	На основани существительных из use_cases определяем сущности.

	Определяем поля каждой сущности.

	Выстраиваем связи на основании нормальных форм

		Имеет ввиду один к одному, один ко многим и т.д.

		Помним о целостности данных, которую обеспечивают foreign_key и cascade.

	На основании запросов задаем индексы.

	Нюансы

		Поля, где хранятся id лучше называть с постфиксом id. Например sender_id, потому что так сразу понятно, что за значение находится в поле.

Как составлять запрос

	Определяем какие поля нужно выбрать.

	Определяем таблицы в которых хранятся нужные нам поля.

	Определяем условие по которому нужно сделать выборку.

	Определям с мощью чего мы можем достигнуть нужный результат (соединение таблиц, агрегация, группировка, подзапросы).

		Что
			
			name, products

		Откуда

			users, products

		Как получить

			Соединение

				JOIN

			Подзапрос

			Группировка

				Объединяет значения в одну строку при совпадении значений в столбцах.

			Агрегация

				MIN, MAX, AVG, COUNT
			
		Условие

			Подзапрос

			Группировка

			Агрегация

	Формат:

		SELECT
			name,
			car
		FROM
			users
		JOIN
			cars
		WHERE
			...

Как выбирать иструмент

	Чем от меньше кол-ва кода сторонних библиотек и их багов я завишу, тем лучше.

Зачем нужны паттерны

	Каждый паттерн решает определённую задачу.

	Большая часть паттернов уже используется во фреймворке.

	Знание паттернов позволяет сделать правильный выбор при решении той или иной задачи.

Советы

	Не использовать protected и private методы, которые относятся к мозгам фреймворка, потому что их могут изменить и всё упадёт.

	Не смешивать 2 вещи, которые предназначенны для разного. Например FormView и admin.ModelAdmin.

	Если начал изворачиваться чтобы решить задачу (например использовать множественное наследование с разными по применению сущностями), то скорее всего неправильно выбрана реализация.

	Не называть переменные data, value и подобными названиями.

	Думать при создании реализации о её замене и расширении. Если не нужно лезть в 5 мест в коде для расширения, то значит всё хорошо, если нет, соответственно нет.

	Называть методы, как можно более общими названиями.

	По возможности нагружать работу базы. Например нужно посчитать кол-во записей. Можно взять все и использовать метод len(), но это не лучшее решение, потому что записей может быть много и эта проверка будет во многих места. Гораздо лучше использовать метод sql - SUM, которое сделает это гораздо быстрее.

	Для расширения встроенных классов можно использовать классы с общим кодом.	

	Если проверка чего-либо не может существовать без объекта, то это метод должен быть в классе на основе, которого создаётся объект. Например мы проверяем конкретный платеж на доступность с помощью метода is_payment_available и этот метод нужно вынести на уровень класса модели.

	Если внутри функции вызываются другие функции и они помогают ей выполнить свою задачу, то эта функция делает одно действие. Если внутри функции вызываются другие функции и они выполняют другие действия (например функция обрабатывает запрос, а внутри неё функции отправляют уведомления пользователям), то это неверные функции, потому что они выполняют несколько действий.

	Помнить о конкурентном доступе (состояние гонки). select_for_update, как один из вариантов решения. Для проверки:

		shell_1
			import time
			from django.db import transaction
			from deals.models import Offer
			with transaction.atomic():
			    obj = Offer.objects.select_for_update().get(pk=7)
			    time.sleep(10)

		shell_2
			import time
			from django.db import transaction
			from deals.models import Offer
			with transaction.atomic():
			    obj = Offer.objects.get(pk=7)
			    obj.save()

		Shell2 будет ждать пока не выполнится Shell1

	

	При разработки или исправлении ошибки придумывать различные варианты решения. Например не заливается дамп базы данных, пробуем удалить базу, создать заново и залить.


	При составлении запросов сначала придумываем на чистом sql (по схеме, которую я составил), а потом пишем на orm.

	При ошибках в ядре делать трассировку и искать все возможные варианты.

	check в postgres может очень сильно тормозить.

	При оптимизации чего-либо сначала нужно обновить это, потом проверить и если всеравно работает медленно, то начать оптимизацию. Все это делается, потому что в обновлении уже может быть решение проблем с производительностью.

	Html сервера может приходить в запакованном формате (zip).

	Если нужно протрассировать celery, то запускаем его в debug режиме.

	При тестировании админки django можно проверять url после редиректа. Если вернуло на ту же страницу, то валидация сработала.

	Прежде чем начинать решать задачу, подумать о том, как это можно сделать. В процессе раздумий перебирать те вещи, которые даёт язык или инструмент. Например задача: "Есть два списка. Значения из одного могут повторяться в другом. Как получить один список без повторяющихся значений?" - склеить 2 списка и преобразовать к set.

	Если происходит непонятная хрень с pycharm или python, то можно попробовать почистить пики (file_name.pyc)

	Если работаю с python 2 и типом данных unicode, то помнить, что везде, где используются русские символы строка должна начинаться с u''. Обычно если буквы u нет, то вылазить обшибка "UnicodeDecodeError 'ascii' codec can't decode byte 0xd0 in position 0: ordinal not in range(128)"

	Название методов

		Пример

			Есть метод который валидирует индексы. На вход метод принимает список индексов. Соответственно он должен называться во множественном числе:

				def validate_indexes(index_list):
					pass

	Возврат значений из методов

		Есть метод validate_indexes. Он либо выкидывает исключение, либо ничего не возращает (то есть None).

		Вопрос: он должен ничего не возращать (то есть None) или все-таки True?

		Ответ: если результат вызова где то потом используется, то должен возращать True, если нет, то может ничего не возвращать (то есть None).

	Ansible

		Для управления конфигурацией.

	Как написать красивое решение

		Выписываем все варианты работы того или иного функционала.

		Смотрим отдаленно от конкретной реализации, что и где можно использовать. Например здесь используем форму для валидации, а эту часть валидации сделаем с помощью выборки валидных данных из базы и их проверки.

	Что лучше одна длинная цепочка из and/or if-ов или эти же if-ы отдельно?

		Если после if-а делается одно и то же действие, то лучше длинная цепочка. Нарпимер после каждого if-а выкидывается одно и тоже исключение с одинаковым текстом.

		Соответсвенно если действи после if-ов разные, то лучше их разбить по одному.

	Если 2 метода делают одно и тоже, но один положительный, а другой отрицательный

		Например есть метод get_product_cards_valid и метод get_product_cards_not_valid.

		Они делают одно и тоже, но один возращает положительный результат, а другой отрицательный.

		В таком случае лучше оставить один метод (например get_product_cards_valid) и взять его отрицательный результат (то есть не валидные карточки товара)

	Признаки плохого проекта

		Если работоспособность проекта зависит от данных в бд.

		То есть проект должен работать и при пустой бд, как будто он только запустился.

			Если нужно, чтобы какие то данные уже были в бд, например site_id, нужно добавить их в миграции.