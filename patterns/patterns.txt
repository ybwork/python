Оглавление

	Что это

	Из чего состоит паттерн

	Зачем знать паттерны

	Классификация паттернов

	Порождающие

		Фабричный метод

		Абстрактная фабрика

		Строитель

		Прототип

		Одиночка

	Структурные

		Адаптер

		Мост

		Компоновщик

		Декоратор

		Фасад

		Легковес

		Заместитель

Что это

	Паттерн проектирования - это часто встречающееся решение определённой проблемы при проектировании архитектуры программ.

	Паттерн представляет собой не какой-то конкретный код, а общую концепцию решения той или иной проблемы, которую нужно будет ещё подстроить под нужды вашей программы.

Из чего состоит паттерн

	Паттерн состоит из:

		проблемы, которую он решает

		способ решения проблемы

		структуры классов, составляющих решение

Зачем знать паттерны

	Проверенные решения.

	Делается меньше просчётов при проектировании, так как все скрытые проблемы в них уже давно найдены.

	Общий программистский словарь.

Классификация паттернов

	Порождающие

	Структурные

	Поведенческие

Порождающие

	Отвечают за создание объектов.

	Список: фабричный метод, абстрактная фабрика, строитель, прототип, одиночка.

Фабричный метод

	Порождающий паттерн.

	Определяет общий интерфейс для создания объектов, позволяя подклассам изменять тип создаваемых объектов.

	Проблема

		Представьте, что вы создаёте программу управления грузовыми перевозками. Сперва вы рассчитываете перевозить товары только на автомобилях. Поэтому весь ваш код работает с объектами класса Грузовик. В какой-то момент ваша программа становится настолько известной, что морские перевозчики выстраиваются в очередь и просят добавить поддержку морской логистики в программу. Чтобы добавить в программу классы морских Судов, понадобится перелопатить всю программу, потому что большая часть существующего клиентского кода жёстко привязана к классам Грузовиков. Более того, если вы потом решите добавить в программу ещё один вид транспорта, то всю эту работу придётся повторить. В итоге вы получите ужасающий код, наполненный условными операторами, которые выполняют то или иное действие, в зависимости от класса транспорта.

		Или вы используете готовый UI-фреймворк для своего приложения. Но вот беда - требуется иметь круглые кнопки, вместо стандартных прямоугольных. Вы создаёте класс RoundButton. Но как сказать главному классу фреймворка UIFramework, чтобы он теперь создавал круглые кнопки, вместо стандартных? Для этого вы создаёте подкласс UIWithRoundButtons из базового класса фреймворка, переопределяете в нём метод создания кнопки (а-ля createButton) и вписываете туда создание своего класса кнопок. Затем используете UIWithRoundButtons вместо стандартного UIFramework.

	Решение

		Паттерн Фабричный метод предлагает создавать объекты не напрямую, используя оператор new, а через вызов особого фабричного метода. Объекты всё равно будут создаваться при помощи new, но делать это будет фабричный метод. Фабричный метод задаёт метод, который следует использовать вместо вызова оператора new для создания объектов. Подклассы могут переопределить этот метод, чтобы изменять тип создаваемых объектов. Зачастую фабричный метод объявляют абстрактным, чтобы заставить все подклассы реализовать его по-своему. Фабричный метод можно определить по создающим методам, которые возвращают объекты.

	Применимость

		Хорош для расширения системы, когда мы не знаем сколько еще будет дополнений.

	Пример на python

		class Creator:
		    """
		    Класс Создатель объявляет фабричный метод, который должен возвращать объект
		    класса. Подклассы Создателя обычно предоставляют реализацию этого метода.
		    """

		    @abstractmethod
		    def factory_method(self):
		        pass

		    def some_operation(self):
		        """
		        Также заметьте, что, несмотря на название, основная обязанность
		        Создателя не заключается только в создании. Обычно он содержит
		        некоторую базовую бизнес-логику.
		        """
		        pass


		"""Конкретные Создатели переопределяют фабричный метод для того, чтобы изменить тип, создаваемого объекта."""


		class ConcreteCreator1(Creator):
		    def factory_method(self):
		        return ConcreteProduct1()


		class ConcreteCreator2(Creator):
		    def factory_method(self):
		        return ConcreteProduct2()


		class Product:
		    """
		    Интерфейс Продукта объявляет операции, которые должны выполнять все
		    конкретные продукты.
		    """

		    @abstractmethod
		    def some_operation(self):
		        pass


		"""
		Конкретные Продукты предоставляют различные реализации интерфейса Продукта.
		"""


		class ConcreteProduct1(Product):
		    def some_operation(self):
		        pass


		class ConcreteProduct2(Product):
		    def some_operation(self):
		        pass


		def client_code(creator: Creator):
		    """
		    Клиентский код работает с экземпляром конкретного создателя, хотя и через
		    его базовый интерфейс. Пока клиент продолжает работать с создателем через
		    базовый интерфейс, вы можете передать ему любой подкласс создателя.
		    """
		    
		    pass


		if __name__ == "__main__":
		    client_code(ConcreteCreator1())
		    client_code(ConcreteCreator2())

Абстрактная фабрика

	Порождающий паттерн.

	Позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам.

	Проблема

		Есть семейство зависимых продуктов - Кресло + Диван + Столик. И есть несколько вариаций этого семейства. Например Кресло, Диван и Столик представлены в трёх разных стилях: Ар-деко, Викторианском и Модерне. Вам нужен такой способ создавать объекты продуктов, чтобы они сочетались с другими продуктами того же семейства. То есть чтобы можно было легко создать столик, диван и кресло например в стиле модерн.

	Решение

		Определите продукты и их вариации.

		Выделите общие интерфейсы для отдельных продуктов.

		Определите интерфейс абстрактной фабрики. Он должен иметь методы для создания каждого продукта.

		Создайте классы конкретных фабрик, реализовав интерфейс абстрактной фабрики. Этих классов должно быть столько же, сколько и вариаций семейств продуктов и внутри они должны создавать продукты определенной вариации.

			class LinuxFactory:
				def create_button(self):
					return button

				def create_icon(self):
					return icon

		Измените код инициализации программы так, чтобы она создавала определённую фабрику и передавала её в клиентский код.

			if os == 'linux':
				factory = LinuxFactory()
			elif os == 'Win':
				factory = WinFactory()

		Замените в клиентском коде участки создания продуктов через конструктор вызовами соответствующих методов фабрики.

		В самом начале программа определяет с какой фабрикой будет работать (например из переменной окружения или файла конфигурации) затем создает объект этой фабрики и отдаёт его клиентскому коду.

		В дальнейшем клиент будет работать только с этой фабрикой, чтобы исключить несовместимость возвращаемых продуктов.

	Применимость

		Используется, когда программа должна работать с разными видами связанных друг с другом объектов (вариациями).

	Пример на python

		class AbstractFactory:
		    """
		    Интерфейс Абстрактной Фабрики объявляет набор методов, которые возвращают
		    различные абстрактные продукты.
		    """
		    @abstractmethod
		    def create_product_a(self):
		        pass

		    @abstractmethod
		    def create_product_b(self):
		        pass


		class ConcreteFactory1(AbstractFactory):
		    """
		    Конкретная Фабрика производит семейство продуктов одной вариации. Фабрика
		    гарантирует совместимость полученных продуктов. То есть стол + стол + кресло 
		    в стиле модерн.
		    """

		    def create_product_a(self):
		        return ConcreteProductA1()

		    def create_product_b(self):
		        return ConcreteProductB1()


		class ConcreteFactory2(AbstractFactory):


		    def create_product_a(self):
		        return ConcreteProductA2()

		    def create_product_b(self):
		        return ConcreteProductB2()


		class AbstractProductA:
		    """
		    Каждый отдельный продукт должен иметь базовый интерфейс.
		    Все вариации продукта должны реализовывать этот интерфейс.
		    """

		    @abstractmethod
		    def some_operation(self):
		        pass


		class ConcreteProductA1(AbstractProductA):
		    def some_operation(self):
		        pass


		class ConcreteProductA2(AbstractProductA):
		    def some_operation(self):
		        pass


		class AbstractProductB:
			"""
			Продукт "B" способен работать самостоятельно и иметь другие методы
	        """

		    @abstractmethod
		    def some_operation(self):
		        pass

		class ConcreteProductB1(AbstractProductB):
		    def some_operation(self):
		        pass

		class ConcreteProductB2(AbstractProductB):
		    def some_operation(self):
		        pass


		def client_code(factory: AbstractFactory):
		    product_a = factory.create_product_a()
		    product_b = factory.create_product_b()


		if __name__ == "__main__":
		    client_code(ConcreteFactory1())
		    client_code(ConcreteFactory2())

Строитель
	
	Порождающий паттерн.

	Позволяет создавать сложные объекты пошагово и даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.

	Проблема

		Нужно создать объект Дом. Чтобы построить стандартный дом, нужно поставить 4 стены, установить двери, вставить пару окон и положить крышу. Но что, если вы хотите дом побольше да посветлее, имеющий сад, бассейн и прочее добро? Самое простое решение - расширить класс Дом, создав подклассы для всех комбинаций параметров дома. Проблема такого подхода — это громадное количество классов, которые вам придётся создать. Каждый новый параметр, вроде цвета обоев или материала кровли, заставит вас создавать всё больше и больше классов для перечисления всех возможных вариантов. Чтобы не плодить подклассы, вы можете подойти к решению с другой стороны. Вы можете создать гигантский конструктор Дома, принимающий уйму параметров для контроля над создаваемым продуктом. Действительно, это избавит вас от подклассов, но приведёт к другой проблеме - большая часть этих параметров будет простаивать, а вызовы конструктора будут выглядеть монструозно из-за длинного списка параметров - new House(1, 2, 3, true, false, true)

	Решение

		Паттерн Строитель предлагает вынести конструирование объекта за пределы его собственного класса, поручив это дело отдельным объектам, называемым строителями.

		Паттерн предлагает разбить процесс конструирования объекта на отдельные шаги (например, построитьСтены, вставитьДвери и другие). Чтобы создать объект, вам нужно поочерёдно вызывать методы строителя. Причём не нужно запускать все шаги, а только те, что нужны для производства объекта определённой конфигурации.

	Применимость

		Когда нужно создавать большие и сложные объекты с перегруженным параметрами конструктором.

		Например дом или машина с большим кол-ом составляющих частей.

	Пример на python

		class Builder:
		    """
		    Интерфейс Строителя объявляет создающие методы для различных частей объекта.
		    """

		    @abstractproperty
		    def product(self):
		        pass

		    @abstractmethod
		    def produce_part_a(self):
		        pass

		    @abstractmethod
		    def produce_part_b(self):
		        pass

		    @abstractmethod
		    def produce_part_c(self):
		        pass


		class ConcreteBuilder1(Builder):
		    """
		    Классы Конкретного Строителя следуют интерфейсу Строителя и предоставляют
		    конкретные реализации шагов построения.
		    """

		    def __init__(self):
		        """
		        Новый экземпляр строителя должен содержать пустой объект продукта,
		        который используется в дальнейшей сборке.
		        """
		        self.reset()


		    def reset(self):
		    	self._product = Product1()
		    

		    @property
		    def product(self):
		        """
		        Конкретные Строители предоставляют свои собственные методы
		        получения результатов. Это связано с тем, что различные типы строителей
		        могут создавать совершенно разные продукты.

		        После возвращения конечного результата клиенту, экземпляр
		        строителя должен быть готов к началу производства следующего продукта.
		        Поэтому обычной практикой является вызов метода сброса в конце тела
		        метода.
		        """
		        product = self._product
		        self.reset()
		        return product

		    def produce_part_a(self):
		        self._product.add("PartA1")

		    def produce_part_b(self):
		        self._product.add("PartB1")

		    def produce_part_c(self):
		        self._product.add("PartC1")


		class Product1():
		    def __init__(self):
		        self.parts = []

		    def add(self):
		        self.parts.append(part)

		    def list_parts(self):
		        pass


		if __name__ == "__main__":
		    """
		    Клиентский код создаёт объект-строитель и инициирует процесс построения.
		    """

		    builder = ConcreteBuilder1()
		    builder.produce_part_a()
		    builder.produce_part_b()
		    builder.produce_part_с()

Прототип

	Порождающий паттерн.

	Позволяет копировать объекты, любой сложности без привязки к их конкретным классам.

	Проблема

		У вас есть объект, который нужно скопировать. Как это сделать? Нужно создать пустой объект такого же класса, а затем поочерёдно скопировать значения всех полей из старого объекта в новый. Но есть нюанс. Не каждый объект удастся скопировать таким образом, ведь часть его состояния может быть приватной, а значит — недоступной для остального кода программы. Есть и другая проблема. Копирующий код станет зависим от классов копируемых объектов. Ведь, чтобы перебрать все поля объекта, нужно привязаться к его классу. Из-за этого вы не сможете копировать объекты, зная только их интерфейсы, а не конкретные классы.

	Решение

		Паттерн Прототип поручает создание копий самим копируемым объектам. Он вводит общий интерфейс для всех объектов, поддерживающих клонирование. Обычно такой интерфейс имеет всего один метод clone. Объект, который копируют, называется прототипом. Клонирование совершается самим объектом-прототипом, что позволяет ему скопировать значения всех полей, даже приватных.

	Применимость

		Когда объекты программы содержат сотни полей и тысячи возможных конфигураций, прототипы могут служить своеобразной альтернативой созданию подклассов.

		Когда ваш код не должен зависеть от классов копируемых объектов.

		Таким образом, вместо порождения объектов из подклассов, вы будете копировать существующие объекты-прототипы, в которых уже настроено внутреннее состояние. Это позволит избежать взрывного роста количества классов в программе и уменьшить её сложность.

	Пример на python

		Паттерн Прототип реализован в базовой библиотеке Python посредством интерфейса Cloneable.

		import copy

		class Prototype:
		    def __init__(self):
		        self._objects = {}

		    def register_object(self, name, obj):
		        self._objects[name] = obj

		    def clone(self, name, **attr):
		        obj = copy.deepcopy(self._objects.get(name))
		        obj.__dict__.update(attr)
		        return obj

		class A:
		    def __init__(self):
		        self.x = 3
		        self.y = 8
		        self.z = 15
		        self.garbage = [38, 11, 19]


		def main():
		    a = A()
		    prototype = Prototype()
		    prototype.register_object('object', a)
		    b = prototype.clone('object')
		    c = prototype.clone('object', x=1, y=2, garbage=[88, 1])


		if __name__ == '__main__':
		    main()

Одиночка

	Порождающий паттерн.

	Гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.

	Проблема

		Представьте, что вы создали объект, а через некоторое время пробуете создать ещё один и хотелось бы получить старый объект, вместо создания нового. Такое поведение невозможно реализовать с помощью обычного конструктора, так как конструктор класса всегда возвращает новый объект.

	Решение

		Все реализации одиночки сводятся к тому, чтобы скрыть конструктор по умолчанию и создать статический метод, который будет либо создавать объект, либо отдавать существующий объект, если он уже был создан.

		В отличие от глобальных переменных, Одиночка гарантирует, что никакой другой код не заменит созданный экземпляр класса.

	Применимость

		Чаще всего это полезно для доступа к какому-то общему ресурсу, например, базе данных, чтобы не открывать каждый раз новое соединение.

		Использовать, когда должен быть единственный экземпляр какого-то класса, доступный всем.

	Пример на python

		class App:
		    __instance = None

		    @staticmethod
		    def get_instance():
		        if App.__instance is None:
		            App.__instance = App()
		        return App.__instance


		print(App.get_instance(), App.get_instance())

Структурные
	
	Показывают различные способы построения связей между объектами.

	Список: адаптер, мост, компоновщик, декоратор, фасад, легковес, заместитель.

Адаптер

	Структурный паттерн.

	Позволяет объектам с несовместимыми интерфейсами работать вместе.

	Проблема

		Представьте, что вы делаете приложение для торговли на бирже. Ваше приложение скачивает биржевые котировки из нескольких источников в XML, а затем рисует красивые графики. В какой-то момент вы решаете улучшить приложение, применив стороннюю библиотеку аналитики. Но вот беда - библиотека поддерживает только формат данных JSON, несовместимый с вашим приложением. Вы смогли бы переписать библиотеку, чтобы та поддерживала формат XML. Но, во-первых, это может нарушить работу существующего кода, который уже зависит от библиотеки. А во-вторых, у вас может просто не быть доступа к её исходному коду.

	Решение

		Вы можете создать адаптер. Это объект-переводчик, который трансформирует интерфейс или данные одного объекта в такой вид, чтобы он стал понятен другому объекту. Например, вы можете обернуть объект, работающий в метрах, адаптером, который бы конвертировал данные в футы.

		Адаптеры могут не только переводить данные из одного формата в другой, но и помогать объектам с разными интерфейсами работать сообща. Адаптер имеет интерфейс, который совместим с одним из объектов. Поэтому этот объект может свободно вызывать методы адаптера. Адаптер получает эти вызовы и перенаправляет их второму объекту, но уже в том формате и последовательности, которые понятны второму объекту.

		Иногда возможно создать даже двухсторонний адаптер, который работал бы в обе стороны.

		Когда вы в первый раз летите за границу, вас может ждать сюрприз при попытке зарядить ноутбук. Стандарты розеток в разных странах отличаются. Ваша европейская зарядка будет бесполезна в США без специального адаптера, позволяющего подключиться к розетке другого типа.

	Применимость

		Когда вы хотите использовать сторонний класс, но его интерфейс не соответствует остальному коду приложения.

		Когда вам нужно использовать несколько существующих подклассов, но в них не хватает какой-то общей функциональности, причём расширить суперкласс вы не можете.

	Пример на python

		class GameConsole:
		    def create_game_picture(self):
		        return 'picture from console'

		class Antenna:
		    def create_wave_picture(self):
		        return 'picture from wave'

		class SourceGameConsole(GameConsole):
		    def get_picture(self):
		        return self.create_game_picture()

		class SourceAntenna(Antenna):
		    def get_picture(self):
		        return self.create_wave_picture()

		class TV:
			"""Это класс адаптер"""
		    def __init__(self, source):
		        self.source = source

		    def show_picture(self):
		        return self.source.get_picture()

		g = SourceGameConsole()
		a = SourceAntenna()
		game_tv = TV(g)
		cabel_tv = TV(a)
		print game_tv.show_picture()
		print cabel_tv.show_picture()

Мост

	Структурный паттерн.

	Разделяет бизнес-логику или большой класс на несколько отдельных иерархий, которые потом можно развивать отдельно друг от друга.

	Одна из этих иерархий (абстракция) получит ссылку на объекты другой иерархии (реализация) и будет делегировать им основную работу. Благодаря тому, что все реализации будут следовать общему интерфейсу, их можно будет взаимозаменять внутри абстракции.

	Проблема

		У вас есть класс геометрических Фигур, который имеет подклассы Круг и Квадрат. Вы хотите расширить иерархию фигур по цвету, то есть иметь Красные и Синие фигуры. Но чтобы всё это объединить, вам придётся создать 4 комбинации подклассов, вроде  СиниеКруги и КрасныеКвадраты. При добавлении новых видов фигур и цветов количество комбинаций будет расти в геометрической прогрессии. Например, чтобы ввести в программу фигуры треугольников, придётся создать сразу два новых подкласса треугольников под каждый цвет. После этого новый цвет потребует создания уже трёх классов для всех видов фигур.

	Решение

		Паттерн Мост предлагает заменить наследование композицией. Таким образом, мы можем сделать Цвет отдельным классом с подклассами Красный и  Синий. Класс Фигур получит ссылку на объект Цвета и сможет делегировать ему работу, если потребуется. Такая связь и станет мостом между Фигурами и Цветом. При добавлении новых классов цветов не потребуется трогать классы фигур и наоборот.

	Применимость

		Когда вы хотите разделить монолитный класс, который содержит несколько различных реализаций какой-то функциональности (например, если класс может работать с разными системами баз данных).

		Когда класс нужно расширять в двух независимых плоскостях. Например цвет и фигуры.

		Когда вы хотите, чтобы реализацию можно было бы изменять во время выполнения программы.

		Паттерн Мост особенно полезен когда вам приходится делать кросс-платформенные приложения, поддерживать несколько типов баз данных или работать с разными поставщиками похожего API.

	Пример на python

		class Abstraction:
		    """
		    Абстракция устанавливает интерфейс для «управляющей» части двух иерархий
		    классов. Она содержит ссылку на объект реализации и делегирует
		    ему всю настоящую работу.
		    """

		    def __init__(self, implementation):
		        self.implementation = implementation

		    def operation(self):
		        return self.implementation.operation_implementation()


		class Implementation:
		    """
		    Реализация устанавливает интерфейс для всех классов реализации.
		    """

		    @abstractmethod
		    def operation_implementation(self):
		        pass


		"""
		Каждая Конкретная Реализация соответствует определённой платформе и реализует
		интерфейс Реализации с использованием API этой платформы.
		"""


		class ConcreteImplementationA(Implementation):
		    def operation_implementation(self):
		        pass


		class ConcreteImplementationB(Implementation):
		    def operation_implementation(self):
		        pass


		def client_code(abstraction):
		    """
		    Клиентский код должен зависеть только от класса Абстракции. 
		    Таким образом, клиентский код может поддерживать любую
		    комбинацию абстракции и реализации.
		    """
			return abstraction.operation()


		if __name__ == "__main__":
		    """
		    Клиентский код должен работать с любой предварительно сконфигурированной
		    комбинацией абстракции и реализации.
		    """

		    implementation = ConcreteImplementationA()
		    abstraction = Abstraction(implementation)
		    client_code(abstraction)


		    implementation = ConcreteImplementationB()
		    abstraction = ExtendedAbstraction(implementation)
		    client_code(abstraction)

Компоновщик

	Структурный паттерн.

	Позволяет сгруппировать множество объектов в древовидную структуру, а затем работать с ней так, как будто это единичный объект.

	Проблема

		Например, есть два объекта: Продукт и Коробка. Коробка может содержать несколько  Продуктов и других Коробок поменьше. Те, в свою очередь, тоже содержат либо  Продукты, либо Коробки и так далее. Теперь предположим, ваши Продукты и Коробки могут быть частью заказов. Каждый заказ может содержать как простые Продукты без упаковки, так и составные Коробки. Ваша задача состоит в том, чтобы узнать цену всего заказа.

		Если решать задачу в лоб, то вам потребуется открыть все коробки заказа, перебрать все продукты и посчитать их суммарную стоимость. Но это слишком хлопотно, так как типы коробок и их содержимое могут быть вам неизвестны. Кроме того, наперёд неизвестно и количество уровней вложенности коробок, поэтому перебрать коробки простым циклом не выйдет.

	Решение

		Компоновщик предлагает рассматривать Продукт и Коробку через единый интерфейс с общим методом получения стоимости. Продукт просто вернёт свою цену. Коробка спросит цену каждого предмета внутри себя и вернёт сумму результатов. Если одним из внутренних предметов окажется коробка поменьше, она тоже будет перебирать своё содержимое, и так далее, пока не будут посчитаны все составные части.

	Применимость

		Когда вам нужно представить древовидную структуру объектов.

		Компоновщик давно стал синонимом всех задач, связанных с построением дерева объектов.

	Пример на python

		class Unit:
		    """Абстрактный компонент, в данном случае это - отряд (отряд может
		    состоять из одного солдата или более)
		    """

		    @abstractmethod
		    def show_name(self):
		        """Вывод данных о компоненте отряда"""
		        pass


		class Archer(Unit):
		    """Лучник"""

		    def show_name(self):
		        print('лучник')


		class Knight(Unit):
		    """Рыцарь"""

		    def show_name(self):
		        print('рыцарь')


		class Swordsman(Unit):
		    """Мечник"""

		    def show_name(self):
		        print('мечник')


		class Squad(Unit):
		    """Компоновщик - отряд, состоящий более чем из одного человека."""

		    def __init__(self):
		        self._units = []

		    def show_name(self):
		        for unit in self._units:
		            unit.show_name()

		    def add(self, unit):
		        """Добавление нового отряда"""
		        self._units.append(unit)

		    def remove(self, unit: Unit):
		        """Удаление отряда из текущего компоновщика"""
		        for u in self._units:
		            if u == unit:
		                self._units.remove(u)
		                u.print()
		                break
		        else:
		            unit.print()


		if __name__ == '__main__':
		    squad = Squad()
		    squad.add(Knight())
		    squad.add(Knight())
		    squad.add(Archer())

		    swordsman = Swordsman()
		    squad.add(swordsman)
		    squad.remove(swordsman)

		    squad.show_name()

		    squad_big = Squad()
		    squad_big.add(Swordsman())
		    squad_big.add(Swordsman())
		    squad_big.add(squad)

		    squad_big.show_name()

Декоратор

	Структурный паттерн.

	Позволяет динамически добавлять объектам новую функциональность, оборачивая их в обёртки.

	Декоратор позволяет оборачивать объекты бесчисленное количество раз благодаря тому, что и обёртки, и реальные оборачиваемые объекты имеют общий интерфейс.

	Проблема

		Вы работаете над библиотекой оповещений, которую можно подключать к разнообразным программам, чтобы получать уведомления о важных событиях. Основой библиотеки является класс Notifier с методом send, который принимает на вход строку-сообщение и высылает её всем администраторам по электронной почте. Сторонняя программа должна создать и настроить этот объект, указав кому отправлять оповещения, а затем использовать его каждый раз, когда что-то случается. В какой-то момент стало понятно, что одних email-оповещений пользователям мало. Некоторые из них хотели бы получать извещения о критических проблемах через SMS. Другие хотели бы получать их в виде сообщений Facebook. Корпоративные пользователи хотели бы видеть сообщения в Slack. Сначала вы добавили каждый из этих типов оповещений в программу, унаследовав их от базового класса Notifier. Теперь пользователь выбирал один из типов оповещений, который и использовался в дальнейшем. Но затем кто-то резонно спросил, почему нельзя выбрать несколько типов оповещений сразу? Ведь если вдруг в вашем доме начался пожар, вы бы хотели получить оповещения по всем каналам, не так ли? Вы попытались реализовать все возможные комбинации подклассов оповещений. Но после того как вы добавили первый десяток классов, стало ясно, что такой подход невероятно раздувает код программы.

	Решение

		Вы помещаете целевой объект в другой объект-обёртку, который запускает базовое поведение объекта, а затем добавляет к результату что-то свое.

		Любая одежда - это аналог Декоратора. Применяя Декоратор, вы не меняете первоначальный класс и не создаёте дочерних классов. Так и с одеждой — надевая свитер, вы не перестаёте быть собой, но получаете новое свойство — защиту от холода. Вы можете пойти дальше и надеть сверху ещё один декоратор — плащ, чтобы защититься и от дождя.

	Применимость

		Когда вам нужно добавлять обязанности объектам на лету, незаметно для кода, который их использует.

		Когда нельзя расширить обязанности объекта с помощью наследования. Во многих языках программирования есть ключевое слово final, которое может заблокировать наследование класса. Расширить такие классы можно только с помощью Декоратора.

	Пример на python

		class Component:
		    """
		    Базовый интерфейс Компонента определяет поведение, которое изменяется
		    декораторами.
		    """

		    def operation(self):
		        pass


		class ConcreteComponent(Component):
		    """Конкретные Компоненты предоставляют 
		    реализации поведения.
		    """

		    def operation(self):
		        return 1


		class Decorator(Component):
		    """Базовый класс Декоратора следует тому же интерфейсу, 
		    что и другиекомпоненты.
		    """

		    def __init__(self, component):
		        self._component = component

		    @property
		    def component(self):
		        """Декоратор делегирует всю работу обёрнутому компоненту."""

		        return self._component

		    def operation(self):
		        self._component.operation()


		class ConcreteDecoratorA(Decorator):
		    """Конкретные Декораторы вызывают обёрнутый объект
		    и изменяют его результат.
		    """

		    def operation(self):
		        return self.component.operation() + 1


		class ConcreteDecoratorB(Decorator):
		    """
		    Декораторы могут выполнять своё поведение до или после вызова обёрнутого
		    объекта.
		    """

		    def operation(self):
		        return self.component.operation() + 8


		if __name__ == "__main__":
		    component = ConcreteComponent()
		    decorator1 = ConcreteDecoratorA(component)
		    decorator2 = ConcreteDecoratorB(decorator1)

Фасад

	Структурный паттерн.

	Предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку.

	Фасад позволяет снизить общую сложность программы и помогает вынести код, зависимый от внешней системы в единственное место.

	Проблема

		Вашему коду приходится работать с большим количеством объектов некой сложной библиотеки или фреймворка. Вы должны самостоятельно инициализировать эти объекты, следить за правильным порядком зависимостей и так далее. В результате бизнес-логика ваших классов тесно переплетается с деталями реализации сторонних классов. Такой код довольно сложно понимать и поддерживать.

	Решение

		Фасад - это простой интерфейс для работы со сложной подсистемой, содержащей множество классов. Фасад может иметь урезанный интерфейс, не имеющий 100% функциональности, которой можно достичь, используя сложную подсистему напрямую. Но он предоставляет именно те фичи, которые нужны клиенту, и скрывает все остальные. К примеру, программа, заливающая видео котиков в социальные сети, может использовать профессиональную библиотеку сжатия видео. Но все, что нужно клиентскому коду этой программы — простой метод encode(filename, format). Создав класс с таким методом, вы реализуете свой первый фасад.

		Когда вы звоните в магазин и делаете заказ по телефону, сотрудник службы поддержки является вашим фасадом ко всем службам и отделам магазина. Он предоставляет вам упрощённый интерфейс к системе создания заказа, платёжной системе и отделу доставки.

	Применимость

		Когда вам нужно представить простой или урезанный интерфейс к сложной подсистеме.

		Когда вы хотите разложить подсистему на отдельные слои.

	Пример на python

		class Facade:
		    """Класс Фасада предоставляет простой интерфейс для сложной логики одной
		    или нескольких подсистем.

		    """

		    def __init__(self, subsystem1, subsystem2):
		        """В зависимости от потребностей вашего приложения вы можете предоставить
		        Фасаду существующие объекты подсистемы или заставить Фасад создать их
		        самостоятельно.

		        """

		        self._subsystem1 = subsystem1 or Subsystem1()
		        self._subsystem2 = subsystem2 or Subsystem2()

		    def operation(self):
		        """Методы Фасада удобны для быстрого доступа к сложной функциональности
		        подсистем. Однако клиенты получают только часть возможностей подсистемы.

		        """

		        self._subsystem1.operation1()
		        self._subsystem2.operation1()

		        self._subsystem1.operation_n()
		        self._subsystem2.operation_z()


		class Subsystem1:
		    """Подсистема может принимать запросы либо от фасада, 
		    либо от клиента напрямую.

		    """

		    def operation1(self):
		        return 'operation1'

		    def operation_n(self):
		        return 'operation_n'


		class Subsystem2:


		    def operation1(self):
		        return 'operation1'

		    def operation_z(self):
		        return 'operation_z'


		def client_code(facade):
		    """Клиентский код работает со сложными подсистемами через простой интерфейс,
		    предоставляемый Фасадом.
		    """

		    return facade.operation()


		if __name__ == "__main__":
		    subsystem1 = Subsystem1()
		    subsystem2 = Subsystem2()
		    facade = Facade(subsystem1, subsystem2)
		    client_code(facade)