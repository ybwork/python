Оглавление

	Что это

	Из чего состоит паттерн

	Зачем знать паттерны

	Классификация паттернов

	Порождающие

		Фабричный метод

		Абстрактная фабрика

		Строитель

		Прототип

		Одиночка

	Структурные

		Адаптер

		Мост

		Компоновщик

		Декоратор

		Фасад

		Легковес

		Заместитель

	Поведенческие

		Цепочка обязанностей

		Команда

		Итератор

		Посредник

		Снимок

		Наблюдатель

		Состояние

		Стратегия

		Шаблонный метод

		Посетитель

Что это

	Паттерн проектирования - это часто встречающееся решение определённой проблемы при проектировании архитектуры программ.

	Паттерн представляет собой не какой-то конкретный код, а общую концепцию решения той или иной проблемы, которую нужно будет ещё подстроить под нужды вашей программы.

Из чего состоит паттерн

	Паттерн состоит из:

		проблемы, которую он решает

		способ решения проблемы

		структуры классов, составляющих решение

Зачем знать паттерны

	Проверенные решения.

	Делается меньше просчётов при проектировании, так как все скрытые проблемы в них уже давно найдены.

	Общий программистский словарь.

Классификация паттернов

	Порождающие

	Структурные

	Поведенческие

Порождающие

	Отвечают за создание объектов.

	Список: фабричный метод, абстрактная фабрика, строитель, прототип, одиночка.

Фабричный метод (Виртуальный конструктор, Factory Method)

	Порождающий паттерн.

	Определяет общий интерфейс для создания объектов, позволяя подклассам изменять тип создаваемых объектов.

	Проблема

		Представьте, что вы создаёте программу управления грузовыми перевозками. Сперва вы рассчитываете перевозить товары только на автомобилях. Поэтому весь ваш код работает с объектами класса Грузовик. 

		В какой-то момент ваша программа становится настолько известной, что морские перевозчики выстраиваются в очередь и просят добавить поддержку морской логистики в программу. 

		Чтобы добавить в программу классы морских Судов, понадобится перелопатить всю программу, потому что большая часть существующего клиентского кода жёстко привязана к классам Грузовиков. 

		Более того, если вы потом решите добавить в программу ещё один вид транспорта, то всю эту работу придётся повторить. 

		В итоге вы получите ужасающий код, наполненный условными операторами, которые выполняют то или иное действие, в зависимости от класса транспорта.

		Или вы используете готовый UI-фреймворк для своего приложения. Но вот беда - требуется иметь круглые кнопки, вместо стандартных прямоугольных. 

		Вы создаёте класс RoundButton. Но как сказать главному классу фреймворка UIFramework, чтобы он теперь создавал круглые кнопки, вместо стандартных? 

		Для этого вы создаёте подкласс UIWithRoundButtons из базового класса фреймворка, переопределяете в нём метод создания кнопки (а-ля createButton) и вписываете туда создание своего класса кнопок. 

		Затем используете UIWithRoundButtons вместо стандартного UIFramework.

	Решение

		Паттерн Фабричный метод предлагает создавать объекты не напрямую, используя оператор new, а через вызов особого фабричного метода. Объекты всё равно будут создаваться при помощи new, но делать это будет фабричный метод. 

		Фабричный метод задаёт метод, который следует использовать вместо вызова оператора new для создания объектов. 

		Подклассы могут переопределить этот метод, чтобы изменять тип создаваемых объектов. 

		Зачастую фабричный метод объявляют абстрактным, чтобы заставить все подклассы реализовать его по-своему. Фабричный метод можно определить по создающим методам, которые возвращают объекты.

	Применимость

		Хорош для расширения системы, когда мы не знаем сколько еще будет дополнений.

	Пример на python

		from __future__ import annotations
		from abc import ABC, abstractmethod


		class Creator(ABC):
		    """Класс Создатель объявляет фабричный метод, который должен возвращать 
		    объект класса Продукт. 

		    Подклассы Создателя обычно предоставляют реализацию этого метода.

		    """

		    @abstractmethod
		    def factory_method(self):
		        """Обратите внимание, что Создатель может также обеспечить реализацию
		        фабричного метода по умолчанию.

		        """
		        pass

		    def some_operation(self) -> str:
		        """Также заметьте, что, несмотря на название, основная обязанность Создателя 
		        не заключается в создании продуктов. 

		        Обычно он содержит некоторую базовую бизнес-логику, которая основана на 
		        объектах Продуктов, возвращаемых фабричным методом. 

		        """

		        # Вызываем фабричный метод, чтобы получить объект-продукт.
		        product = self.factory_method()

		        # Далее, работаем с этим продуктом.
		        result = product.operation()

		        return result


		"""
		Конкретные Создатели переопределяют фабричный метод для того, чтобы изменить тип
		результирующего продукта.
		"""


		class ConcreteCreator1(Creator):
		    def factory_method(self) -> ConcreteProduct1:
		        return ConcreteProduct1()


		class ConcreteCreator2(Creator):
		    def factory_method(self) -> ConcreteProduct2:
		        return ConcreteProduct2()


		class Product(ABC):
		    """Интерфейс Продукта объявляет операции, которые должны выполнять 
		    все конкретные продукты.

		    """

		    @abstractmethod
		    def operation(self) -> str:
		        pass


		"""
		Конкретные Продукты предоставляют различные реализации интерфейса Продукта.
		"""


		class ConcreteProduct1(Product):
		    def operation(self) -> str:
		        return 'result of ConcreteProduct2'


		class ConcreteProduct2(Product):
		    def operation(self) -> str:
		        return 'result of ConcreteProduct2'


		def client_code(creator: Creator) -> None:
		    """Клиентский код работает с экземпляром конкретного создателя, хотя и через
		    его базовый интерфейс. 

		    Пока клиент продолжает работать с создателем через базовый интерфейс, 
		    вы можете передать ему любой подкласс создателя.

		    """

		    print('client_code')


		if __name__ == "__main__":
		    client_code(ConcreteCreator1())
		    client_code(ConcreteCreator2())

Абстрактная фабрика (Abstract Factory)

	Порождающий паттерн.

	Позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам.

	Проблема

		Есть семейство зависимых продуктов - Кресло + Диван + Столик. И есть несколько вариаций этого семейства. Например Кресло, Диван и Столик представлены в трёх разных стилях: Ар-деко, Викторианском и Модерне. 

		Вам нужен такой способ создавать объекты продуктов, чтобы они сочетались с другими продуктами того же семейства. То есть чтобы можно было легко создать столик, диван и кресло например в стиле модерн.

	Решение

		Определите продукты и их вариации.

		Выделите общие интерфейсы для отдельных продуктов.

		Определите интерфейс абстрактной фабрики. Он должен иметь методы для создания каждого продукта.

		Создайте классы конкретных фабрик, реализовав интерфейс абстрактной фабрики. 

		Этих классов должно быть столько же, сколько и вариаций семейств продуктов и внутри они должны создавать продукты определенной вариации.

		Замените в клиентском коде участки создания продуктов через конструктор вызовами соответствующих методов фабрики.

		В самом начале программа определяет с какой фабрикой будет работать (например из переменной окружения или файла конфигурации) затем создает объект этой фабрики и отдаёт его клиентскому коду.

		В дальнейшем клиент будет работать только с этой фабрикой, чтобы исключить несовместимость возвращаемых продуктов.

	Применимость

		Используется, когда программа должна работать с разными видами связанных друг с другом объектов (вариациями).

	Пример на python

		from __future__ import annotations
		from abc import ABC, abstractmethod


		class AbstractFactory(ABC):
		    """Интерфейс Абстрактной Фабрики объявляет набор методов, которые возвращают
		    различные абстрактные продукты. 

		    """

		    @abstractmethod
		    def create_product_a(self) -> AbstractProductA:
		        pass

		    @abstractmethod
		    def create_product_b(self) -> AbstractProductB:
		        pass


		class ConcreteFactory1(AbstractFactory):
		    """Конкретная Фабрика производит семейство продуктов одной вариации. 

		    Фабрика гарантирует совместимость полученных продуктов. 

		    """

		    def create_product_a(self) -> ConcreteProductA1:
		        return ConcreteProductA1()

		    def create_product_b(self) -> ConcreteProductB1:
		        return ConcreteProductB1()


		class ConcreteFactory2(AbstractFactory):
		    """Каждая Конкретная Фабрика имеет соответствующую вариацию продукта."""

		    def create_product_a(self) -> ConcreteProductA2:
		        return ConcreteProductA2()

		    def create_product_b(self) -> ConcreteProductB2:
		        return ConcreteProductB2()


		class AbstractProductA(ABC):
		    """Каждый отдельный продукт семейства продуктов должен иметь базовый интерфейс.

		    Все вариации продукта должны реализовывать этот интерфейс.

		    """

		    @abstractmethod
		    def useful_function_a(self) -> str:
		        pass


		"""
		Конкретные продукты создаются соответствующими Конкретными Фабриками.
		"""


		class ConcreteProductA1(AbstractProductA):
		    def useful_function_a(self) -> str:
		        return 'result product A1'


		class ConcreteProductA2(AbstractProductA):
		    def useful_function_a(self) -> str:
		        return 'result product A2'


		class AbstractProductB(ABC):
		    """Базовый интерфейс другого продукта. 

		    Все продукты могут взаимодействовать друг с другом, но правильное взаимодействие
		    возможно только между продуктами одной и той же конкретной вариации.

		    """

		    @abstractmethod
		    def useful_function_b(self) -> None:
		        pass

		    @abstractmethod
		    def another_useful_function_b(self, collaborator: AbstractProductA) -> None:
		        pass


		"""
		Конкретные Продукты создаются соответствующими Конкретными Фабриками.
		"""


		class ConcreteProductB1(AbstractProductB):
		    def useful_function_b(self) -> str:
		        return 'result product B1'

		    def another_useful_function_b(self, collaborator: AbstractProductA) -> str:
		        """Продукт B1 может корректно работать только с Продуктом A1. 

		        Тем не менее, он принимает любой экземпляр Абстрактного Продукта А 
		        в качестве аргумента.

		        """

		        result = collaborator.useful_function_a()
		        return result


		class ConcreteProductB2(AbstractProductB):
		    def useful_function_b(self) -> str:
		        return 'result product B2'

		    def another_useful_function_b(self, collaborator: AbstractProductA):
		        """Продукт B2 может корректно работать только с Продуктом A2. 

		        Тем не менее, он принимает любой экземпляр Абстрактного Продукта А 
		        в качестве аргумента.

		        """

		        result = collaborator.useful_function_a()
		        return result


		def client_code(factory: AbstractFactory) -> None:
		    """Клиентский код работает с фабриками и продуктами только через абстрактные
		    типы: Абстрактная Фабрика и Абстрактный Продукт. 

		    Это позволяет передавать любой подкласс фабрики или продукта клиентскому коду, 
		    не нарушая его.

		    """

		    product_a = factory.create_product_a()
		    product_b = factory.create_product_b()


		if __name__ == "__main__":
		    """Клиентский код может работать с любым конкретным классом фабрики."""

		    client_code(ConcreteFactory1())
		    client_code(ConcreteFactory2())

Строитель (Builder)
	
	Порождающий паттерн.

	Позволяет создавать сложные объекты пошагово и даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.

	Проблема

		Нужно создать объект Дом. Чтобы построить стандартный дом, нужно поставить 4 стены, установить двери, вставить пару окон и положить крышу. 

		Но что, если вы хотите дом побольше да посветлее, имеющий сад, бассейн и прочее добро? Самое простое решение - расширить класс Дом, создав подклассы для всех комбинаций параметров дома. 

		Проблема такого подхода - это громадное количество классов, которые вам придётся создать. Каждый новый параметр, вроде цвета обоев или материала кровли, заставит вас создавать всё больше и больше классов для перечисления всех возможных вариантов. 

		Чтобы не плодить подклассы, вы можете создать гигантский конструктор Дома, принимающий уйму параметров для контроля над создаваемым продуктом. 

		Действительно, это избавит вас от подклассов, но приведёт к другой проблеме - большая часть этих параметров будет простаивать, а вызовы конструктора будут выглядеть монструозно из-за длинного списка параметров - new House(1, 2, 3, true, false, true)

	Решение

		Паттерн Строитель предлагает вынести конструирование объекта за пределы его собственного класса, поручив это дело отдельным объектам, называемым строителями.

		Паттерн предлагает разбить процесс конструирования объекта на отдельные шаги (например, построитьСтены, вставитьДвери и другие). 

		Чтобы создать объект, вам нужно поочерёдно вызывать методы строителя. Причём не нужно запускать все шаги, а только те, что нужны для производства объекта определённой конфигурации.

	Применимость

		Когда нужно создавать большие и сложные объекты с перегруженным параметрами конструктором.

	Пример на python

		from __future__ import annotations
		from abc import ABC, abstractmethod, abstractproperty
		from typing import Any


		class Builder(ABC):
		    """
		    Интерфейс строителя, объявляет создающие методы.
		    """

		    @abstractproperty
		    def product(self) -> None:
		        pass

		    @abstractmethod
		    def produce_part_a(self) -> None:
		        pass

		    @abstractmethod
		    def produce_part_b(self) -> None:
		        pass

		    @abstractmethod
		    def produce_part_c(self) -> None:
		        pass


		class ConcreteBuilder1(Builder):
		    """
		    Класс конкретного строителя. Предоставляют конкретные реализации шагов построения. 
		    """

		    def __init__(self) -> None:
		        """
		        Новый экземпляр строителя должен содержать пустой объект продукта,
		        который используется в дальнейшей сборке.
		        """
		        self.reset()

		    def reset(self) -> None:
		        self._product = Product1()

		    @property
		    def product(self) -> Product1:
		        product = self._product
		        self.reset()
		        return product

		    def produce_part_a(self) -> None:
		        self._product.add("PartA1")

		    def produce_part_b(self) -> None:
		        self._product.add("PartB1")

		    def produce_part_c(self) -> None:
		        self._product.add("PartC1")


		class Product1():
		    def __init__(self) -> None:
		        self.parts = []

		    def add(self, part: Any) -> None:
		        self.parts.append(part)

		    def list_parts(self) -> None:
		        print('list_parts')


		class Director:
		    """
		    Директор отвечает только за выполнение шагов построения в определённой
		    последовательности. Это полезно при производстве продуктов в определённом
		    порядке или особой конфигурации. Класс директор необязателен,
		    так как клиент может напрямую управлять строителями.
		    """

		    def __init__(self) -> None:
		        self._builder = None

		    @property
		    def builder(self) -> Builder:
		        return self._builder

		    @builder.setter
		    def builder(self, builder: Builder) -> None:
		        self._builder = builder

		    """
		    Директор может строить несколько вариаций продукта, используя одинаковые
		    шаги построения.
		    """

		    def build_minimal_viable_product(self) -> None:
		        self.builder.produce_part_a()

		    def build_full_featured_product(self) -> None:
		        self.builder.produce_part_a()
		        self.builder.produce_part_b()
		        self.builder.produce_part_c()


		if __name__ == "__main__":
		    """
		    Клиентский код создаёт объект-строитель, передаёт его директору, а затем
		    инициирует процесс построения. Конечный результат извлекается из
		    объекта-строителя.
		    """

		    director = Director()
		    builder = ConcreteBuilder1()
		    director.builder = builder

		    director.build_minimal_viable_product()
		    builder.product.list_parts()

		    director.build_full_featured_product()
		    builder.product.list_parts()

		    # Помните, что паттерн Строитель можно использовать без класса Директор.
		    builder.produce_part_a()
		    builder.produce_part_b()
		    builder.product.list_parts()

Прототип (Клон, Prototype)

	Порождающий паттерн.

	Позволяет копировать объекты, любой сложности без привязки к их конкретным классам.

	Проблема

		У вас есть объект, который нужно скопировать. Как это сделать? Нужно создать пустой объект такого же класса, а затем поочерёдно скопировать значения всех полей из старого объекта в новый. Но есть нюанс. Не каждый объект удастся скопировать таким образом, ведь часть его состояния может быть приватной, а значит — недоступной для остального кода программы. Есть и другая проблема. Копирующий код станет зависим от классов копируемых объектов. Ведь, чтобы перебрать все поля объекта, нужно привязаться к его классу. Из-за этого вы не сможете копировать объекты, зная только их интерфейсы, а не конкретные классы.

	Решение

		Паттерн Прототип поручает создание копий самим копируемым объектам. Он вводит общий интерфейс для всех объектов, поддерживающих клонирование. Обычно такой интерфейс имеет всего один метод clone. Объект, который копируют, называется прототипом. Клонирование совершается самим объектом-прототипом, что позволяет ему скопировать значения всех полей, даже приватных.

	Применимость

		Когда объекты программы содержат сотни полей и тысячи возможных конфигураций, прототипы могут служить своеобразной альтернативой созданию подклассов.

		Когда ваш код не должен зависеть от классов копируемых объектов.

		Таким образом, вместо порождения объектов из подклассов, вы будете копировать существующие объекты-прототипы, в которых уже настроено внутреннее состояние. Это позволит избежать взрывного роста количества классов в программе и уменьшить её сложность.

	Пример на python

		Паттерн Прототип реализован в базовой библиотеке Python посредством интерфейса Cloneable.

		import copy

		class Prototype:
		    def __init__(self):
		        self._objects = {}

		    def register_object(self, name, obj):
		        self._objects[name] = obj

		    def clone(self, name, **attr):
		        obj = copy.deepcopy(self._objects.get(name))
		        obj.__dict__.update(attr)
		        return obj

		class A:
		    def __init__(self):
		        self.x = 3
		        self.y = 8
		        self.z = 15
		        self.garbage = [38, 11, 19]


		def main():
		    a = A()
		    prototype = Prototype()
		    prototype.register_object('object', a)
		    b = prototype.clone('object')
		    c = prototype.clone('object', x=1, y=2, garbage=[88, 1])


		if __name__ == '__main__':
		    main()

Одиночка (Singleton)

	Порождающий паттерн.

	Гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.

	Проблема

		Представьте, что вы создали объект, а через некоторое время пробуете создать ещё один и хотелось бы получить старый объект, вместо создания нового. Такое поведение невозможно реализовать с помощью обычного конструктора, так как конструктор класса всегда возвращает новый объект.

	Решение

		Все реализации одиночки сводятся к тому, чтобы скрыть конструктор по умолчанию и создать статический метод, который будет либо создавать объект, либо отдавать существующий объект, если он уже был создан.

		В отличие от глобальных переменных, Одиночка гарантирует, что никакой другой код не заменит созданный экземпляр класса.

	Применимость

		Чаще всего это полезно для доступа к какому-то общему ресурсу, например, базе данных, чтобы не открывать каждый раз новое соединение.

		Использовать, когда должен быть единственный экземпляр какого-то класса, доступный всем.

	Пример на python

		class App:
		    __instance = None

		    @staticmethod
		    def get_instance():
		        if App.__instance is None:
		            App.__instance = App()
		        return App.__instance


		print(App.get_instance(), App.get_instance())

Структурные
	
	Показывают различные способы построения связей между объектами.

	Список: адаптер, мост, компоновщик, декоратор, фасад, легковес, заместитель.

Адаптер (Обёртка, Adapter)

	Структурный паттерн.

	Позволяет объектам с несовместимыми интерфейсами работать вместе.

	Проблема

		Представьте, что вы делаете приложение для торговли на бирже. Ваше приложение скачивает биржевые котировки из нескольких источников в XML, а затем рисует красивые графики. В какой-то момент вы решаете улучшить приложение, применив стороннюю библиотеку аналитики. Но вот беда - библиотека поддерживает только формат данных JSON, несовместимый с вашим приложением. Вы смогли бы переписать библиотеку, чтобы та поддерживала формат XML. Но, во-первых, это может нарушить работу существующего кода, который уже зависит от библиотеки. А во-вторых, у вас может просто не быть доступа к её исходному коду.

	Решение

		Вы можете создать адаптер. Это объект-переводчик, который трансформирует интерфейс или данные одного объекта в такой вид, чтобы он стал понятен другому объекту. Например, вы можете обернуть объект, работающий в метрах, адаптером, который бы конвертировал данные в футы.

		Адаптеры могут не только переводить данные из одного формата в другой, но и помогать объектам с разными интерфейсами работать сообща. Адаптер имеет интерфейс, который совместим с одним из объектов. Поэтому этот объект может свободно вызывать методы адаптера. Адаптер получает эти вызовы и перенаправляет их второму объекту, но уже в том формате и последовательности, которые понятны второму объекту.

		Иногда возможно создать даже двухсторонний адаптер, который работал бы в обе стороны.

		Когда вы в первый раз летите за границу, вас может ждать сюрприз при попытке зарядить ноутбук. Стандарты розеток в разных странах отличаются. Ваша европейская зарядка будет бесполезна в США без специального адаптера, позволяющего подключиться к розетке другого типа.

	Применимость

		Когда вы хотите использовать сторонний класс, но его интерфейс не соответствует остальному коду приложения.

		Когда вам нужно использовать несколько существующих подклассов, но в них не хватает какой-то общей функциональности, причём расширить суперкласс вы не можете.

	Пример на python

		class Target():
		    """
		    Целевой класс объявляет интерфейс, с которым может работать клиентский код.
		    """

		    def request(self) -> str:
		        return "Target: The default target's behavior."


		class Adaptee:
		    """
		    Адаптируемый класс содержит некоторое полезное поведение, но его интерфейс
		    несовместим с существующим клиентским кодом. Адаптируемый класс нуждается в
		    некоторой доработке, прежде чем клиентский код сможет его использовать.
		    """

		    def specific_request(self) -> str:
		        return ".eetpadA eht fo roivaheb laicepS"


		class Adapter(Target):
		    """
		    Адаптер делает интерфейс Адаптируемого класса совместимым с целевым
		    интерфейсом.
		    """

		    def __init__(self, adaptee: Adaptee) -> None:
		        self.adaptee = adaptee

		    def request(self) -> str:
		        return self.adaptee.specific_request()


		def client_code(target: Target) -> None:
		    """
		    Клиентский код поддерживает все классы, использующие интерфейс Target.
		    """

		    target.request()


		if __name__ == "__main__":
		    target = Target()
		    client_code(target)

		    adaptee = Adaptee()
		    adaptee.specific_request()

		    adapter = Adapter(adaptee)
		    client_code(adapter)

Мост (Bridge)

	Структурный паттерн.

	Разделяет бизнес-логику или большой класс на несколько отдельных иерархий, которые потом можно развивать отдельно друг от друга.

	Одна из этих иерархий (абстракция) получит ссылку на объекты другой иерархии (реализация) и будет делегировать им основную работу. Благодаря тому, что все реализации будут следовать общему интерфейсу, их можно будет взаимозаменять внутри абстракции.

	Проблема

		У вас есть класс геометрических Фигур, который имеет подклассы Круг и Квадрат. Вы хотите расширить иерархию фигур по цвету, то есть иметь Красные и Синие фигуры. Но чтобы всё это объединить, вам придётся создать 4 комбинации подклассов, вроде  СиниеКруги и КрасныеКвадраты. При добавлении новых видов фигур и цветов количество комбинаций будет расти в геометрической прогрессии. Например, чтобы ввести в программу фигуры треугольников, придётся создать сразу два новых подкласса треугольников под каждый цвет. После этого новый цвет потребует создания уже трёх классов для всех видов фигур.

	Решение

		Паттерн Мост предлагает заменить наследование композицией. Таким образом, мы можем сделать Цвет отдельным классом с подклассами Красный и  Синий. Класс Фигур получит ссылку на объект Цвета и сможет делегировать ему работу, если потребуется. Такая связь и станет мостом между Фигурами и Цветом. При добавлении новых классов цветов не потребуется трогать классы фигур и наоборот.

	Применимость

		Когда вы хотите разделить монолитный класс, который содержит несколько различных реализаций какой-то функциональности (например, если класс может работать с разными системами баз данных).

		Когда класс нужно расширять в двух независимых плоскостях. Например цвет и фигуры.

		Когда вы хотите, чтобы реализацию можно было бы изменять во время выполнения программы.

		Паттерн Мост особенно полезен когда вам приходится делать кросс-платформенные приложения, поддерживать несколько типов баз данных или работать с разными поставщиками похожего API.

	Пример на python

		from __future__ import annotations
		from abc import ABC, abstractmethod


		class Abstraction:
		    def __init__(self, implementation: Implementation) -> None:
		        self.implementation = implementation

		    def operation(self) -> str:
		        return self.implementation.operation_implementation()


		class ExtendedAbstraction(Abstraction):
		    """
		    Можно расширить Абстракцию без изменения классов Реализации.
		    """

		    def operation(self) -> str:
		        return self.implementation.operation_implementation()


		class Implementation(ABC):
		    """
		    Реализация устанавливает интерфейс для всех классов реализации. Он не должен соответствовать интерфейсу Абстракции.
		    """

		    @abstractmethod
		    def operation_implementation(self) -> str:
		        pass


		"""
		Каждая Конкретная Реализация соответствует определённой платформе и реализует
		интерфейс Реализации.
		"""


		class ConcreteImplementationA(Implementation):
		    def operation_implementation(self) -> str:
		        return "ConcreteImplementationA"


		class ConcreteImplementationB(Implementation):
		    def operation_implementation(self) -> str:
		        return "ConcreteImplementationB"


		def client_code(abstraction: Abstraction) -> None:
		    """
		    Клиентский код должен зависеть только от класса Абстракции. Таким образом, клиентский код может поддерживать любую комбинацию абстракции и реализации.
		    """

		    print(abstraction.operation())


		if __name__ == "__main__":
		    """
		    Клиентский код должен работать с любой предварительно сконфигурированной
		    комбинацией абстракции и реализации.
		    """

		    implementation = ConcreteImplementationA()
		    abstraction = Abstraction(implementation)
		    client_code(abstraction)

		    implementation = ConcreteImplementationB()
		    abstraction = ExtendedAbstraction(implementation)
		    client_code(abstraction)

Компоновщик (Дерево, Composite)

	Структурный паттерн.

	Позволяет сгруппировать множество объектов в древовидную структуру, а затем работать с ней так, как будто это единичный объект.

	Проблема

		Например, есть два объекта: Продукт и Коробка. Коробка может содержать несколько  Продуктов и других Коробок поменьше. Те, в свою очередь, тоже содержат либо  Продукты, либо Коробки и так далее. Теперь предположим, ваши Продукты и Коробки могут быть частью заказов. Каждый заказ может содержать как простые Продукты без упаковки, так и составные Коробки. Ваша задача состоит в том, чтобы узнать цену всего заказа.

		Если решать задачу в лоб, то вам потребуется открыть все коробки заказа, перебрать все продукты и посчитать их суммарную стоимость. Но это слишком хлопотно, так как типы коробок и их содержимое могут быть вам неизвестны. Кроме того, наперёд неизвестно и количество уровней вложенности коробок, поэтому перебрать коробки простым циклом не выйдет.

	Решение

		Компоновщик предлагает рассматривать Продукт и Коробку через единый интерфейс с общим методом получения стоимости. Продукт просто вернёт свою цену. Коробка спросит цену каждого предмета внутри себя и вернёт сумму результатов. Если одним из внутренних предметов окажется коробка поменьше, она тоже будет перебирать своё содержимое, и так далее, пока не будут посчитаны все составные части.

	Применимость

		Когда вам нужно представить древовидную структуру объектов.

		Компоновщик давно стал синонимом всех задач, связанных с построением дерева объектов.

	Пример на python

		class Unit:
		    """Абстрактный компонент, в данном случае это - отряд (отряд может
		    состоять из одного солдата или более)
		    """

		    @abstractmethod
		    def show_name(self):
		        """Вывод данных о компоненте отряда"""
		        pass


		class Archer(Unit):
		    """Лучник"""

		    def show_name(self):
		        print('лучник')


		class Knight(Unit):
		    """Рыцарь"""

		    def show_name(self):
		        print('рыцарь')


		class Swordsman(Unit):
		    """Мечник"""

		    def show_name(self):
		        print('мечник')


		class Squad(Unit):
		    """Компоновщик - отряд, состоящий более чем из одного человека."""

		    def __init__(self):
		        self._units = []

		    def show_name(self):
		        for unit in self._units:
		            unit.show_name()

		    def add(self, unit):
		        """Добавление нового отряда"""
		        self._units.append(unit)

		    def remove(self, unit: Unit):
		        """Удаление отряда из текущего компоновщика"""
		        for u in self._units:
		            if u == unit:
		                self._units.remove(u)
		                u.print()
		                break
		        else:
		            unit.print()


		if __name__ == '__main__':
		    squad = Squad()
		    squad.add(Knight())
		    squad.add(Knight())
		    squad.add(Archer())

		    swordsman = Swordsman()
		    squad.add(swordsman)
		    squad.remove(swordsman)

		    squad.show_name()

		    squad_big = Squad()
		    squad_big.add(Swordsman())
		    squad_big.add(Swordsman())
		    squad_big.add(squad)

		    squad_big.show_name()

		------------------------------------

		from __future__ import annotations
		from abc import ABC, abstractmethod
		from typing import List


		class Component(ABC):
		    """
		    Базовый класс Компонент объявляет общие операции как для простых, так и для сложных объектов структуры.
		    """

		    @property
		    def parent(self) -> Component:
		        return self._parent

		    @parent.setter
		    def parent(self, parent: Component):
		        """
		        При необходимости базовый Компонент может объявить интерфейс для
		        установки и получения родителя компонента в древовидной структуре.
		        """

		        self._parent = parent

		    """
		    В некоторых случаях целесообразно определить операции управления потомками
		    прямо в базовом классе Компонент. Таким образом, вам не нужно будет
		    предоставлять конкретные классы компонентов клиентскому коду, даже во время сборки дерева объектов.
		    """

		    def add(self, component: Component) -> None:
		        pass

		    def remove(self, component: Component) -> None:
		        pass

		    def is_composite(self) -> bool:
		        """
		        Вы можете предоставить метод, который позволит клиентскому коду понять, может ли компонент иметь вложенные объекты.
		        """

		        return False

		    @abstractmethod
		    def operation(self) -> str:
		        """
		        Базовый Компонент может сам реализовать некоторое поведение по умолчанию или поручить это конкретным классам, объявив метод, содержащий поведение абстрактным.
		        """

		        pass


		class Leaf(Component):
		    """
		    Класс Лист представляет собой конечные объекты. Лист не может
		    иметь вложенных компонентов.

		    Обычно объекты Листьев выполняют фактическую работу, тогда как объекты
		    Контейнера лишь делегируют работу своим подкомпонентам.
		    """

		    def operation(self) -> str:
		        return "Leaf"


		class Composite(Component):
		    """
		    Класс Контейнер содержит сложные компоненты, которые могут иметь вложенные
		    компоненты. 

		    Обычно объекты Контейнеры делегируют фактическую работу своим
		    детям, а затем «суммируют» результат.
		    """

		    def __init__(self) -> None:
		        self._children: List[Component] = []

		    """
		    Объект контейнера может как добавлять компоненты в свой список вложенных
		    компонентов, так и удалять их.
		    """

		    def add(self, component: Component) -> None:
		        self._children.append(component)
		        component.parent = self

		    def remove(self, component: Component) -> None:
		        self._children.remove(component)
		        component.parent = None

		    def is_composite(self) -> bool:
		        return True

		    def operation(self) -> str:
		        """
		        Контейнер выполняет свою основную логику особым образом. Он проходит
		        рекурсивно через всех своих детей, собирая и суммируя их результаты.
		        """

		        results = []
		        for child in self._children:
		            results.append(child.operation())
		        return '+'.join(results)


		def client_code(component: Component) -> None:
		    """
		    Клиентский код работает со всеми компонентами через базовый интерфейс.
		    """

		    print(component.operation())


		def client_code2(component1: Component, component2: Component) -> None:
		    if component1.is_composite():
		        component1.add(component2)

		    print(component1.operation())


		if __name__ == "__main__":
		    # Таким образом, клиентский код может поддерживать простые
		    # компоненты-листья...
		    simple = Leaf()
		    client_code(simple)

		    # ...а также сложные контейнеры.
		    tree = Composite()

		    branch1 = Composite()
		    branch1.add(Leaf())
		    branch1.add(Leaf())

		    branch2 = Composite()
		    branch2.add(Leaf())

		    tree.add(branch1)
		    tree.add(branch2)

		    client_code(tree)
		    client_code2(tree, simple)

Декоратор (Обёртка, Decorator)

	Структурный паттерн.

	Позволяет динамически добавлять объектам новую функциональность, оборачивая их в обёртки.

	Декоратор позволяет оборачивать объекты бесчисленное количество раз благодаря тому, что и обёртки, и реальные оборачиваемые объекты имеют общий интерфейс.

	Проблема

		Вы работаете над библиотекой оповещений, которую можно подключать к разнообразным программам, чтобы получать уведомления о важных событиях. Основой библиотеки является класс Notifier с методом send, который принимает на вход строку-сообщение и высылает её всем администраторам по электронной почте. Сторонняя программа должна создать и настроить этот объект, указав кому отправлять оповещения, а затем использовать его каждый раз, когда что-то случается. В какой-то момент стало понятно, что одних email-оповещений пользователям мало. Некоторые из них хотели бы получать извещения о критических проблемах через SMS. Другие хотели бы получать их в виде сообщений Facebook. Корпоративные пользователи хотели бы видеть сообщения в Slack. Сначала вы добавили каждый из этих типов оповещений в программу, унаследовав их от базового класса Notifier. Теперь пользователь выбирал один из типов оповещений, который и использовался в дальнейшем. Но затем кто-то резонно спросил, почему нельзя выбрать несколько типов оповещений сразу? Ведь если вдруг в вашем доме начался пожар, вы бы хотели получить оповещения по всем каналам, не так ли? Вы попытались реализовать все возможные комбинации подклассов оповещений. Но после того как вы добавили первый десяток классов, стало ясно, что такой подход невероятно раздувает код программы.

	Решение

		Вы помещаете целевой объект в другой объект-обёртку, который запускает базовое поведение объекта, а затем добавляет к результату что-то свое.

		Любая одежда - это аналог Декоратора. Применяя Декоратор, вы не меняете первоначальный класс и не создаёте дочерних классов. Так и с одеждой — надевая свитер, вы не перестаёте быть собой, но получаете новое свойство — защиту от холода. Вы можете пойти дальше и надеть сверху ещё один декоратор — плащ, чтобы защититься и от дождя.

	Применимость

		Когда вам нужно добавлять обязанности объектам на лету, незаметно для кода, который их использует.

		Когда нельзя расширить обязанности объекта с помощью наследования. Во многих языках программирования есть ключевое слово final, которое может заблокировать наследование класса. Расширить такие классы можно только с помощью Декоратора.

	Пример на python

		class Component():
		    """
		    Базовый интерфейс Компонента определяет поведение, которое изменяется
		    декораторами.
		    """

		    def operation(self) -> str:
		        pass


		class ConcreteComponent(Component):
		    """
		    Конкретные Компоненты предоставляют реализации поведения по умолчанию.
		    """

		    def operation(self) -> str:
		        return "ConcreteComponent"


		class Decorator(Component):
		    """
		    Базовый класс Декоратора следует тому же интерфейсу, что и другие
		    компоненты. 

		    Основная цель этого класса - определить интерфейс обёртки для
		    всех конкретных декораторов. 

		    Реализация кода обёртки по умолчанию может включать в себя поле для хранения завёрнутого компонента и средства его инициализации.
		    """

		    _component: Component = None

		    def __init__(self, component: Component) -> None:
		        self._component = component

		    @property
		    def component(self) -> str:
		        """
		        Декоратор делегирует всю работу обёрнутому компоненту.
		        """

		        return self._component

		    def operation(self) -> str:
		        self._component.operation()


		class ConcreteDecoratorA(Decorator):
		    """
		    Конкретные Декораторы вызывают обёрнутый объект и изменяют его результат
		    некоторым образом.
		    """

		    def operation(self):
		        """
		        Декораторы могут вызывать родительскую реализацию операции, вместо того, чтобы вызвать обёрнутый объект напрямую. 

		        Такой подход упрощает расширение классов декораторов.
		        """

		        return self.component.operation()


		class ConcreteDecoratorB(Decorator):
		    def operation(self) -> str:
		        return self.component.operation()


		def client_code(component: Component) -> None:
		    component.operation()


		if __name__ == "__main__":
		    # Таким образом, клиентский код может поддерживать как простые компоненты...
		    simple = ConcreteComponent()
		    client_code(simple)


		    # ...так и декорированные.
		    #
		    # Обратите внимание, что декораторы могут обёртывать не только простые
		    # компоненты, но и другие декораторы.
		    decorator1 = ConcreteDecoratorA(simple)
		    decorator2 = ConcreteDecoratorB(decorator1)
		    client_code(decorator2)

Фасад (Facade)

	Структурный паттерн.

	Предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку.

	Фасад позволяет снизить общую сложность программы и помогает вынести код, зависимый от внешней системы в единственное место.

	Проблема

		Вашему коду приходится работать с большим количеством объектов некой сложной библиотеки или фреймворка. Вы должны самостоятельно инициализировать эти объекты, следить за правильным порядком зависимостей и так далее. В результате бизнес-логика ваших классов тесно переплетается с деталями реализации сторонних классов. Такой код довольно сложно понимать и поддерживать.

	Решение

		Фасад - это простой интерфейс для работы со сложной подсистемой, содержащей множество классов. Фасад может иметь урезанный интерфейс, не имеющий 100% функциональности, которой можно достичь, используя сложную подсистему напрямую. Но он предоставляет именно те фичи, которые нужны клиенту, и скрывает все остальные. К примеру, программа, заливающая видео котиков в социальные сети, может использовать профессиональную библиотеку сжатия видео. Но все, что нужно клиентскому коду этой программы — простой метод encode(filename, format). Создав класс с таким методом, вы реализуете свой первый фасад.

		Когда вы звоните в магазин и делаете заказ по телефону, сотрудник службы поддержки является вашим фасадом ко всем службам и отделам магазина. Он предоставляет вам упрощённый интерфейс к системе создания заказа, платёжной системе и отделу доставки.

	Применимость

		Когда вам нужно представить простой или урезанный интерфейс к сложной подсистеме.

		Когда вы хотите разложить подсистему на отдельные слои.

	Пример на python

		from __future__ import annotations


		class Facade:
		    """
		    Класс Фасада предоставляет простой интерфейс для сложной логики одной или
		    нескольких подсистем. 

		    Фасад делегирует запросы клиентов соответствующим объектам внутри подсистемы.
		    """

		    def __init__(self, subsystem1: Subsystem1, subsystem2: Subsystem2) -> None:
		        """
		        В зависимости от потребностей вашего приложения вы можете предоставить
		        Фасаду существующие объекты подсистемы или заставить Фасад создать их
		        самостоятельно.

		        Некоторые фасады могут работать с разными подсистемами одновременно.
		        """

		        self._subsystem1 = subsystem1 or Subsystem1()
		        self._subsystem2 = subsystem2 or Subsystem2()

		    def operation(self) -> str:
		        """
		        Методы Фасада удобны для быстрого доступа к сложной функциональности
		        подсистем. Однако клиенты получают только часть возможностей подсистемы.
		        """

		        results = []
		        results.append(self._subsystem1.operation1())
		        results.append(self._subsystem2.operation1())
		        results.append(self._subsystem1.operation_n())
		        results.append(self._subsystem2.operation_z())

		        return "\n".join(results)


		class Subsystem1:
		    """
		    Подсистема может принимать запросы либо от фасада, либо от клиента напрямую.
		    В любом случае, для Подсистемы Фасад – это ещё один клиент, и он не является
		    частью Подсистемы.
		    """

		    def operation1(self) -> str:
		        return "Subsystem1"

		    def operation_n(self) -> str:
		        return "Subsystem1"


		class Subsystem2:
		    def operation1(self) -> str:
		        return "Subsystem2"

		    def operation_z(self) -> str:
		        return "Subsystem2: Fire!"


		def client_code(facade: Facade) -> None:
		    """
		    Клиентский код работает со сложными подсистемами через простой интерфейс,
		    предоставляемый Фасадом. 

		    Когда фасад управляет жизненным циклом подсистемы, клиент может даже не знать о существовании подсистемы. Такой подход позволяет держать сложность под контролем.
		    """

		    print(facade.operation())


		if __name__ == "__main__":
		    subsystem1 = Subsystem1()
		    subsystem2 = Subsystem2()
		    facade = Facade(subsystem1, subsystem2)
		    client_code(facade)

Легковес (Приспособленец, Кэш, Flyweight)

	Структурный паттерн.

	Позволяет вместить бóльшее количество объектов в отведённую оперативную память. 

	Легковес экономит память, разделяя общее состояние объектов между собой, вместо хранения одинаковых данных в каждом объекте.

	Проблема

		На досуге вы решили написать небольшую игру, в которой игроки перемещаются по карте и стреляют друг в друга. Фишкой игры должна была стать реалистичная система частиц. Пули, снаряды, осколки от взрывов - всё это должно красиво летать и радовать взгляд. Игра отлично работала на вашем мощном компьютере. Однако ваш друг сообщил, что игра начинает тормозить и вылетает через несколько минут после запуска. Покопавшись в логах, вы обнаружили, что игра вылетает из-за недостатка оперативной памяти. У вашего друга компьютер значительно менее «прокачанный», поэтому проблема у него и проявляется так быстро. И действительно, каждая частица представлена собственным объектом, имеющим множество данных. В определённый момент, когда побоище на экране достигает кульминации, новые объекты частиц уже не вмещаются в оперативную память компьютера, и программа вылетает.

	Решение

		Если внимательно посмотреть на класс частиц, то можно заметить, что цвет и спрайт занимают больше всего памяти. Более того, они хранятся в каждом объекте, хотя фактически их значения одинаковы для большинства частиц.

		Остальное состояние объектов - координаты, вектор движения и скорость - отличаются для всех частиц. А цвет и спрайт — это данные, не изменяющиеся во времени.

		Неизменяемые данные объекта принято называть «внутренним состоянием». Все остальные данные - это «внешнее состояние».

		Паттерн Легковес предлагает не хранить в классе внешнее состояние, а передавать его в те или иные методы через параметры.

		Чаще всего внешнее состояние перемещают в контейнер, который управлял объектами до применения паттерна.

		В нашем примере с частицами достаточно будет оставить всего три объекта с отличающимися спрайтами и цветом - для пуль, снарядов и осколков.

		Так как объекты легковесов будут использованы в разных контекстах, вы должны быть уверены в том, что их состояние невозможно изменить после создания. Всё внутреннее состояние легковес должен получать через параметры конструктора. Он не должен иметь сеттеров и публичных полей.

	Применимость

		Когда не хватает оперативной памяти для поддержки всех нужных объектов.

	Пример на python

		import json
		from typing import Dict


		class Flyweight():
		    """
		    Легковес хранит общую часть состояния (также называемую внутренним
		    состоянием), которая принадлежит нескольким реальным бизнес-объектам.

		    Легковес принимает оставшуюся часть состояния (внешнее состояние, уникальное
		    для каждого объекта) через его параметры метода.
		    """

		    def __init__(self, shared_state: str) -> None:
		        self._shared_state = shared_state

		    def operation(self, unique_state: str) -> None:
		        s = json.dumps(self._shared_state)
		        u = json.dumps(unique_state)


		class FlyweightFactory():
		    """
		    Фабрика Легковесов создает объекты-Легковесы и управляет ими. Она
		    обеспечивает правильное разделение легковесов. Когда клиент запрашивает
		    легковес, фабрика либо возвращает существующий экземпляр, либо создает
		    новый, если он ещё не существует.
		    """

		    _flyweights: Dict[str, Flyweight] = {}

		    def __init__(self, initial_flyweights: Dict) -> None:
		        for state in initial_flyweights:
		            self._flyweights[self.get_key(state)] = Flyweight(state)

		    def get_key(self, state: Dict) -> str:
		        """
		        Возвращает хеш строки Легковеса для данного состояния.
		        """

		        return "_".join(sorted(state))

		    def get_flyweight(self, shared_state: Dict) -> Flyweight:
		        """
		        Возвращает существующий Легковес с заданным состоянием или создает
		        новый.
		        """

		        key = self.get_key(shared_state)

		        if not self._flyweights.get(key):
		            print("FlyweightFactory: Can't find a flyweight, creating new one.")
		            self._flyweights[key] = Flyweight(shared_state)
		        else:
		            print("FlyweightFactory: Reusing existing flyweight.")

		        return self._flyweights[key]

		    def list_flyweights(self) -> None:
		        count = len(self._flyweights)
		        print("\n".join(map(str, self._flyweights.keys())), end="")


		def add_car_to_police_database(
		    factory: FlyweightFactory, plates: str, owner: str,
		    brand: str, model: str, color: str
		) -> None:

		    flyweight = factory.get_flyweight([brand, model, color])
		    # Клиентский код либо сохраняет, либо вычисляет внешнее состояние и передает
		    # его методам легковеса.
		    flyweight.operation([plates, owner])


		if __name__ == "__main__":
		    """
		    Клиентский код обычно создает кучу предварительно заполненных легковесов на
		    этапе инициализации приложения.
		    """

		    factory = FlyweightFactory([
		        ["Chevrolet", "Camaro2018", "pink"],
		        ["Mercedes Benz", "C300", "black"],
		        ["Mercedes Benz", "C500", "red"],
		        ["BMW", "M5", "red"],
		        ["BMW", "X6", "white"],
		    ])

		    factory.list_flyweights()

		    add_car_to_police_database(
		        factory, 
		        "CL234IR", 
		        "James Doe", 
		        "BMW", 
		        "M5", 
		        "red"
		    )

		    add_car_to_police_database(
		        factory, 
		        "CL234IR", 
		        "James Doe", 
		        "BMW", 
		        "X1", 
		        "red"
		    )
		    
		    factory.list_flyweights()

Заместитель (Proxy)

	Cтруктурный паттерн.

	Позволяет подставлять вместо реальных объектов специальные объекты-заменители. 

	Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу.

	Заместитель получает вызовы от клиента, выполняет свою функцию (контроль доступа, кеширование, изменение запроса и прочее), а затем передаёт вызов сервисному оригиналу.

	Заместитель имеет тот же интерфейс, что и реальный объект, поэтому для клиента нет разницы — работать через заместителя или напрямую.

	Проблема

		У вас есть внешний ресурсоёмкий объект, который нужен не все время, а изредка. Мы могли бы создавать этот объект не в самом начале программы, а только тогда, когда он кому-то реально понадобится. Каждый клиент объекта получил бы некий код отложенной инициализации. Но, вероятно, это привело бы к множественному дублированию кода. В идеале, этот код хотелось бы поместить прямо в служебный класс, но это не всегда возможно. Например, код класса может находиться в закрытой сторонней библиотеке.

	Решение

		Паттерн Заместитель предлагает создать новый класс-дублёр, имеющий тот же интерфейс, что и оригинальный служебный объект. При получении запроса от клиента объект-заместитель сам бы создавал экземпляр служебного объекта и переадресовывал бы ему всю реальную работу.

		Банковский чек — это заместитель пачки наличных. И чек, и наличные имеют общий интерфейс — ими можно оплачивать товары. Для покупателя польза в том, что не надо таскать с собой тонны наличных, а владелец магазина может превратить чек в зелёные бумажки, обратившись в банк.

	Применимость

		Наиболее распространёнными областями применения паттерна Заместитель являются ленивая загрузка, кэширование, контроль доступа, ведение журнала и т.д.

		Ленивая инициализация (виртуальный прокси). Когда у вас есть тяжёлый объект, грузящий данные из файловой системы или базы данных.

		Защита доступа (защищающий прокси). Когда в программе есть разные типы пользователей, и вам хочется защищать объект от неавторизованного доступа. Например, если ваши объекты — это важная часть операционной системы, а пользователи — сторонние программы (хорошие или вредоносные).

		Локальный запуск сервиса (удалённый прокси). Когда настоящий сервисный объект находится на удалённом сервере.

		Логирование запросов (логирующий прокси). Когда требуется хранить историю обращений к сервисному объекту.

		Кеширование объектов («умная» ссылка). Когда нужно кешировать результаты запросов клиентов и управлять их жизненным циклом.

	Пример на python

		from abc import ABC, abstractmethod


		class Subject(ABC):
		    """
		    Интерфейс Субъекта объявляет общие операции как для Реального Субъекта, так
		    и для Заместителя. 

		    Пока клиент работает с Реальным Субъектом, используя этот интерфейс, вы сможете передать ему заместителя вместо реального субъекта.
		    """

		    @abstractmethod
		    def request(self) -> None:
		        pass


		class RealSubject(Subject):
		    """
		    Реальный Субъект содержит некоторую базовую бизнес-логику. Как правило,
		    Реальные Субъекты способны выполнять некоторую полезную работу, которая к
		    тому же может быть очень медленной или точной – например, коррекция входных
		    данных. Заместитель может решить эти задачи без каких-либо изменений в коде
		    Реального Субъекта.
		    """

		    def request(self) -> None:
		        print("RealSubject")


		class Proxy(Subject):
		    """
		    Интерфейс Заместителя идентичен интерфейсу Реального Субъекта.
		    """

		    def __init__(self, real_subject: RealSubject) -> None:
		        self._real_subject = real_subject

		    def request(self) -> None:
		        """
		        Наиболее распространёнными областями применения паттерна Заместитель
		        являются ленивая загрузка, кэширование, контроль доступа, ведение
		        журнала и т.д. Заместитель может выполнить одну из этих задач, а затем,
		        в зависимости от результата, передать выполнение одноимённому методу в
		        связанном объекте класса Реального Субъекта.
		        """

		        if self.check_access():
		            self._real_subject.request()
		            self.log_access()

		    def check_access(self) -> bool:
		        print("Proxy: Checking access prior to firing a real request.")
		        return True

		    def log_access(self) -> None:
		        print("Proxy: Logging the time of request.", end="")


		def client_code(subject: Subject) -> None:
		    """
		    Клиентский код должен работать со всеми объектами (как с реальными, так и
		    заместителями) через интерфейс Субъекта, чтобы поддерживать как реальные
		    субъекты, так и заместителей.
		    """

		    subject.request()


		if __name__ == "__main__":
		    real_subject = RealSubject()
		    client_code(real_subject)

		    proxy = Proxy(real_subject)
		    client_code(proxy)

Поведенческие

	Решают задачи эффективного и безопасного взаимодействия между объектами программы.

	Список: Цепочка обязанностей, команда, итератор, посредник, снимок, наблюдатель, состояние, стратегия, шаблонный метод, посетитель.

Цепочка обязанностей (CoR, Chain of Command, Chain of Responsibility)

	Поведенческий паттерн.

	Позволяет передавать запрос последовательно по цепочке обработчиков, пока один из них не обработает запрос.

	Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи.

	Проблема

		Представьте, что вы делаете систему приёма онлайн-заказов. Вы хотите ограничить к ней доступ так, чтобы только авторизованные пользователи могли создавать заказы. Кроме того, определённые пользователи, владеющие правами администратора, должны иметь полный доступ к заказам. Вы быстро сообразили, что эти проверки нужно выполнять последовательно. Ведь пользователя можно попытаться «залогинить» в систему, если его запрос содержит логин и пароль. Но если такая попытка не удалась, то проверять расширенные права доступа попросту не имеет смысла. На протяжении следующих нескольких месяцев вам пришлось добавить ещё несколько таких последовательных проверок. С каждой новой «фичей» код проверок, выглядящий как большой клубок условных операторов, всё больше и больше раздувался. При изменении одного правила приходилось трогать код всех проверок. А для того, чтобы применить проверки к другим ресурсам, пришлось продублировать их код в других классах. Поддерживать такой код стало не только очень хлопотно, но и затратно. И вот в один прекрасный день вы получаете задачу рефакторинга...

	Решение

		Цепочка обязанностей базируется на том, чтобы превратить отдельные поведения в объекты. В нашем случае каждая проверка переедет в отдельный класс с единственным методом выполнения. Данные запроса, над которым происходит проверка, будут передаваться в метод как аргументы. При этом паттерн предлагает связать объекты обработчиков в одну цепь. Каждый из них будет иметь ссылку на следующий обработчик в цепи. Таким образом, при получении запроса обработчик сможет не только сам что-то с ним сделать, но и передать обработку следующему объекту в цепочке. Каждый из бработчик не обязательно должен передавать запрос дальше, потому что если текущая проверка не прошла. Ведь нет смысла тратить попусту ресурсы, если и так понятно, что с запросом что-то не так.

		Но есть и другой подход, при котором обработчики прерывают цепь только когда они могут обработать запрос. В этом случае запрос движется по цепи, пока не найдётся обработчик, который может его обработать.

		Вы купили новую видеокарту. Она автоматически определилась и заработала под Windows, но в вашей любимой Ubuntu «завести» её не удалось. Со слабой надеждой вы звоните в службу поддержки. Первым вы слышите голос автоответчика, предлагающий выбор из десятка стандартных решений. Ни один из вариантов не подходит, и робот соединяет вас с живым оператором. Увы, но рядовой оператор поддержки умеет общаться только заученными фразами и давать шаблонные ответы. После очередного предложения «выключить и включить компьютер» вы просите связать вас с настоящими инженерами. Оператор перебрасывает звонок дежурному инженеру, изнывающему от скуки в своей каморке. Уж он-то знает, как вам помочь! Инженер рассказывает вам, где скачать подходящие драйвера и как настроить их под Ubuntu. Запрос удовлетворён. Вы кладёте трубку.
		
	Применимость

		Когда программа должна обрабатывать разнообразные запросы несколькими способами, но заранее неизвестно, какие конкретно запросы будут приходить и какие обработчики для них понадобятся.

		Когда важно, чтобы обработчики выполнялись один за другим в строгом порядке.

		Когда набор объектов, способных обработать запрос, должен задаваться динамически.

	Пример на python

		from __future__ import annotations
		from abc import ABC, abstractmethod
		from typing import Any, Optional


		class Handler(ABC):
		    """
		    Интерфейс Обработчика объявляет метод построения цепочки обработчиков.

		    Он также объявляет метод для выполнения запроса.
		    """

		    @abstractmethod
		    def set_next(self, handler: Handler) -> Handler:
		        pass

		    @abstractmethod
		    def handle(self, request) -> Optional[str]:
		        pass


		class AbstractHandler(Handler):
		    """
		    Поведение цепочки по умолчанию может быть реализовано внутри базового класса
		    обработчика.
		    """

		    _next_handler: Handler = None

		    def set_next(self, handler: Handler) -> Handler:
		        self._next_handler = handler

		        # Возврат обработчика отсюда позволит связать обработчики простым
		        # способом, вот так:
		        # monkey.set_next(squirrel).set_next(dog)
		        return handler

		    @abstractmethod
		    def handle(self, request: Any) -> str:
		        if self._next_handler:
		            return self._next_handler.handle(request)

		        return None


		"""
		Все Конкретные Обработчики либо обрабатывают запрос, либо передают его
		следующему обработчику в цепочке.
		"""


		class MonkeyHandler(AbstractHandler):
		    def handle(self, request: Any) -> str:
		        if request == "Banana":
		            return request
		        else:
		            return super().handle(request)


		class SquirrelHandler(AbstractHandler):
		    def handle(self, request: Any) -> str:
		        if request == "Nut":
		            return request
		        else:
		            return super().handle(request)


		class DogHandler(AbstractHandler):
		    def handle(self, request: Any) -> str:
		        if request == "MeatBall":
		            return request
		        else:
		            return super().handle(request)


		def client_code(handler: Handler) -> None:
		    """
		    Обычно клиентский код приспособлен для работы с единственным обработчиком. 

		    В большинстве случаев клиенту даже неизвестно, что этот обработчик является
		    частью цепочки.
		    """

		    for food in ["Nut", "Banana", "Cup of coffee"]:
		        result = handler.handle(food)
		        if result:
		            print(result)
		        else:
		            print(food)


		if __name__ == "__main__":
		    monkey = MonkeyHandler()
		    squirrel = SquirrelHandler()
		    dog = DogHandler()

		    monkey.set_next(squirrel).set_next(dog)

		    # Клиент должен иметь возможность отправлять запрос любому обработчику, а не
		    # только первому в цепочке.
		    client_code(monkey)
		    client_code(squirrel)

Команда (Действие, Транзакция, Action, Command)

	Поведенческий паттерн.

	Позволяет заворачивать запросы или простые операции в отдельные объекты, позволяя передавать их как аргументы при вызове методов, ставить в очередь, логировать, а также поддерживать отмену операций.

	Проблема

		Представьте, что вы работаете над программой текстового редактора. Дело как раз подошло к разработке панели управления. Вы создали класс красивых Кнопок и хотите использовать его для всех кнопок приложения, начиная от панели управления, заканчивая простыми кнопками в диалогах. Все эти кнопки, хоть и выглядят схоже, но делают разные вещи. Поэтому возникает вопрос: куда поместить код обработчиков кликов по этим кнопкам? Самым простым решением было бы создать подклассы для каждой кнопки и переопределить в них метод действия под разные задачи. Но скоро стало понятно, что такой подход никуда не годится. Во-первых, получается очень много подклассов. Во-вторых, код кнопок, относящийся к графическому интерфейсу, начинает зависеть от классов бизнес-логики, которая довольно часто меняется.

	Решение

		Хорошие программы обычно структурированы в виде слоёв. Самый распространённый пример - слои пользовательского интерфейса и бизнес-логики. Первый всего лишь рисует красивую картинку для пользователя. Но когда нужно сделать что-то важное, интерфейс «просит» слой бизнес-логики заняться этим. В реальности это выглядит так: один из объектов интерфейса напрямую вызывает метод одного из объектов бизнес-логики, передавая в него какие-то параметры - update(2, John)

		Паттерн Команда предлагает больше не отправлять такие вызовы напрямую. Вместо этого вызов для каждого элемента, отличающегося друг от друга (кнопка закрытия, кнопка сохранения), следует завернуть в собственный класс с единственным методом, который и будет осуществлять вызов. Такие объекты называют командами.

		К объекту интерфейса можно будет привязать объект команды. Когда объект интерфейса будет готов передать запрос, он вызовет метод команды, а та - позаботится обо всём остальном.

		Вы заходите в ресторан и садитесь у окна. К вам подходит вежливый официант и принимает заказ, записывая все пожелания в блокнот. Откланявшись, он уходит на кухню, где вырывает лист из блокнота и клеит на стену. Далее лист оказывается в руках повара, который читает содержание заказа и готовит заказанные блюда. В этом примере вы являетесь отправителем, официант с блокнотом - командой, а повар - получателем. Как и в паттерне, вы не соприкасаетесь напрямую с поваром. Вместо этого вы отправляете заказ с официантом, который самостоятельно «настраивает» повара на работу. С другой стороны, повар не знает, кто конкретно послал ему заказ. Но это ему безразлично, так как вся необходимая информация есть в листе заказа.

	Применимость

		...

	Пример на python

		from __future__ import annotations
		from abc import ABC, abstractmethod


		class Command(ABC):
		    """
		    Интерфейс Команды объявляет метод для выполнения команд.
		    """

		    @abstractmethod
		    def execute(self) -> None:
		        pass


		class SimpleCommand(Command):
		    """
		    Некоторые команды способны выполнять простые операции самостоятельно.
		    """

		    def __init__(self, payload: str) -> None:
		        self._payload = payload

		    def execute(self) -> None:
		        print(self._payload)


		class ComplexCommand(Command):
		    """
		    Но есть и команды, которые делегируют более сложные операции другим
		    объектам, называемым «получателями».
		    """

		    def __init__(self, receiver: Receiver, a: str, b: str) -> None:
		        """
		        Сложные команды могут принимать один или несколько объектов-получателей
		        вместе с любыми данными о контексте через конструктор.
		        """

		        self._receiver = receiver
		        self._a = a
		        self._b = b

		    def execute(self) -> None:
		        """
		        Команды могут делегировать выполнение любым методам получателя.
		        """

		        self._receiver.do_something(self._a)
		        self._receiver.do_something_else(self._b)


		class Receiver:
		    """
		    Классы Получателей содержат некую важную бизнес-логику. Они умеют выполнять
		    все виды операций, связанных с выполнением запроса.
		    """

		    def do_something(self, a: str) -> None:
		        print(a)

		    def do_something_else(self, b: str) -> None:
		        print(b)


		class Invoker:
		    """
		    Отправитель связан с одной или несколькими командами. Он отправляет запрос
		    команде.
		    """

		    _on_start = None
		    _on_finish = None

		    """
		    Инициализация команд.
		    """

		    def set_on_start(self, command: Command):
		        self._on_start = command

		    def set_on_finish(self, command: Command):
		        self._on_finish = command

		    def do_something_important(self) -> None:
		        """
		        Отправитель не зависит от классов конкретных команд и получателей.
		        Отправитель передаёт запрос получателю косвенно, выполняя команду.
		        """

		        if isinstance(self._on_start, Command):
		            self._on_start.execute()

		        if isinstance(self._on_finish, Command):
		            self._on_finish.execute()


		if __name__ == "__main__":
		    """
		    Клиентский код может параметризовать отправителя любыми командами.
		    """

		    invoker = Invoker()
		    invoker.set_on_start(SimpleCommand("Say Hi!"))
		    
		    receiver = Receiver()
		    invoker.set_on_finish(
		        ComplexCommand(receiver, "Send email", "Save report")
		    )
		    invoker.do_something_important()

Итератор (Iterator)

	Поведенческий паттерн.

	Даёт возможность последовательно обходить сложную коллекцию, без раскрытия деталей её реализации.

	Проблема

		Коллекции — самая распространённая структура данных, которую вы можете встретить в программировании. Это набор объектов, собранный в одну кучу по каким-то критериям.

		Большинство коллекций выглядят как обычный список элементов. Но есть и экзотические коллекции, построенные на основе деревьев, графов и других сложных структур данных.

		Но как бы ни была структурирована коллекция, пользователь должен иметь возможность последовательно обходить её элементы, чтобы проделывать с ними какие-то действия.

		Но каким способом следует перемещаться по сложной структуре данных? Например, сегодня может быть достаточным обход дерева в глубину, но завтра потребуется возможность перемещаться по дереву в ширину. А на следующей неделе и того хуже — понадобится обход коллекции в случайном порядке.

		Добавляя всё новые алгоритмы в код коллекции, вы понемногу размываете её основную функцию, которая заключается в эффективном хранении данных. Некоторые алгоритмы могут быть и вовсе слишком «заточены» под определённое приложение и смотреться дико в общем классе коллекции.

	Решение

		Идея паттерна Итератор состоит в том, чтобы вынести поведение обхода коллекции из самой коллекции в отдельный класс.

		Объект-итератор будет отслеживать состояние обхода, текущую позицию в коллекции и сколько элементов ещё осталось обойти. Одну и ту же коллекцию смогут одновременно обходить различные итераторы, а сама коллекция не будет даже знать об этом. 

		К тому же, если вам понадобится добавить новый способ обхода, вы сможете создать отдельный класс итератора, не изменяя существующий код коллекции.

	Применимость

		Когда у вас есть сложная структура данных, и вы хотите скрыть от клиента детали её реализации.

		Когда вам нужно иметь несколько вариантов обхода одной и той же структуры данных.

		Когда вам хочется иметь единый интерфейс обхода различных структур данных.

	Пример на python

		from __future__ import annotations
		from collections.abc import Iterable, Iterator
		from typing import Any, List


		"""
		Для создания итератора в Python есть два абстрактных класса из встроенного
		модуля collections - Iterable, Iterator. Нужно реализовать метод __iter__() в
		итерируемом объекте (списке), а метод __next__() в итераторе.
		"""


		class AlphabeticalOrderIterator(Iterator):
		    """
		    Конкретные Итераторы реализуют различные алгоритмы обхода. Эти классы
		    постоянно хранят текущее положение обхода.
		    """

		    """
		    Атрибут _position хранит текущее положение обхода. У итератора может быть
		    множество других полей для хранения состояния итерации, особенно когда он
		    должен работать с определённым типом коллекции.
		    """
		    _position: int = None

		    """Этот атрибут указывает направление обхода."""
		    _reverse: bool = False

		    def __init__(self, collection: WordsCollection, reverse: bool = False) -> None:
		        self._collection = collection
		        self._reverse = reverse
		        self._position = -1 if reverse else 0

		    def __next__(self):
		        """
		        Метод __next __() должен вернуть следующий элемент в последовательности.
		        При достижении конца коллекции и в последующих вызовах должно вызываться
		        исключение StopIteration.
		        """
		        try:
		            value = self._collection[self._position]
		            self._position += -1 if self._reverse else 1
		        except IndexError:
		            raise StopIteration()

		        return value


		class WordsCollection(Iterable):
		    """
		    Конкретные Коллекции предоставляют один или несколько методов для получения
		    новых экземпляров итератора, совместимых с классом коллекции.
		    """

		    def __init__(self, collection: List[Any] = []) -> None:
		        self._collection = collection

		    def __iter__(self) -> AlphabeticalOrderIterator:
		        """
		        Метод __iter__() возвращает объект итератора, по умолчанию мы возвращаем
		        итератор с сортировкой по возрастанию.
		        """
		        return AlphabeticalOrderIterator(self._collection)

		    def get_reverse_iterator(self) -> AlphabeticalOrderIterator:
		        return AlphabeticalOrderIterator(self._collection, True)

		    def add_item(self, item: Any):
		        self._collection.append(item)


		if __name__ == "__main__":
		    collection = WordsCollection()
		    collection.add_item("First")
		    collection.add_item("Second")
		    collection.add_item("Third")

		    print("\n".join(collection))
		    print("\n".join(collection.get_reverse_iterator()))

Посредник (Intermediary, Controller, Mediator)

	Поведенческий паттерн.

	Позволяет уменьшить связанность множества классов между собой, благодаря перемещению этих связей в один класс-посредник.

	Проблема

		Предположим, что у вас есть диалог создания профиля пользователя. Он состоит из всевозможных элементов управления — текстовых полей, чекбоксов, кнопок.

		Отдельные элементы диалога должны взаимодействовать друг с другом. Так, например, чекбокс «у меня есть собака» открывает скрытое поле для ввода имени домашнего любимца, а клик по кнопке отправки запускает проверку значений всех полей формы.

		Прописав эту логику прямо в коде элементов управления, вы поставите крест на их повторном использовании в других местах приложения. Они станут слишком тесно связанными с элементами диалога редактирования профиля, которые не нужны в других контекстах. Поэтому вы сможете использовать либо все элементы сразу, либо ни одного.

	Решение

		Паттерн Посредник заставляет объекты общаться не напрямую друг с другом, а через отдельный объект-посредник, который знает, кому нужно перенаправить тот или иной запрос. 

		Благодаря этому, компоненты системы будут зависеть только от посредника, а не от десятков других компонентов.

		Пилоты садящихся или улетающих самолётов не общаются напрямую с другими пилотами. Вместо этого они связываются с диспетчером, который координирует действия нескольких самолётов одновременно. Без диспетчера пилотам приходилось бы все время быть начеку и следить за всеми окружающими самолётами самостоятельно, а это приводило бы к частым катастрофам в небе.

	Применимость

		Когда вам сложно менять некоторые классы из-за того, что они имеют множество хаотичных связей с другими классами.

		Когда вы не можете повторно использовать класс, поскольку он зависит от уймы других классов.

		Упрощает коммуникацию между компонентами системы.

	Пример на python

		from __future__ import annotations
		from abc import ABC


		class Mediator(ABC):
		    """
		    Интерфейс Посредника предоставляет метод, используемый компонентами для
		    уведомления посредника о различных событиях. Посредник может реагировать на
		    эти события и передавать исполнение другим компонентам.
		    """

		    def notify(self, sender: object, event: str) -> None:
		        pass


		class ConcreteMediator(Mediator):
		    def __init__(self, component1: Component1, component2: Component2) -> None:
		        self._component1 = component1
		        self._component1.mediator = self
		        self._component2 = component2
		        self._component2.mediator = self

		    def notify(self, sender: object, event: str) -> None:
		        if event == "A":
		            self._component2.do_c()
		        elif event == "D":
		            self._component1.do_b()
		            self._component2.do_c()


		class BaseComponent:
		    """
		    Базовый Компонент обеспечивает базовую функциональность хранения экземпляра
		    посредника внутри объектов компонентов.
		    """

		    def __init__(self, mediator: Mediator = None) -> None:
		        self._mediator = mediator

		    @property
		    def mediator(self) -> Mediator:
		        return self._mediator

		    @mediator.setter
		    def mediator(self, mediator: Mediator) -> None:
		        self._mediator = mediator


		"""
		Конкретные Компоненты реализуют различную функциональность. Они не зависят отё
		других компонентов. Они также не зависят от каких-либо конкретных классов
		посредников.
		"""


		class Component1(BaseComponent):
		    def do_a(self) -> None:
		        self.mediator.notify(self, "A")

		    def do_b(self) -> None:
		        self.mediator.notify(self, "B")


		class Component2(BaseComponent):
		    def do_c(self) -> None:
		        self.mediator.notify(self, "C")

		    def do_d(self) -> None:
		        self.mediator.notify(self, "D")


		if __name__ == "__main__":
		    c1 = Component1()
		    c2 = Component2()
		    
		    mediator = ConcreteMediator(c1, c2)

		    c1.do_a()
		    c2.do_d()

Снимок (Хранитель, Memento)

	Поведенческий паттерн.

	Позволяет сохранять и восстанавливать прошлые состояния объектов, не раскрывая подробностей их реализации.

	Позволяет делать снимки внутреннего состояния объектов, а затем восстанавливать их.

	Проблема

		Предположим, что вы пишете программу текстового редактора. Помимо обычного редактирования, ваш редактор позволяет менять форматирование текста, вставлять картинки и прочее.

		В какой-то момент вы решили сделать все эти действия отменяемыми. Для этого вам нужно сохранять текущее состояние редактора перед тем, как выполнить любое действие. Если потом пользователь решит отменить своё действие, вы достанете копию состояния из истории и восстановите старое состояние редактора.

		Чтобы сделать копию состояния объекта, достаточно скопировать значение его полей. Таким образом, если вы сделали класс редактора достаточно открытым, то любой другой класс сможет заглянуть внутрь, чтобы скопировать его состояние.

		Казалось бы, что ещё нужно? Ведь теперь любая операция сможет сделать резервную копию редактора перед своим действием. Но такой наивный подход обеспечит вам уйму проблем в будущем. Ведь если вы решите провести рефакторинг — убрать или добавить парочку полей в класс редактора, то придётся менять код всех классов, которые могли копировать состояние редактора.

		Но это ещё не все. Давайте теперь рассмотрим сами копии состояния редактора. Из чего состоит состояние редактора? Даже самый примитивный редактор должен иметь несколько полей для хранения текущего текста, позиции курсора и прокрутки экрана. Чтобы сделать копию состояния, вам нужно записать значения всех этих полей в некий «контейнер».

		Скорее всего, вам понадобится хранить массу таких контейнеров в качестве истории операций, поэтому удобнее всего сделать их объектами одного класса. Этот класс должен иметь много полей, но практически никаких методов. Чтобы другие объекты могли записывать и читать из него данные, вам придётся сделать его поля публичными. Но это приведёт к той же проблеме, что и с открытым классом редактора. Другие классы станут зависимыми от любых изменений в классе контейнера, который подвержен тем же изменениям, что и класс редактора.

	Решение

		Паттерн Снимок поручает создание копии состояния объекта самому объекту, который этим состоянием владеет. Вместо того, чтобы делать снимок «извне», наш редактор сам сделает копию своих полей, ведь ему доступны все поля, даже приватные.

		Паттерн предлагает держать копию состояния в специальном объекте-снимке с ограниченным интерфейсом, позволяющим, например, узнать дату изготовления или название снимка. Но, с другой стороны, снимок должен быть открыт для своего создателя, позволяя прочесть и восстановить его внутреннее состояние.

		Такая схема позволяет создателям производить снимки и отдавать их для хранения другим объектам, называемым опекунами. Опекунам будет доступен только ограниченный интерфейс снимка, поэтому они никак не смогут повлиять на «внутренности» самого снимка. В нужный момент опекун может попросить создателя восстановить своё состояние, передав ему соответствующий снимок.

	Применимость

		Когда вам нужно сохранять мгновенные снимки состояния объекта (или его части), чтобы впоследствии объект можно было восстановить в том же состоянии.

		Когда прямое получение состояния объекта раскрывает приватные детали его реализации, нарушая инкапсуляцию.

	Пример на python

		from __future__ import annotations
		from abc import ABC, abstractmethod
		from datetime import datetime
		from random import sample
		from string import ascii_letters, digits


		class Originator():
		    """
		    Создатель содержит некоторое важное состояние, которое может со временем
		    меняться. Он также объявляет метод сохранения состояния внутри снимка и
		    метод восстановления состояния из него.
		    """

		    _state = None

		    """Для удобства состояние создателя хранится внутри одной переменной."""

		    def __init__(self, state: str) -> None:
		        self._state = state
		        print(self._state)

		    def do_something(self) -> None:
		        """
		        Бизнес-логика Создателя может повлиять на его внутреннее состояние.
		        Поэтому клиент должен выполнить резервное копирование состояния с
		        помощью метода save перед запуском методов бизнес-логики.
		        """

		        self._state = self._generate_random_string(30)
		        print(self._state)

		    def _generate_random_string(self, length: int = 10) -> None:
		        return "".join(sample(ascii_letters, length))

		    def save(self) -> Memento:
		        """Сохраняет текущее состояние внутри снимка."""

		        return ConcreteMemento(self._state)

		    def restore(self, memento: Memento) -> None:
		        """Восстанавливает состояние Создателя из объекта снимка."""

		        self._state = memento.get_state()
		        print(self._state)


		class Memento(ABC):
		    """
		    Интерфейс Снимка предоставляет способ извлечения метаданных снимка, таких
		    как дата создания или название. Однако он не раскрывает состояние Создателя.
		    """

		    @abstractmethod
		    def get_name(self) -> str:
		        pass

		    @abstractmethod
		    def get_date(self) -> str:
		        pass


		class ConcreteMemento(Memento):
		    def __init__(self, state: str) -> None:
		        self._state = state
		        self._date = str(datetime.now())[:19]

		    def get_state(self) -> str:
		        """Создатель использует этот метод, когда восстанавливает своё состояние."""
		        return self._state

		    def get_name(self) -> str:
		        return self._date} / self._state[0:9]

		    def get_date(self) -> str:
		        return self._date


		class Caretaker():
		    """
		    Опекун не зависит от класса Конкретного Снимка. Таким образом, он не имеет
		    доступа к состоянию создателя, хранящемуся внутри снимка. Он работает со
		    всеми снимками через базовый интерфейс Снимка.
		    """

		    def __init__(self, originator: Originator) -> None:
		        self._mementos = []
		        self._originator = originator

		    def backup(self) -> None:
		        self._mementos.append(self._originator.save())

		    def undo(self) -> None:
		        if not len(self._mementos):
		            return

		        memento = self._mementos.pop()

		        print(memento.get_name())

		        try:
		            self._originator.restore(memento)
		        except Exception:
		            self.undo()

		    def show_history(self) -> None:
		        for memento in self._mementos:
		            print(memento.get_name())


		if __name__ == "__main__":
		    originator = Originator("Super-duper-super-puper-super.")
		    caretaker = Caretaker(originator)

		    caretaker.backup()
		    originator.do_something()

		    caretaker.backup()
		    originator.do_something()

		    caretaker.backup()
		    originator.do_something()

		    print()
		    caretaker.show_history()

		    caretaker.undo()
		    caretaker.undo()

Наблюдатель (Издатель-Подписчик, Слушатель, Observer)

	Поведенческий паттерн.

	Создаёт механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах.

	Позволяет объектам оповещать другие объекты об изменениях своего состояния.

	Проблема

		Представьте, что вы имеете два объекта: Покупатель и Магазин. В магазин вот-вот должны завезти новый товар, который интересен покупателю.

		Покупатель может каждый день ходить в магазин, чтобы проверить наличие товара. Но при этом он будет злиться, без толку тратя своё драгоценное время.

		С другой стороны, магазин может разослать спам каждому своему покупателю. Многих это расстроит, так как товар специфический, и не всем он нужен.

		Получается конфликт: либо покупатель тратит время на периодические проверки, либо магазин тратит ресурсы на бесполезные оповещения.

	Решение

		Давайте называть Издателями те объекты, которые содержат важное или интересное для других состояние. Остальные объекты, которые хотят отслеживать изменения этого состояния, назовём Подписчиками.

		Паттерн Наблюдатель предлагает хранить внутри объекта издателя список ссылок на объекты подписчиков, причём издатель не должен вести список подписки самостоятельно. Он предоставит методы, с помощью которых подписчики могли бы добавлять или убирать себя из списка.

		Теперь самое интересное. Когда в издателе будет происходить важное событие, он будет проходиться по списку подписчиков и оповещать их об этом, вызывая определённый метод объектов-подписчиков

		После того как вы оформили подписку на газету или журнал, вам больше не нужно ездить в супермаркет и проверять, не вышел ли очередной номер. Вместо этого издательство будет присылать новые номера по почте прямо к вам домой сразу после их выхода.

	Применимость

		Когда после изменения состояния одного объекта требуется что-то сделать в других, но вы не знаете наперёд, какие именно объекты должны отреагировать.

		Когда одни объекты должны наблюдать за другими, но только в определённых случаях.

	Пример на python

		from __future__ import annotations
		from abc import ABC, abstractmethod
		from random import randrange
		from typing import List


		class Subject(ABC):
		    """
		    Интферфейс издателя объявляет набор методов для управлениями подпискичами.
		    """

		    @abstractmethod
		    def attach(self, observer: Observer) -> None:
		        """Присоединяет наблюдателя к издателю."""
		        pass

		    @abstractmethod
		    def detach(self, observer: Observer) -> None:
		        """Отсоединяет наблюдателя от издателя."""
		        pass

		    @abstractmethod
		    def notify(self) -> None:
		        """Уведомляет всех наблюдателей о событии."""
		        pass


		class ConcreteSubject(Subject):
		    """
		    Издатель владеет некоторым важным состоянием и оповещает 
		    наблюдателей о его изменениях.
		    """

		    """
		    Для удобства в этой переменной хранится состояние Издателя, необходимое всем
		    подписчикам.
		    """
		    _state: int = None

		    """
		    Список подписчиков. В реальной жизни список подписчиков может храниться в
		    более подробном виде (классифицируется по типу события и т.д.)
		    """
		    _observers: List[Observer] = []

		    def attach(self, observer: Observer) -> None:
		        self._observers.append(observer)

		    def detach(self, observer: Observer) -> None:
		        self._observers.remove(observer)

		    """
		    Методы управления подпиской.
		    """

		    def notify(self) -> None:
		        """Запуск обновления в каждом подписчике."""

		        for observer in self._observers:
		            observer.update(self)

		    def some_business_logic(self) -> None:
		        """
		        Обычно логика подписки - только часть того, что делает Издатель.
		        Издатели часто содержат некоторую важную бизнес-логику, которая
		        запускает метод уведомления всякий раз, когда должно произойти что-то
		        важное (или после этого).
		        """

		        self._state = randrange(0, 10)
		        print(self._state)
		        self.notify()


		class Observer(ABC):
		    """
		    Интерфейс Наблюдателя объявляет метод уведомления, который издатели
		    используют для оповещения своих подписчиков.
		    """

		    @abstractmethod
		    def update(self, subject: Subject) -> None:
		        """Получить обновление от субъекта."""
		        pass


		"""
		Конкретные Наблюдатели реагируют на обновления, выпущенные Издателем, к которому
		они прикреплены.
		"""


		class ConcreteObserverA(Observer):
		    def update(self, subject: Subject) -> None:
		        if subject._state < 3:
		            print("ConcreteObserverA")


		class ConcreteObserverB(Observer):
		    def update(self, subject: Subject) -> None:
		        if subject._state == 0 or subject._state >= 2:
		            print("ConcreteObserverB")


		if __name__ == "__main__":
		    subject = ConcreteSubject()

		    observer_a = ConcreteObserverA()
		    subject.attach(observer_a)

		    observer_b = ConcreteObserverB()
		    subject.attach(observer_b)

		    subject.some_business_logic()
		    subject.some_business_logic()

		    subject.detach(observer_a)

		    subject.some_business_logic()

Состояние (State)

	Поведенческий паттерн.

	Позволяет объектам менять поведение в зависимости от своего состояния.

	Проблема

		Паттерн Состояние невозможно рассматривать в отрыве от концепции машины состояний, также известной как стейт-машина или конечный автомат.

		Основная идея в том, что программа может находиться в одном из нескольких состояний, которые всё время сменяют друг друга. Набор этих состояний, а также переходов между ними, предопределён и конечен. Находясь в разных состояниях, программа может по-разному реагировать на одни и те же события, которые происходят с ней.

		Такой подход можно применить и к отдельным объектам. Например, объект Документ может принимать три состояния: Черновик, Модерация или Опубликован. В каждом из этих состоянии метод опубликовать будет работать по-разному.

		Машину состояний чаще всего реализуют с помощью множества условных операторов,  if либо switch, которые проверяют текущее состояние объекта и выполняют соответствующее поведение.

		Основная проблема такой машины состояний проявится в том случае, если в Документ добавить ещё десяток состояний. Каждый метод будет состоять из увесистого условного оператора, перебирающего доступные состояния. Такой код крайне сложно поддерживать. Малейшее изменение логики переходов заставит вас перепроверять работу всех методов, которые содержат условные операторы машины состояний.

	Решение

		Паттерн Состояние предлагает создать отдельные классы для каждого состояния, в котором может пребывать объект, а затем вынести туда поведения, соответствующие этим состояниям.

		Вместо того, чтобы хранить код всех состояний, первоначальный объект, называемый контекстом, будет содержать ссылку на один из объектов-состояний и делегировать ему работу, зависящую от состояния.

		Благодаря тому, что объекты состояний будут иметь общий интерфейс, контекст сможет делегировать работу состоянию, не привязываясь к его классу. Поведение контекста можно будет изменить в любой момент, подключив к нему другой объект-состояние.

	Применимость

		Когда у вас есть объект, поведение которого кардинально меняется в зависимости от внутреннего состояния, причём типов состояний много, и их код часто меняется.

		Когда код класса содержит множество больших, похожих друг на друга, условных операторов, которые выбирают поведения в зависимости от текущих значений полей класса.

		Когда вы сознательно используете табличную машину состояний, построенную на условных операторах, но вынуждены мириться с дублированием кода для похожих состояний и переходов.

	Пример на python

		from __future__ import annotations
		from abc import ABC, abstractmethod


		class Context(ABC):
		    """
		    Контекст определяет интерфейс, представляющий интерес для клиентов. Он также
		    хранит ссылку на экземпляр подкласса Состояния, который отображает текущее
		    состояние Контекста.
		    """

		    # Ссылка на текущее состояние Контекста
		    _state = None

		    def __init__(self, state: State) -> None:
		        self.transition_to(state)

		    def transition_to(self, state: State):
		        """Контекст позволяет изменять объект Состояния во время выполнения."""

		        print(type(state).__name__)
		        self._state = state
		        self._state.context = self

		    """
		    Контекст делегирует часть своего поведения текущему объекту Состояния.
		    """

		    def request1(self):
		        self._state.handle1()

		    def request2(self):
		        self._state.handle2()


		class State(ABC):
		    """
		    Базовый класс Состояния объявляет методы, которые должны реализовать все
		    Конкретные Состояния, а также предоставляет обратную ссылку на объект
		    Контекст, связанный с Состоянием. Эта обратная ссылка может использоваться
		    Состояниями для передачи Контекста другому Состоянию.
		    """

		    @property
		    def context(self) -> Context:
		        return self._context

		    @context.setter
		    def context(self, context: Context) -> None:
		        self._context = context

		    @abstractmethod
		    def handle1(self) -> None:
		        pass

		    @abstractmethod
		    def handle2(self) -> None:
		        pass


		"""
		Конкретные Состояния реализуют различные модели поведения, связанные с
		состоянием Контекста.
		"""


		class ConcreteStateA(State):
		    def handle1(self) -> None:
		        self.context.transition_to(ConcreteStateB())

		    def handle2(self) -> None:
		        print("ConcreteStateA")


		class ConcreteStateB(State):
		    def handle1(self) -> None:
		        print("ConcreteStateB")

		    def handle2(self) -> None:
		        self.context.transition_to(ConcreteStateA())


		if __name__ == "__main__":
		    context = Context(ConcreteStateA())
		    context.request1()
		    context.request2()

Стратегия (Strategy)

	Поведенческий паттерн.

	Определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс, после чего алгоритмы можно взаимозаменять прямо во время исполнения программы.

	Проблема

		Вы решили написать приложение-навигатор для путешественников. Оно должно показывать красивую и удобную карту, позволяющую с лёгкостью ориентироваться в незнакомом городе.

		Одной из самых востребованных функций являлся поиск и прокладывание маршрутов. Пребывая в неизвестном ему городе, пользователь должен иметь возможность указать начальную точку и пункт назначения, а навигатор — проложит оптимальный путь.

		Первая версия вашего навигатора могла прокладывать маршрут лишь по дорогам, поэтому отлично подходила для путешествий на автомобиле. Но, очевидно, не все ездят в отпуск на машине. Поэтому следующим шагом вы добавили в навигатор прокладывание пеших маршрутов.

		С каждым новым алгоритмом код основного класса навигатора увеличивался вдвое. В таком большом классе стало довольно трудно ориентироваться.

		Любое изменение алгоритмов поиска, будь то исправление багов или добавление нового алгоритма, затрагивало основной класс. Это повышало риск сделать ошибку, случайно задев остальной работающий код.

	Решение

		Паттерн Стратегия предлагает определить семейство схожих алгоритмов, которые часто изменяются или расширяются, и вынести их в собственные классы, называемые стратегиями.

		Вместо того, чтобы изначальный класс сам выполнял тот или иной алгоритм, он будет играть роль контекста, ссылаясь на одну из стратегий и делегируя ей выполнение работы. Чтобы сменить алгоритм, вам будет достаточно подставить в контекст другой объект-стратегию.

		Важно, чтобы все стратегии имели общий интерфейс. Используя этот интерфейс, контекст будет независимым от конкретных классов стратегий. С другой стороны, вы сможете изменять и добавлять новые виды алгоритмов, не трогая код контекста.

	Применимость

		Когда вам нужно использовать разные вариации какого-то алгоритма внутри одного объекта.

		Когда у вас есть множество похожих классов, отличающихся только некоторым поведением.

		Когда вы не хотите обнажать детали реализации алгоритмов для других классов.

		Когда различные вариации алгоритмов реализованы в виде развесистого условного оператора. Каждая ветка такого оператора представляет собой вариацию алгоритма.

	Пример на python

		from __future__ import annotations
		from abc import ABC, abstractmethod
		from typing import List


		class Context():
		    """
		    Контекст определяет интерфейс, представляющий интерес для клиентов.
		    """

		    def __init__(self, strategy: Strategy) -> None:
		        """
		        Обычно Контекст принимает стратегию через конструктор, а также
		        предоставляет сеттер для её изменения во время выполнения.
		        """

		        self._strategy = strategy

		    @property
		    def strategy(self) -> Strategy:
		        """
		        Контекст хранит ссылку на один из объектов Стратегии. Контекст не знает
		        конкретного класса стратегии. Он должен работать со всеми стратегиями
		        через интерфейс Стратегии.
		        """

		        return self._strategy

		    @strategy.setter
		    def strategy(self, strategy: Strategy) -> None:
		        """
		        Обычно Контекст позволяет заменить объект Стратегии во время выполнения.
		        """

		        self._strategy = strategy

		    def do_some_business_logic(self) -> None:
		        """
		        Вместо того, чтобы самостоятельно реализовывать множественные версии
		        алгоритма, Контекст делегирует некоторую работу объекту Стратегии.
		        """

		        result = self._strategy.do_algorithm(["a", "b", "c", "d", "e"])


		class Strategy(ABC):
		    """
		    Интерфейс Стратегии объявляет операции, общие для всех поддерживаемых версий
		    некоторого алгоритма.

		    Контекст использует этот интерфейс для вызова алгоритма, определённого
		    Конкретными Стратегиями.
		    """

		    @abstractmethod
		    def do_algorithm(self, data: List):
		        pass


		"""Конкретные Стратегии реализуют алгоритм, следуя базовому интерфейсу Стратегии."""


		class ConcreteStrategyA(Strategy):
		    def do_algorithm(self, data: List) -> List:
		        return sorted(data)


		class ConcreteStrategyB(Strategy):
		    def do_algorithm(self, data: List) -> List:
		        return reversed(sorted(data))


		if __name__ == "__main__":
		    # Клиентский код выбирает конкретную стратегию и передаёт её в контекст.
		    # Клиент должен знать о различиях между стратегиями, чтобы сделать
		    # правильный выбор.

		    context = Context(ConcreteStrategyA())
		    context.do_some_business_logic()

		    # изменение стратегии на лету через сеттер
		    context.strategy = ConcreteStrategyB()
		    context.do_some_business_logic()

Шаблонный метод (Template Method)

	Поведенческий паттерн.

	Определяет скелет алгоритма в суперклассе и заставляет подклассы реализовать конкретные шаги этого алгоритма.

	Паттерн позволяет подклассам переопределять шаги алгоритма, не меняя его общей структуры.

	Проблема

		Вы пишете программу для дата-майнинга в офисных документах. Пользователи будут загружать в неё документы в разных форматах (PDF, DOC, CSV), а программа должна извлекать из них полезную информацию.

		В первой версии вы ограничились только обработкой DOC-файлов. В следующей версии добавили поддержку CSV. А через месяц прикрутили работу с PDF-документами.

		В какой-то момент вы заметили, что код всех трёх классов обработки документов хоть и отличается в части работы с файлами, но содержат довольно много общего в части самого извлечения данных. Было бы здорово избавится от повторной реализации алгоритма извлечения данных в каждом из классов.

	Решение

		Паттерн Шаблонный метод предлагает разбить алгоритм на последовательность шагов, описать эти шаги в отдельных методах и вызывать их в одном шаблонном методе друг за другом.

		Это позволит подклассам переопределять некоторые шаги алгоритма, оставляя без изменений его структуру и остальные шаги, которые для этого подкласса не так важны.

		Теперь мы можем определить общее для всех классов поведение и вынести его в суперкласс.

	Применимость

		Когда подклассы должны расширять базовый алгоритм, не меняя его структуры.

		Когда у вас есть несколько классов, делающих одно и то же с незначительными отличиями. Если вы редактируете один класс, то приходится вносить такие же правки и в остальные классы.

	Пример на python

		from abc import ABC, abstractmethod


		class AbstractClass(ABC):
		    """
		    Абстрактный Класс определяет шаблонный метод, содержащий скелет некоторого
		    алгоритма, состоящего из вызовов (обычно) абстрактных примитивных операций.

		    Конкретные подклассы должны реализовать эти операции, но оставить сам
		    шаблонный метод без изменений.
		    """

		    def template_method(self) -> None:
		        """
		        Шаблонный метод определяет скелет алгоритма.
		        """

		        self.base_operation1()
		        self.required_operations1()
		        self.base_operation2()
		        self.hook1()
		        self.required_operations2()
		        self.base_operation3()
		        self.hook2()

		    # Эти операции уже имеют реализации.

		    def base_operation1(self) -> None:
		        print("base_operation1")

		    def base_operation2(self) -> None:
		        print("base_operation2")

		    def base_operation3(self) -> None:
		        print("base_operation3")

		    # А эти операции должны быть реализованы в подклассах.

		    @abstractmethod
		    def required_operations1(self) -> None:
		        pass

		    @abstractmethod
		    def required_operations2(self) -> None:
		        pass

		    # Это «хуки». Подклассы могут переопределять их, но это не обязательно,
		    # поскольку у хуков уже есть стандартная (но пустая) реализация. Хуки
		    # предоставляют дополнительные точки расширения в некоторых критических
		    # местах алгоритма.

		    def hook1(self) -> None:
		        pass

		    def hook2(self) -> None:
		        pass


		class ConcreteClass1(AbstractClass):
		    """
		    Конкретные классы должны реализовать все абстрактные операции базового
		    класса. Они также могут переопределить некоторые операции с реализацией по
		    умолчанию.
		    """

		    def required_operations1(self) -> None:
		        print("required_operations1")

		    def required_operations2(self) -> None:
		        print("required_operations2")


		class ConcreteClass2(AbstractClass):
		    def required_operations1(self) -> None:
		        print("required_operations1")

		    def required_operations2(self) -> None:
		        print("required_operations2")

		    def hook1(self) -> None:
		        print("hook1")


		def client_code(abstract_class: AbstractClass) -> None:
		    """
		    Клиентский код вызывает шаблонный метод для выполнения алгоритма. Клиентский
		    код не должен знать конкретный класс объекта, с которым работает, при
		    условии, что он работает с объектами через интерфейс их базового класса.
		    """

		    abstract_class.template_method()


		if __name__ == "__main__":
		    client_code(ConcreteClass1())
		    client_code(ConcreteClass2())

Посетитель (Visitor)

	Поведенческий паттерн.

	Позволяет добавлять в программу новые операции, не изменяя классы объектов, над которыми эти операции могут выполняться.

	Проблема

		Ваша команда разрабатывает приложение, работающее с геоданными в виде графа. Узлами графа являются городские локации: памятники, театры, рестораны, важные предприятия и прочее. Каждый узел имеет ссылки на другие, ближайшие к нему узлы. Каждому типу узлов соответствует свой класс, а каждый узел представлен отдельным объектом.

		Ваша задача - сделать экспорт этого графа в XML. Дело было бы плёвым, если бы вы могли редактировать классы узлов. Достаточно было бы добавить метод экспорта в каждый тип узла, а затем, перебирая узлы графа, вызывать этот метод для каждого узла. Благодаря полиморфизму, решение получилось бы изящным, так как вам не пришлось бы привязываться к конкретным классам узлов.

		Но, к сожалению, классы узлов вам изменить не удалось. Системный архитектор сослался на то, что код классов узлов сейчас очень стабилен, и от него многое зависит, поэтому он не хочет рисковать и позволять кому-либо его трогать.

		К тому же он сомневался в том, что экспорт в XML вообще уместен в рамках этих классов. Их основная задача была связана с геоданными, а экспорт выглядит в рамках этих классов чужеродно.

		Была и ещё одна причина запрета. Если на следующей неделе вам бы понадобился экспорт в какой-то другой формат данных, то эти классы снова пришлось бы менять.

	Решение

		Паттерн Посетитель предлагает разместить новое поведение в отдельном классе, вместо того чтобы множить его сразу в нескольких классах.

		Объекты, с которыми должно было быть связано поведение, не будут выполнять его самостоятельно. 

		Вместо этого вы будете передавать эти объекты в методы посетителя, а уже он будет делать всю работу.

		Код поведения, скорее всего, должен отличаться для объектов разных классов, поэтому и методов у посетителя должно быть несколько. 

		Названия и принцип действия этих методов будет схож, но основное отличие будет в типе принимаемого в параметрах объекта.

		Объекты, которые мы передаём в параметрах посетителю будут вызывать нужный метод посетителя.

	Применимость

		Когда вам нужно выполнить какую-то операцию над всеми элементами сложной структуры объектов, например, деревом.

		Когда над объектами сложной структуры объектов надо выполнять некоторые не связанные между собой операции, но вы не хотите «засорять» классы такими операциями.

		Когда новое поведение имеет смысл только для некоторых классов из существующей иерархии.

	Пример на python

		from __future__ import annotations
		from abc import ABC, abstractmethod
		from typing import List


		class Component(ABC):
		    """
		    Интерфейс Компонента объявляет метод accept, который в качестве аргумента
		    может получать любой объект, реализующий интерфейс посетителя.
		    """

		    @abstractmethod
		    def accept(self, visitor: Visitor) -> None:
		        pass


		class ConcreteComponentA(Component):
		    """
		    Каждый Конкретный Компонент должен реализовать метод accept таким образом,
		    чтобы он вызывал метод посетителя, соответствующий классу компонента.
		    """

		    def accept(self, visitor: Visitor) -> None:
		        """
		        Обратите внимание, мы вызываем visitConcreteComponentA, что
		        соответствует названию текущего класса. Таким образом мы позволяем
		        посетителю узнать, с каким классом компонента он работает.
		        """

		        visitor.visit_concrete_component_a(self)

		    def exclusive_method_of_concrete_component_a(self) -> str:
		        """
		        Конкретные Компоненты могут иметь особые методы, не объявленные в их
		        базовом классе или интерфейсе. Посетитель всё же может использовать эти
		        методы, поскольку он знает о конкретном классе компонента.
		        """

		        return "A"


		class ConcreteComponentB(Component):
		    def accept(self, visitor: Visitor):
		        visitor.visit_concrete_component_b(self)

		    def special_method_of_concrete_component_b(self) -> str:
		        return "B"


		class Visitor(ABC):
		    """
		    Интерфейс Посетителя объявляет набор методов посещения, соответствующих
		    классам компонентов.
		    """

		    @abstractmethod
		    def visit_concrete_component_a(self, element: ConcreteComponentA) -> None:
		        pass

		    @abstractmethod
		    def visit_concrete_component_b(self, element: ConcreteComponentB) -> None:
		        pass


		"""
		Конкретные Посетители реализуют несколько версий одного и того же алгоритма,
		которые могут работать со всеми классами конкретных компонентов.

		Максимальную выгоду от паттерна Посетитель вы почувствуете, используя его со
		сложной структурой объектов, такой как дерево Компоновщика.
		"""


		class ConcreteVisitor1(Visitor):
		    def visit_concrete_component_a(self, element) -> None:
		        element.exclusive_method_of_concrete_component_a()

		    def visit_concrete_component_b(self, element) -> None:
		        element.special_method_of_concrete_component_b()


		class ConcreteVisitor2(Visitor):
		    def visit_concrete_component_a(self, element) -> None:
		        element.exclusive_method_of_concrete_component_a()

		    def visit_concrete_component_b(self, element) -> None:
		        element.special_method_of_concrete_component_b()


		def client_code(components: List[Component], visitor: Visitor) -> None:
		    """
		    Клиентский код может выполнять операции посетителя над любым набором
		    элементов, не выясняя их конкретных классов. Операция принятия направляет
		    вызов к соответствующей операции в объекте посетителя.
		    """

		    for component in components:
		        component.accept(visitor)


		if __name__ == "__main__":
		    components = [ConcreteComponentA(), ConcreteComponentB()]

		    visitor1 = ConcreteVisitor1()
		    client_code(components, visitor1)

		    visitor2 = ConcreteVisitor2()
		    client_code(components, visitor2)