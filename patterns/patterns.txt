Оглавление

	Что это

	Из чего состоит паттерн

	Зачем знать паттерны

	Классификация паттернов

	Порождающие

	Фабричный метод

	Абстрактная фабрика

	Одиночка

Что это

	Паттерн проектирования - это часто встречающееся решение определённой проблемы при проектировании архитектуры программ.

	Паттерн представляет собой не какой-то конкретный код, а общую концепцию решения той или иной проблемы, которую нужно будет ещё подстроить под нужды вашей программы.

Из чего состоит паттерн

	Паттерн состоит из:

		проблемы, которую он решает

		способ решения проблемы

		структуры классов, составляющих решение

Зачем знать паттерны

	Проверенные решения.

	Делается меньше просчётов при проектировании, так как все скрытые проблемы в них уже давно найдены.

	Общий программистский словарь.

Классификация паттернов

	Порождающие

	Структурные

	Поведенческие

Порождающие

	Отвечают за создание объектов.

	Список: фабричный метод, абстрактная фабрика, строитель, прототип, одиночка.

Фабричный метод

	Порождающий паттерн.

	Определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.

	Представьте, что вы создаёте программу управления грузовыми перевозками. Сперва вы рассчитываете перевозить товары только на автомобилях. Поэтому весь ваш код работает с объектами класса Грузовик. В какой-то момент ваша программа становится настолько известной, что морские перевозчики выстраиваются в очередь и просят добавить поддержку морской логистики в программу.Чтобы добавить в программу классы морских  Судов, понадобится перелопатить всю программу. Более того, если вы потом решите добавить в программу ещё один вид транспорта, то всю эту работу придётся повторить.

	Паттерн Фабричный метод предлагает создавать объекты не напрямую, используя оператор new, а через вызов особого фабричного метода.

	Объекты всё равно будут создаваться при помощи new, но делать это будет фабричный метод.

	Фабричный метод задаёт метод, который следует использовать вместо вызова оператора new для создания объектов. Подклассы могут переопределить этот метод, чтобы изменять тип создаваемых объектов.

	Зачастую фабричный метод объявляют абстрактным, чтобы заставить все подклассы реализовать его по-своему. 

	фабричный метод хорошо применять, когда:

		заранее неизвестны типы и зависимости объектов

		нужно дать возможность пользователям расширять части вашего приложения, библиотеки, фреймворка

			Например, вы используете готовый UI-фреймворк для своего приложения. Но вот беда — требуется иметь круглые кнопки, вместо стандартных прямоугольных. Вы создаёте класс RoundButton. Но как сказать главному классу фреймворка  UIFramework, чтобы он теперь создавал круглые кнопки, вместо стандартных? Для этого вы создаёте подкласс UIWithRoundButtons из базового класса фреймворка, переопределяете в нём метод создания кнопки (а-ля createButton) и вписываете туда создание своего класса кнопок. Затем используете UIWithRoundButtons вместо стандартного UIFramework.

		когда нужно экономить системные ресурсы, повторно используя уже созданные объекты, вместо порождения новых

	Фабричный метод можно определить по создающим методам, которые возвращают объекты.

	Пример на python:

		from __future__ import annotations
		from abc import ABC, abstractmethod


		class Creator:
		    """
		    Класс Создатель объявляет фабричный метод, который должен возвращать объект
		    класса. Подклассы Создателя обычно предоставляют реализацию этого метода.
		    """

		    @abstractmethod
		    def factory_method(self):
		        pass

		    def some_operation(self):
		        """
		        Также заметьте, что, несмотря на название, основная обязанность
		        Создателя не заключается только в создании. Обычно он содержит
		        некоторую базовую бизнес-логику.
		        """
		        pass


		"""
		Конкретные Создатели переопределяют фабричный метод для того, чтобы изменить тип, создаваемого объекта.
		"""


		class ConcreteCreator1(Creator):
		    def factory_method(self):
		        return ConcreteProduct1()


		class ConcreteCreator2(Creator):
		    def factory_method(self):
		        return ConcreteProduct2()


		class Product:
		    """
		    Интерфейс Продукта объявляет операции, которые должны выполнять все
		    конкретные продукты.
		    """

		    @abstractmethod
		    def some_operation(self):
		        pass


		"""
		Конкретные Продукты предоставляют различные реализации интерфейса Продукта.
		"""


		class ConcreteProduct1(Product):
		    def some_operation(self):
		        pass


		class ConcreteProduct2(Product):
		    def some_operation(self):
		        pass


		def client_code(creator: Creator):
		    """
		    Клиентский код работает с экземпляром конкретного создателя, хотя и через
		    его базовый интерфейс. Пока клиент продолжает работать с создателем через
		    базовый интерфейс, вы можете передать ему любой подкласс создателя.
		    """
		    
		    pass


		if __name__ == "__main__":
		    client_code(ConcreteCreator1())
		    client_code(ConcreteCreator2())

Абстрактная фабрика

	Порождающий паттерн.

	Позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам.

	Используется, когда программа должна работать с разными видами связанных друг с другом продуктов.

	Например представьте, что вы пишете симулятор мебельного магазина. Ваш код содержит:

		Семейство зависимых продуктов. Скажем, Кресло + Диван + Столик.

		Несколько вариаций этого семейства. Например, продукты Кресло, Диван и Столик представлены в трёх разных стилях: Ар-деко, Викторианском и Модерне.

	Вам нужен такой способ создавать объекты продуктов, чтобы они сочетались с другими продуктами того же семейства. То есть чтобы можно было легко создать столик, диван и кресло например в стиле модерн.

	При этом пользователь может смотреть коллекции мебели в разных стилях.

	Шаги реализации:

		Определите продукты и их вариации.

		Выделите общие интерфейсы для отдельных продуктов.

		Определите интерфейс абстрактной фабрики. Он должен иметь методы для создания каждого продукта.

		Создайте классы конкретных фабрик, реализовав интерфейс абстрактной фабрики. Этих классов должно быть столько же, сколько и вариаций семейств продуктов и внутри они должны создавать продукты определенной вариации.

			class LinuxFactory:
				def create_button(self):
					return button

				def create_icon(self):
					return icon

		Измените код инициализации программы так, чтобы она создавала определённую фабрику и передавала её в клиентский код.

			if os == 'linux':
				factory = LinuxFactory()
			elif os == 'Win':
				factory = WinFactory()

		Замените в клиентском коде участки создания продуктов через конструктор вызовами соответствующих методов фабрики.


	В самом начале программа определяет с какой фабрикой будет работать (например из переменной окружения или файла конфигурации) затем создает объект этой фабрики и отдаёт его клиентскому коду.

	В дальнейшем клиент будет работать только с этой фабрикой, чтобы исключить несовместимость возвращаемых продуктов.

	Пример на python:

		class AbstractFactory(ABC):
		    """
		    Интерфейс Абстрактной Фабрики объявляет набор методов, которые возвращают
		    различные абстрактные продукты. Эти продукты называются семейством и связаны
		    темой или концепцией высокого уровня. Продукты одного семейства обычно могут
		    взаимодействовать между собой. Семейство продуктов может иметь несколько
		    вариаций, но продукты одной вариации несовместимы с продуктами другой.
		    """
		    @abstractmethod
		    def create_product_a(self) -> AbstractProductA:
		        pass

		    @abstractmethod
		    def create_product_b(self) -> AbstractProductB:
		        pass


		class ConcreteFactory1(AbstractFactory):
		    """
		    Конкретная Фабрика производит семейство продуктов одной вариации. Фабрика
		    гарантирует совместимость полученных продуктов. Обратите внимание, что
		    сигнатуры методов Конкретной Фабрики возвращают абстрактный продукт, в то
		    время как внутри метода создается экземпляр конкретного продукта.
		    """

		    def create_product_a(self) -> ConcreteProductA1:
		        return ConcreteProductA1()

		    def create_product_b(self) -> ConcreteProductB1:
		        return ConcreteProductB1()


		class ConcreteFactory2(AbstractFactory):
		    """
		    Каждая Конкретная Фабрика имеет соответствующую вариацию продукта.
		    """

		    def create_product_a(self) -> ConcreteProductA2:
		        return ConcreteProductA2()

		    def create_product_b(self) -> ConcreteProductB2:
		        return ConcreteProductB2()


		class AbstractProductA(ABC):
		    """
		    Каждый отдельный продукт семейства продуктов должен иметь базовый интерфейс.
		    Все вариации продукта должны реализовывать этот интерфейс.
		    """

		    @abstractmethod
		    def useful_function_a(self) -> str:
		        pass


		"""
		Конкретные продукты создаются соответствующими Конкретными Фабриками.
		"""


		class ConcreteProductA1(AbstractProductA):
		    def useful_function_a(self) -> str:
		        return "The result of the product A1."


		class ConcreteProductA2(AbstractProductA):
		    def useful_function_a(self) -> str:
		        return "The result of the product A2."


		class AbstractProductB(ABC):
		    """
		    Базовый интерфейс другого продукта. Все продукты могут взаимодействовать
		    друг с другом, но правильное взаимодействие возможно только между продуктами
		    одной и той же конкретной вариации.
		    """
		    @abstractmethod
		    def useful_function_b(self) -> None:
		        """
		        Продукт B способен работать самостоятельно...
		        """
		        pass

		    @abstractmethod
		    def another_useful_function_b(self, collaborator: AbstractProductA) -> None:
		        """
		        ...а также взаимодействовать с Продуктами Б той же вариации.

		        Абстрактная Фабрика гарантирует, что все продукты, которые она создает,
		        имеют одинаковую вариацию и, следовательно, совместимы.
		        """
		        pass


		"""
		Конкретные Продукты создаются соответствующими Конкретными Фабриками.
		"""


		class ConcreteProductB1(AbstractProductB):
		    def useful_function_b(self) -> str:
		        return "The result of the product B1."

		    """
		    Продукт B1 может корректно работать только с Продуктом A1. Тем не менее, он
		    принимает любой экземпляр Абстрактного Продукта А в качестве аргумента.
		    """

		    def another_useful_function_b(self, collaborator: AbstractProductA) -> str:
		        result = collaborator.useful_function_a()
		        return f"The result of the B1 collaborating with the ({result})"


		class ConcreteProductB2(AbstractProductB):
		    def useful_function_b(self) -> str:
		        return "The result of the product B2."

		    def another_useful_function_b(self, collaborator: AbstractProductA):
		        """
		        Продукт B2 может корректно работать только с Продуктом A2. Тем не менее,
		        он принимает любой экземпляр Абстрактного Продукта А в качестве
		        аргумента.
		        """
		        result = collaborator.useful_function_a()
		        return f"The result of the B2 collaborating with the ({result})"


		def client_code(factory: AbstractFactory) -> None:
		    """
		    Клиентский код работает с фабриками и продуктами только через абстрактные
		    типы: Абстрактная Фабрика и Абстрактный Продукт. Это позволяет передавать
		    любой подкласс фабрики или продукта клиентскому коду, не нарушая его.
		    """
		    product_a = factory.create_product_a()
		    product_b = factory.create_product_b()

		    print(f"{product_b.useful_function_b()}")
		    print(f"{product_b.another_useful_function_b(product_a)}", end="")


		if __name__ == "__main__":
		    """
		    Клиентский код может работать с любым конкретным классом фабрики.
		    """
		    print("Client: Testing client code with the first factory type:")
		    client_code(ConcreteFactory1())

		    print("\n")

		    print("Client: Testing the same client code with the second factory type:")
		    client_code(ConcreteFactory2())


Одиночка

	Порождающий паттерн.

	Гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.

	Чаще всего это полезно для доступа к какому-то общему ресурсу, например, базе данных, чтобы не открывать каждый раз новое соединение.

	Использовать, когда должен быть единственный экземпляр какого-то класса, доступный всем.

	Одиночка скрывает от клиентов все способы создания нового объекта, кроме специального статического метода. Этот метод либо создаёт объект, либо отдаёт существующий объект, если он уже был создан.

	Пример на python:

		class App:
		    __instance = None

		    @staticmethod
		    def get_instance():
		        if App.__instance is None:
		            App.__instance = App()
		        return App.__instance


		print(App.get_instance(), App.get_instance())

	В отличие от глобальных переменных, Одиночка гарантирует, что никакой другой код не заменит созданный экземпляр класса.



