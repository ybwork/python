Оглавление

	Что это

	Последовательное очищение

	Содержательные имена

	Функции

	Комментарии

	Форматирование

	Обработка ошибок

	Классы

	Системы

	Запахи и эвристические правила

	Общие стандарты кодирования

Что это

	Руководство по написанию кода.

	Данное руководство представляет из себя выжимку из книги "Чистый код" Роберта Мартина.

Последовательное очищение

	Чтобы написать чистый код, мы сначала пишем грязный код, а затем очищаем его.

    Иногда лучше перестроить систему, чем добавлять изменения.

Содержательные имена

	Имена переменных должны отвечать на все главные вопросы. Например, что измеряется и в каких единицах - days_since_creation

	Не использовать слова со скрытыми значениями. Например $hp, aix и т.д.

	Имена классов должны представлять из себя существительные и их комбинации, если это необходимо. Например AddressParser, Product и т.д.

	Имена методов должны быть глаголами или глагольными сочетаниями. Например: getName, save и т.д.

	Выберите одно слово для каждой концепции. Например если в разных классах есть методы fetch, get, retrieve, которые обозначают одно и то же - получать. Соответственно это несёт путаницу, поэтому выбираем одно название метода для получения чего-либо и используем его везде.

	При этом не следует делать это везде и бездумно. Например мы создаём новый класс, где есть фунция, которая добавляет один элемент в коллекцию. Если подумать, то данная функция не создаёт, а добавляет, поэтому её можно назвать append.

Функции

	Функции должны быть компактными.

	"Однако каждая функция Кента занимала всего 3-4 строки". Этого можно достигнуть например с помощью вызова дополнительной функции в конструкциях if, while.

	Функция должна выполнять только одну операцию и ничего другого она делать не должна.

	Но как быть если в функции идёт проверка входного параметра, потом вызвается другая функция и происходит третье действие? Ответ такой: если функция выполняет только те действия, которые находятся на одном уровне абстракции под объявленной фунцией, то всё верно.

	Под "на одном уровне абстракции" я понимаю, что методы из других классов должны быть обернуты в метод в той части кода, где их будет вызывать другой метод (если не понятно, то вчитаться в пример ниже).

	    Не на одном уровне абстракции:

            void sendRequest(Request request)
            {
                if (server->error() != Server::errorOk)
                {
                        // handle
                }

                if (request.userName.empty())
                {
                        // handle
                }

                // ещё 100 if-ов

                client.send(request, server);
            }

        В данном случае Server::errorOk и request.userName.empty() находятся на другом уровне абстракции нежели функция sendRequest(Request request).

        На одном уровне абстракции:

            void sendRequest(Request request)
            {
                if (!isServerReady())
                {
                        // handle
                }

                if (!isRequestValid(request))
                {
                        // handle
                }

                // больше нет if'ов

                client.send(request, server);
            }

            Всё что мы сделали это перенесли проверку методов Server::errorOk и request.userName.empty() в отдельные функции и таким образом мы вернули единую абстракцию.

    Код должен читаться, как разссказ - сверху вниз. За каждой функции должна следовать функция следующей абстракции.

    Код в структурах if, while и т.д. желательно вынести в отдельную функцию и желательно чтобы в условии эта функция была одна.

    Если в функции появляются вложенные структуры if, while и т.д., то лучше вынести их в другие функции.

    К сожаление без команд if и switch не всегда удаётся обойтись, поэтому здесь нам может помочь полиморфизм.

    Длинное, содержательное имя лучше короткого.

    Не бойтесь тратить время на выбор имени. Опробуйте несколько разных имён и посмотрите, как код читается с каждым из них.

    В идеальном случае кол-во аргументов функции равно нулю. Функция с тремя аргументами по возможности следует избегать. 

    Аргументы плохи тем, что читающему код нужно постоянно помнить о подробностях. Под подробностями понимается аргумент функции.

    Так же аргументы создают проблемы при написании тестов, потому что нужно много вариантов чтобы оттестировать функцию.

    Передача логического значения в функцию - воистину ужасная привычка. То есть, когда при ложном агрументе выполняется одно, а при истинном, другое.

    Функция что то должна делать или отвечать на какой то вопрос, но не одновременно! Например: create или is_exists.

    Либо функция возвращает информацию об объекте, либо изменяет его, но не одновременно!

    Использовать исключения вместо возвращения кодов ошибок.

Комментарии

	"Не комментируйте плохой код - перепишите его".

	Комментарии - зло, потому что код изменяется и эволюционирует, при этом не всегда программист вспоминает о поддержке комментариев. В итоге они становятся устаревшими и дизенформируют других читателей кода.

	Чтобы объяснить намерение кодом, а не комментарием можно написать функцию и вызвать ее внутри другой функции.

	Но всё же есть полезные комментарии:

        которые обычно помещают для описания работы модуля в общем

        которые описывают функцию в общем и рассказывают о её аргументах

        комментирование кусков из инородных модулей, изменить код которых нет возможности

        предупреждение о последствиях (запускайте данный метод только для тестирования)

        заметки на будущее или TODO комментарии (на данный момент не используется, но ситуация измениться при переходе к отладке)

        усиление значения (вызов данной функции очень важен, потому что)

        если идёт разработки api

Форматирование

	Не усложняйте код, допуская его оформление в разных стилях.

	Работая в группе нужно согласовать единый стиль форматирования и его должен придерживаться каждый программист.

	Маленькие файлы обычно более понятны, чем большие.

    Имя файла должно быть простым, но содержательным.

	Каждая группа строк должна представлять собой законченную мысль и отделяться от другой группы пустой строкой.

	Концепции связанные друг с другом, должны находиться рядом друг с другом. Например внутри класса контроллера есть метод обрабатывающий роут и рядом с ним объявленны функции, которые он использует.

	Переменные следует объявлять, как можно ближе к месту использования.

    Функция, которая вызывает другую, должна находиться выше вызываемой.

Обработка ошибок
	
	Используйте исключени вместо кодов ошибок, потому что если мы возвращаем код ошибки, то вызывающая сторона должна проверить ответ, а это ведёт к условным оператрам и загромождению кода.

	Создавайте содержательные сообщения об ошибках и передавайте их со своими исключениями.

Классы

	Классы должны быть компактными.

	Каждый класс имеет одну ответственность.

	Имя класса должно описывать его ответственности. Чтобы понять использует класс одну ответственность или нет нужно описать то, что он делает. Если описание больше 25 слов и в нём присутствуют слова: "и", "или", "если", "но", то указывает на то, что класс имеет много ответственностей.

	Классы должны быть открыты для расширений, но закрыты для модификации. В идеале новая функциональность должна реализовываться расширением системы, а не внесением изменений в уже существующий код.

Системы

	Принятие решений лучше всего откладывать до последнего, потому что это позволяет собрать всю информацию о проекте и принять правильное, информативное решение.

    Чистым должен быть не только код, но и архитектура системы.

    Используйте самое простое решение из всех возможных.

Запахи и эвристические правила

    Список того, что "дурно пахнет" при чтении кода:

        в комментариях не уместно хранить информацию о истории изменений, авторах и т.п.

        не пишите комментарии, которые с течением времени устареют

        избыточным считается комментарий, который описывает то, что и так очевидно (например эта переменная возрастает $i++;)

        комментарии должны говорить то, что не может сказать сам код

        увидев закомментированный код, удалите его

        все модульные тесты должны выполняться одной командой и должны быть быстрыми

        желательно делать функции без аргументов, но в пределе 3-х аргументов это терпимо

        выходные аргументы функции противоестественны

        избегать флаги в аргументах, потому что это как минимум говорит о том, что функция делает не одно действие

        не бойтесь удалять функции, которые не используются

        свести к минимуму использование разных языков в одном файле

        на этапе разработки не отключать вывод ошибок

        не повторяйтесь

        хорошо определённый интерфейс имеет небольшое кол-во функций

        скрывайте вспомогательные функции, константы и переменные класса

        переменные и функции должны объявляться вблизи от места их использования

        функция не должна вызываться с аргументами типа true/false

        лучше использовать нестатические функции, но если вы уверены, что не понадобиться полиморфное поведение, то можно и статические

        используйте пояснительные переменные

        имена функций должны описывать выполняемые действия (если приходится читать функцию, чтобы понять, что она делает, её лучше переназвать)

        Правило одной команды if/switch

Общие стандарты кодирования

    Числа стоит скрыть в константах с содержательными названиями.

    Передавать в функцию аргументы в виде переменных, а не волшебные числа и строки - show(1, 'John');

    Архитектура важнее кода.

    Инкапсулируйте условные инструкции.

    Избегать отрицательных условий в if, потому что они сложнее для понимания.

    Функция должна выполнять одну операцию. Пример неправильной функции:
            
	    public void pay()
	    {
	        for (Employe $e as $employes) {
	            if (e.isPayDay()) {
	                Money pay = e.calculatePay();
	                e.deliverPay(pay);
	            }
	        }
	    }

	    Эта функция выполняет сразу три операции: перебирает всех работников, проверяет начисленны ли работнику какие-то выплаты и наконец производит оплату. Поэтому её лучше разбить на 3 отдельных.

    Модуль не должен обладать знаниями о других компонентах с которыми он работает.

    Используйте содержательные имена.

    Используйте в именах переменных стандартные имена, наприме для шаблона декоратор - decorator, для работы со строкой - toString()