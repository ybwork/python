Оглавление

	Тестирование

	Хранение файлов

	Фильтрация

	Юнит тесты

	Юнит тесты (нюансы)

	Юнит тесты (команды)

	Множественное создание

	Админка

	Запросы

	Модели

	Нюансы

Тестирование

	Есть класс Client для тестов клиентской части приложения.

	Есть класс RequestFactory для использования в тестах объекта request.

	Из объекта Client можно получить текущего пользователя через result.wsgi_request.user

Хранение файл

	Есть класс FileSystemStorage, который реализует всю работу по локальному хранению файлов.

Фильтрация

	При множественной фильтрации каждый queryset уникален и никак не связан с предыдущим.

		q_1 = Question.objects.filter(year=2006) 
		q_2 = q_1.filter(is_active=True)
		q_3 = q_2.filter(tag='music')

Юнит тесты
	
	Тестируют работу методов, функций и классов.

	Класс для теста должен наследоваться от from django.test import TestCase

	Метод setUp это встроенный метод тестирования, который позволяет создавать тестовые данные в бд в момент. Нужно потому что при прохождении тестов создается пустая бд.

Юнит тесты нюансы

	Помнить, что при выполнении тестов создается ПУСТАЯ база данных.

	Если класс в котором написаны тесты наследуется от from django.test import TestCase, то при выполнении будет создана новая, пустая и временная база данных.

	Если класс в котором написаны тесты наследуется напрямую от unittest.TestCase (класс чистого python для тестирования), то при выполнении будет использована боевая база данных и это может иметь последствия.

	Помнить, что метод create_user возвращает хэшированный пароль и через него нельзя будет потом залогиниться. Поэтому можно сделать приватное св-во в методе setUp.

Юнит тесты команды

	self.client.login()

	self.assertEqual()

	self.assertQuerysetEqual()

	response = self.client.post(reverse('admin:user_invoice_add'), {'num': 'x23md'}) - делает пост запрос на нужный урл с нужными параметрами

	response.wsgi_request.user - выводит пользователя, который сделал запрос

	./manage.py test

	./manage.py test app_name/

Множественное создание

	Invoice.objects.bulk_create(
		Invoice(num='bbb'),
		Invoice(num='aaa')
	)

Админка

	response.context['cl'].queryset - доступ к списку сущности

Запросы

	Permission.objects.filter(codename__in=['add_invoice', 'view_invoice']) - фильтр по нескольким условиям

	Invoice.objects.order_by('?') - сортировка по asc

	TemplateEntry.objects.filter(template=obj.template.pk).query - вывод чистого sql запроса

	User.objects.create(name='Ilya') - создает и возвращает созданную сущность

    Book.objects.filter(name='name').select_related('author') - позволяет взять сразу все связанные объекты (если мы в дальнейшем будем в цикле использовать данный queryset, то выполниться только один запрос, а не столько сколько итераций в цикле.

        attr_list = Template.objects.filter(options__isnull=False).select_related('options')

        for attr_old_template in attr_old_template_list:
        	# здесь .exists() уже не будет делать запрос к базе, а проверять в существующем queryset из attr_list
            if not attr_list.filter(options__name=attr_old_template.options.name).exists():
                pass

Модели

	@property - позволяет определить имя функции, как поле модели (значения поля будет выдаваться динамически результатом функции)

Нюансы

	Чтобы отправлялись сообщения об ошибках DEBUG должен быть в False и в ADMINS = [('Ilya', 'kaduk@gmail.com')] указана почта куда оптравлять ошибки.

	У формы нельзя взять старое значение (только через базу).