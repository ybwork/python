Оглавление

	Тестирование

	Хранение файлов

	Фильтрация

	Юнит тесты

	Юнит тесты (нюансы)

	Юнит тесты (команды)

	Множественное создание

	Админка

	Запросы

	Модели

	Трассировка (pycharm)

	Настройка бд

	The contenttypes framework

	Миграции

	Миграции тестирование работы в бою

	Настройки базы

	Валидаторы

	Импорт файла settings

	Менеджеры модели и queryset-ы

	Нюансы

Тестирование

	Есть класс Client для тестов клиентской части приложения.

	Есть класс RequestFactory для использования в тестах объекта request.

	Из объекта Client можно получить текущего пользователя через result.wsgi_request.user

Хранение файл

	Есть класс FileSystemStorage, который реализует всю работу по локальному хранению файлов.

Фильтрация

	При множественной фильтрации каждый queryset уникален и никак не связан с предыдущим.

		q_1 = Question.objects.filter(year=2006) 
		q_2 = q_1.filter(is_active=True)
		q_3 = q_2.filter(tag='music')

Юнит тесты
	
	Тестируют работу методов, функций и классов.

	Класс для теста должен наследоваться от from django.test import TestCase

	Метод setUp это встроенный метод тестирования, который позволяет создавать тестовые данные в бд в момент. Нужно потому что при прохождении тестов создается пустая бд.

	Именуем в формате PropertyAdminTests. Обратить внимание на то что во множественном числе - Tests.

	Именование делится на форматы:

		QuestionViewTests

		QuestionMethodTests

Юнит тесты (нюансы)

	Помнить, что при выполнении тестов создается ПУСТАЯ база данных.

	Если класс в котором написаны тесты наследуется от from django.test import TestCase, то при выполнении будет создана новая, пустая и временная база данных.

	Если класс в котором написаны тесты наследуется напрямую от unittest.TestCase (класс чистого python для тестирования), то при выполнении будет использована боевая база данных и это может иметь последствия.

	Помнить, что метод create_user возвращает хэшированный пароль и через него нельзя будет потом залогиниться. Поэтому можно сделать приватное св-во в методе setUp.

	Когда делаем логин и потом последующий запрос помнить, что нужно делать через клиент self.client.login, self.client.post

	Для тестирование кастомных actions в панели администратора используем:

		self.client.post(
            reverse('admin:cards_productcard_changelist'),
            {
                'action': 'mark_cards_as_checked', 
                '_selected_action': ProductCard.objects.values_list('pk', flat=True)
            }
        )

    Если используем много баз данных, а для тестов должна создаваться одна, то можно при выполнении тестов переопределить DATABASES:

		if 'test' in sys.argv:
		    DATABASES = {
		        'default': {
		            'ENGINE': 'django.db.backends.mysql',
		            'NAME': 'magic',
		            'USER': 'root',
		            'PASSWORD': 'asdf1234',
		            'HOST': '127.0.0.1',
		            'PORT': '3306',
		            'OPTIONS': {
		            	'charset': 'utf8'
		                'init_command': 'SET default_storage_engine=INNODB',
		            }
		        },
		    }

	Работе тестового клиента может мешать debug_toolbar.

	При работе с тестовым клиентом если создаем суперпользователя, то лучше создавать его, как is_staff=True и is_superuser=True.

	При тестировании исключений один из варинтов такой:

		with self.assertRaises(ValidationError):
			# Если внутри этого метода будет выкинуто исключение ValidationError, то тест прошел
			self.helper.validate_product_card_image_indexes(index_list=[0, 1, 1])

	При работе с методом self.assertEqual(), первый аргумент это метод, который тестируем, а второй это значение, которое он должен вернуть

	Для создания общих данных доступных в каждом классе тесте нужно использовать метод setUpModule. Определяется без класса.

	Использовать bulk_create только в случаях, когда действительно много.

	При комментирование тестовых методов писать их в формате:

		"""Должен фильтровать queryset и возращать валидные карточки товара.

        Валидные это те, у которых есть код 1с, бренд, шаблон у 
        вида-типа и фотографии.


        """

        То есть пишем, что должен делать тестовый метод.

    Каждый метод setUp наполняет базу своими уникальными объектами, которые не зависят от другого метода setUp. То есть если в одном создал 2 объекта, то в этом классе тестов будут доступны только эти два объекта при выборке всех.

   	Лучше не использовать self в setUp, потому что если потом в методах теста обновляется объект, а мы берем его через self, то обновления не видны.

   	Лучше дублировать наполнение данных в каждом методе setUp, потому что если выносить это на setUpModule, то можно запутаться + каждый метод setUp изолирован друг от друга и не вызывает проблем.

Юнит тесты команды

	self.client.login()

	self.assertEqual()

	self.assertQuerysetEqual()

	sefl.assertRaises(NameError)

	response = self.client.post(reverse('admin:user_invoice_add'), {'num': 'x23md'}) - делает пост запрос на нужный урл с нужными параметрами

	response.wsgi_request.user - выводит пользователя, который сделал запрос

	./manage.py test

	./manage.py test app_name/

Множественное создание

	Invoice.objects.bulk_create(
		Invoice(num='bbb'),
		Invoice(num='aaa')
	)

Админка

	response.context['cl'].queryset - доступ к списку сущности

	self.kwargs - доступ к GET параметрам, не работает в actions

	request.get_full_path() - позовляет получить полный путь запроса, вместе с GET параметрами

Запросы

	Permission.objects.filter(codename__in=['add_invoice', 'view_invoice']) - фильтр по нескольким условиям

	Invoice.objects.order_by('?') - рандомная сортировка, может быть медленным и сильно нагружать базу данных, поэтому лучше явно задавать

	TemplateEntry.objects.filter(template=obj.template.pk).query - вывод чистого sql запроса

	User.objects.create(name='Ilya') - создает и возвращает созданную сущность

    Book.objects.filter(name='name').select_related('author') - позволяет взять сразу все связанные объекты (если мы в дальнейшем будем в цикле использовать данный queryset, то выполниться только один запрос, а не столько сколько итераций в цикле.

        attr_list = Template.objects.filter(options__isnull=False).select_related('options')

        for attr_old_template in attr_old_template_list:
        	# здесь .exists() уже не будет делать запрос к базе, а проверять в существующем queryset из attr_list
            if not attr_list.filter(options__name=attr_old_template.options.name).exists():
                pass

    Attribute.objects.bulk_create([Attribute(name='one'), Attribute(name='two')]) - multiple создание объектов одним запросом, возвращает созданные объекты

    ProductCard.objects.values_list('code', flat=True) - flat=True делает результат просто списком [1, 2, 3], а если без flat=True, то было бы так [(1), (2), (3)]

Модели

	В сообществе принято называть таблицы и модели в единственном числе. Например Product.

	@property - позволяет определить имя функции, как поле модели (значения поля будет выдаваться динамически результатом функции)

	ForeignKey('Manufacturer', on_delete=models.CASCADE) - позволяет создать связь с моделью, которая еще не определена. Если нужно обратиться к модели из другого приложения, то пишем так 'name_app.Manufacturer'

	ForeignKey.limit_choices_to - позволяет ограничить выбор внешнего ключа для модельной форме в админке, по умолчанию в селект выводится все данные из queryset

	Если в коде целая портянка из запросов, то её лучше вынести в модель. Даже если это простой запрос.

Трассировка (pycharm)

	...

	Для просмотра кол-ва запросов в debug режиме
	
		from django.conf import settings
		settings.DEBUG = True
		from django.db import connection
		Model.objects.count()
		print len(connection.queries)

Настройка бд

    'TEST': { 'CHARSET': 'utf8', 'COLLATION': 'utf8_general_ci',} - позволяет задать кодировку бд при выполнении тестов

The contenttypes framework

	...

Миграции

	Создали и описали модель.

	Выполнили ./manage.py makemigrations

	В приложении в директории migrations создался файл.

	Выполнили ./manage.py migrate

	В базе создались таблицы.

	Добавили в модель новое поле.

	Выполнили ./manage.py makemigrations

	В приложении в директории migrations создался новый файл.

	Выполнили ./manage.py migrate

	В базе в нужной таблице создалось поле, которое добавили в модель.

	Удалили новое поле из модели.

	Выполнили ./manage.py makemigrations

	В приложении в директории migrations создался еще один файл. При этом предыдущие два остались.

	Выполнили ./manage.py migrate

	В базе в нужной таблице удалилось поле, которое удалили из модели.

Миграции тестирование работы в бою

	Заливаем актуальный дамп в бд.

	Создаем новое поле в модели.

	Выполняем ./manage.py makemigrations

	Выполняем ./manage.py migrate

	Должно успешно создасться новое поле в бд.

Настройки базы

	Установка кодировки и подсистемы для mysql 

		DATABASES = {
		    'default': {
		    	...
		        'OPTIONS': {
		            'charset': 'utf8',
		            'init_command': 'SET default_storage_engine=INNODB',
		        }
		    },
		}

Валидаторы

	Это функции для валидации значений, которые вешаются на поля модели.

	Обычно храняться в приложении в файле validators.py

Импорт файла settings

	Правильно так:

		from django.conf import settings

		if settings.DEBUG:
			pass

Менеджеры модели и queryset-ы

	Queryset-ы модели более гибче, чем менеджеры модели и похожи на фильтры. Используются не вместо Book.objects, а вместе с Book.objects.queryset_method()

		class ProductCardQuerySet:
			def get_actual(self):
				return 'actual'

		objects = ProductCardQuerySet.as_manager()

	Есть дилемма: где создавать метод, который работает с queryset, а потом преобразует его к листу через values_list? Ответ: Я предпочитаю возвращать queryset, а потом после вызова метода дописывать values_list.

	В кастомном queryset-е не переопределяется метод get_queryset, только в кастомном менеджере.
	
Нюансы

	Сообщения об ошибках

		Чтобы отправлялись сообщения об ошибках DEBUG должен быть в False и в ADMINS = [('Ilya', 'kaduk@gmail.com')] указана почта куда оптравлять ошибки.

	Старое значение формы

		У формы нельзя взять старое значение (только через базу).

	Использование last, first методов

		Не использовать неявные методы last, first и т.д. Лучше взять одну сущность по условию, например get(pk=3)

	Update

		При выполнение update, если обновляемое значение отличается от уже существующего, то затирает self.queryset, если нет, то возращает.