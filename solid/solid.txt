Оглавление

	Что это

	Принцип единственной ответственности (Single responsibility)

	Принцип инверсии зависимостей (Dependency Invertion)

	Принцип открытости/закрытости (Open-closed)

	Принцип разделения интерфейса (Interface segregation)

	Принцип подстановки Барбары Лисков (Liskov substitution)

Что это

    Это принципы объектно-ориентированного программирования и проектирования.

    Автор Роберт Мартин.

Принцип единственной ответственности (Single responsibility)

	Каждый метод, модуль, класс должен заниматься чем то одним.

	Например если один и тот же класс работает с пользовательским интерфейсом и взаимодействует с базой данных, то это явное нарушение данного принципа.

Принцип инверсии зависимостей (Dependency Invertion)

	В любой программе существуют отношения между классами. 

	Например один класс внутри себя создает экземпляр другого класса.

	При такой зависимости мы не можем менять экземпляр класса в зависимости от работы программы.

	Если в языке программирования нет интерфейсов, то лучше реализовывать через конструктор или сеттер.

	Пример:

		Допустим, мы разработали класс TextReceiver, который принимает по какому-либо каналу связи текст и расшифровывает его. 

		При этом TextReceiver реализуется посредством класса TextDecription. То есть внутри TextReceiver создается экземпляр класса TextDecription.

		Все работает замечательно до тех пор, пока не появится необходимость поддерживать несколько алгоритмов шифрования и заменять один алгоритм на другой во время выполнения программы.

	Пример кода:

		class Speaker {
		    private SpeechWriter writer;
		    
		    public Speaker(SpeechWriter writer) {
		        this.writer = writer;
		    }
		    
		    // через сеттер
		    // void setWriter(SpeechWriter writer) {
		    //    this.writer = writer;
		    // }
		    
		    public void spead() {
		        System.out.println(writer.getSpeech());
		}

		class HelloSpeechWriter {
		    public String getSpeech() {
		        return "Hello guys!";
		    }
		}
		
		class GoSpeechWriter {
		    public String getSpeech() {
		        return "Go go go!";
		    }
		}


Принцип открытости/закрытости (Open-closed)

	Программные сущности (классы, модули, функции) должны быть открыты для расширения, но закрыты для изменения.

	Целью является разработка системы, которая будет достаточно просто и безболезненно меняться.

	Например, внесение изменений в библиотеку общую для 4-х проектов не должно вести к изменениям в этих 4-х проектах.

	Пример:

		Предположим, что у нас есть объект SmtpMailer.

		Для логирования своих действий он использует Logger, который записывает информацию в текстовые файлы.

			class SmtpMailer:
				def __init__(self):
					self.logger = Logger()

				def send_message(self, message):
					# send message
					self.logger.logging('log text')

		И тоже самое происходит в других классах, которые используют Logger.

		Теперь надо писать лог в базу данных.

		Мы создаём новый класс для этого.

		И теперь мы должны внести изменения логгера во всех местах, где он используется.

		Но ведь по принципу единственности ответственности не SmptMailer отвечает за логирование, почему изменения дошли и до него? 

		Потому что нарушен наш принцип открытости/закрытости и SmptMailer не закрыт для модификации.

	Решение проблемы:

		В данном случае защитить SmtpMailer поможет выделение абстракции.

			class SmtpMailer:
				def __init__(self, logger):
					self.logger = logger

				def send_message(self, message):
					# send message
					self.logger.logging('log text')

			class LoggerToFile:
				pass

			class LoggerToDB:
				pass

			logger_to_file = LoggerToFile()
			smtp_mailer = SmtpMailer(logger=logger_to_file)

	Нарушение принципа открытости/закрытости также затрагивает нарушение принципа единственной ответственности.

Принцип разделения интерфейса (Interface segregation)

	Клиенты не должны зависеть от методов, которые они не используют.

	Если клиенту нужна лишь определенная часть интерфейса (функционала) вашего класса, то этот интерфейс (функционал) необходимо выделить.

	Например:

		Есть класс автомобиля. 

		Клиенты могут смотреть на него по-разному, например инспектор ГИБДД видит лишь номер двигателя и скорость, а жена водителя бардачок и магнитолу. 

		Мы не можем разделить класс на несколько частей, потому что есть водителю нужно отслеживать текущую скорость и хранить в бардачке документы. 

		Тем не менее, класс может выступать в разных ролях.

		Жене совершенно не обязательно знать о номере двигателя и назначении ручника, сотрудник ГИБДД не должен рыться в нашем бардачке. 

		Для решения всех этих проблем достаточно создать несколько специализированных классов интерфейса, которые и следует передавать соответствующим клиентам. 

		Исходный класс при этом останется неизменным.

Принцип подстановки Барбары Лисков (Liskov substitution)

	Принцип подстановки изначально сформулирован Барбарой Лисков и регламентирует правильное использование механизма наследования.

	Выделяются некоторый базовый тип и его подтип (класс-наследник).

	Согласно принципу LSP, программы должны быть написаны таким образом, чтобы в любом месте вместо базового типа мог быть подставлен подтип.

	Это означает, что классы наследники должны реализовывать интерфейс согласованно с интерфейсом базового класса.

	В качестве примера рассмотрим классы геометрических фигур — точка, окружность, сфера.

		Мы могли бы реализовать три класса, независимо друг от друга, но тогда каждый из них содержал бы данные с координатами и соответствующий набор функций — т.е. в нашей программе появился бы повторяющийся код.

		Поэтому среди трех классов нам надо найти наиболее общий и применить механизм наследования.






	