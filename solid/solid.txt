Оглавление

	Что это

	Принцип единственной ответственности (Single responsibility)

	Принцип инверсии зависимостей (Dependency Invertion)

	Принцип открытости/закрытости (Open-closed)

	Принцип подстановки Барбары Лисков (Liskov substitution)

	Принцип разделения интерфейса (Interface segregation)

Что это

    Это принципы объектно-ориентированного программирования и проектирования.

    Автор Роберт Мартин.

Принцип единственной ответственности (Single responsibility)

	Каждый метод, модуль, класс должен заниматься чем то одним.

	Например если один и тот же класс работает с пользовательским интерфейсом и взаимодействует с базой данных, то это явное нарушение данного принципа.

Принцип инверсии зависимостей (Dependency Invertion)

	В любой программе существуют отношения между классами. 

	Например один класс внутри себя создает экземпляр другого класса.

	При такой зависимости мы не можем менять экземпляр класса в зависимости от работы программы.

	Пример:

		Допустим, мы разработали класс TextReceiver, который принимает по какому-либо каналу связи текст и расшифровывает его. 

		При этом TextReceiver реализуется посредством класса TextDecription. То есть внутри TextReceiver создается экземпляр класса TextDecription.

		Все работает замечательно до тех пор, пока не появится необходимость поддерживать несколько алгоритмов шифрования и заменять один алгоритм на другой во время выполнения программы.

Принцип открытости/закрытости (Open-closed)

	Программные сущности (классы, модули, функции) должны быть открыты для расширения, но закрыты для изменения.

	Целью является разработка системы, которая будет достаточно просто и безболезненно меняться.

	Например, внесение изменений в библиотеку общую для 4-х проектов не должно вести к изменениям в этих 4-х проектах.

	Пример:

		Предположим, что у нас есть объект SmtpMailer.

		Для логирования своих действий он использует Logger, который записывает информацию в текстовые файлы.

			class SmtpMailer:
				def __init__(self):
					self.logger = Logger()

				def send_message(self, message):
					# send message
					self.logger.logging('log text')

		И тоже самое происходит в других классах, которые используют Logger.

		Теперь надо писать лог в базу данных.

		Мы создаём новый класс для этого.

		И теперь мы должны внести изменения логгера во всех местах, где он используется.

		Но ведь по принципу единственности ответственности не SmptMailer отвечает за логирование, почему изменения дошли и до него? 

		Потому что нарушен наш принцип открытости/закрытости и SmptMailer не закрыт для модификации.

	Решение проблемы:

		В данном случае защитить SmtpMailer поможет выделение абстракции.

			class SmtpMailer:
				def __init__(self, logger):
					self.logger = logger

				def send_message(self, message):
					# send message
					self.logger.logging('log text')

			class LoggerToFile:
				pass

			class LoggerToDB:
				pass

			logger_to_file = LoggerToFile()
			smtp_mailer = SmtpMailer(logger=logger_to_file)

	Нарушение принципа открытости/закрытости также затрагивает нарушение принципа единственной ответственности.

	




	