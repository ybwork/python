Оглавление

	Что это

	Установка и настройка

	Команды

	Основные понятия

	Как это работает

	Общая схема

	Producer (поставщик)

	Exchange (точка обмена)

	Topic

	Queue (очередь)

	Consumer (подписчик)

	Bindings (переплёты)

	Multiple bindings (составные связи)

	Паттерны

	Очереди задач

	Подтверждение выполнения сообщений

	Устойчивость сообщений и очередей

	Равномерное распределение сообщений

	Размер очереди

	Временные очереди

	Удаленный вызов процедур

	Docker

	Нюансы

Что это

	RabbitMQ ‒ это брокер сообщений.

	Его основная цель принимать и отдавать сообщения.

	Используется если нужно доставить задачу от одного приложения в другое.

	Для использования RabbitMQ необходима библиотека.

	Для python бывают следующие библиотеки: py-amqplib, txAMQP, pika.

Установка и настройка

	wget https://packages.erlang-solutions.com/erlang-solutions_1.0_all.deb

	sudo dpkg -i erlang-solutions_1.0_all.deb

	sudo apt-get update

	sudo apt-get install erlang erlang-nox

	------------------------------------------------------------------------

	sudo apt-get update

	sudo apt-cache policy

	sudo apt-key adv --keyserver "hkps.pool.sks-keyservers.net" --recv-keys "0x6B73A36E6026DFCA"

	wget -O - "https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc" | sudo apt-key add -

	sudo apt-get install apt-transport-https

	echo "deb https://dl.bintray.com/rabbitmq/debian {distribution} main" | sudo tee /etc/apt/sources.list.d/bintray.rabbitmq.list

	echo "deb https://dl.bintray.com/rabbitmq/debian bionic main" | sudo tee /etc/apt/sources.list.d/bintray.rabbitmq.list

	echo "deb https://dl.bintray.com/rabbitmq/debian xenial main" | sudo tee /etc/apt/sources.list.d/bintray.rabbitmq.list

	sudo apt-get update

	sudo apt-get install rabbitmq-server

	sudo service rabbitmq-server start

	-----------------------------------------------------------

	sudo rabbitmqctl add_user admin password 
	sudo rabbitmqctl set_user_tags admin administrator
	sudo rabbitmqctl set_permissions -p / admin ".*" ".*" ".*"

	-----------------------------------------------------------

	sudo rabbitmq-plugins enable rabbitmq_management

	http://localhost:15672

	------------------------------------------------------------

	Если работает на чистом питоне, то pip install pika

Команды

	sudo rabbitmqctl status - выводит версию

	sudo rabbitmqctl list_queues - выводит список очередей

	sudo rabbitmqctl name messages_ready - выводит список выполненных задач

	sudo rabbitmqctl name messages_ready messages_unacknowledged - выводит список невыполненных задач

	sudo rabbitmqctl list_exchanges - выводит список точек обмена

	sudo rabbitmqctl list_bindings - выводит список связанных точек обмена с очередями

	sudo systemctl enable rabbitmq-server - включает сервер
	sudo systemctl start rabbitmq-server - запускает сервер
	sudo systemctl stop rabbitmq-server - останавливает сервер

	sudo rabbitmqctl add_user admin password
	sudo rabbitmqctl set_user_tags admin administrator
	sudo rabbitmqctl set_permissions -p / admin ".*" ".*" ".*"

Основные понятия

	Поставщик, точка обмена, очередь, подписчик.

Как это работает

	Есть поставщик. Поставщик посылает сообщение/сигнал/задачу в точку обмена.

	Точка обмена принимает сообщение от поставщика и решает, что с ним делать. Точка обмена может отправить сообщение в очередь или удалить его.

	Очередь принимает сообщение и отправляет его дальше в подписчик. Может быть создана при вызове подписчика или при вызове поставщика, но лучше делать в подписчике.

	Подписчик слушает очередь и если там есть сообщения, обрабатывает их. Как правило подписчик находится в другом приложении, с котором осуществляется связь. Один подписчик можно запустить в любом кол-ве процессов.

	Когда возникает потребность выполнять какие то задачи последовательно можно использовать одну очередь, но это плохая идея, потому что если все подписчики заняты, то размер очереди будет расти или если будут появлятся новые задачи, то будет расти кол-во поставщиков. 

	Правильным решением будет связка в которую будут приходить отчёты о завершении задачи, а обработчик этой связки будет в зависимости от выполненной задачи отправлять новую. Это реализуется с помощью exchange + queue + consumer (здесь генерация новых задач в зависимости от выполнения предыдущих)

	Rabbit только доставляет задачи. Он ничего не знает о том выполнилось задачи или нет.

	В реализации не мешать логику событий с логикой реализации.

Producer (поставщик)

	Программа, которая отправляет сообщения. Обозначается буквой P.

Exchange (точка обмена)

	Основная идея в модели отправки сообщений Rabbit в том, что поставщик никогда не отправляет сообщения на прямую в очередь.

	Как правила поставщик отправляет сообщения в точку обмена.

	Точка обмена в свою очередь отправляет сообщение в очередь.

	Точка обмена разруливает всю работу с сообщениями. 

	Точка обмена точно знает отправить сообщение в конкретную очередь, либо в несколько очередей, либо не отправлять никому и удалить его.

	Что делать с сообщением указывается в типе точки обмена.

	Существуют несколько типов: direct, topic, headers и fanout.

	direct - сообщения идут в ту очередь, в которую точка обмена их отправляет, это реализуется с помощью роутинга

	topic - сообщения идут в конкретно заданную точкой обмена очередь, но роут не может быть произвольным и должен состоять из списка слов разделённых точкой, слова могут быть любыми, но они должны описывать свойство сообщения, это помогает отправлять сообщения по заданным критериям, например мы может получить все логи с типом error, пришедшие из cron, и все логи пришедшие с kern.

		Логика работы topic такая же как и у direct — сообщения доходят до тех очередей, routing key которых совпадает с routing key сообщения. Но есть 2 специальные возможности для topic:

			kern.* - вместо звёздочки может быть только одно слово

			cron.# - вместо решётки может быть заменено на 0 или более слов

	headers - ...

	fanout - копирует все сообщения во все очереди, channel.exchange_declare('logs', 'fanout', False, False, False) - logs это имя точки обмена

	Если имеем один Exchange и одну очередь, то лучше задать тип direct, потому что если вдруг создадим случайно ещё одну очередь, то ничего не произойдёт.

Topic

	Это тип exchange.

Fanout

	Это тип exchange.

	Exchange отправляет одно сообщение во все очереди.

Queue (очередь)

	Находится внутри обменника, то есть находится внтури RabbitMQ

	Сообщения хранятся в очередях

	Любое кол-во поставщиков могут отправлять сообщения в очередь

	Любое кол-во подписчиков могут получать сообщения из одной очереди

	Очереди создаются и в файлах поставщиках и в файлах подписчиках. Это нужно потому что мы не знаем какой файл сработает раньше. При этом каждая очередь с одинаковым названием будет созданна только единожды.

Consumer (подписчик)

	Программа принимающая сообщения

	Находится в состоянии ожидания сообщений

Bindings (переплёты)

	Нужны для того чтобы точка обмена отправляла сообщение в очередь

	channel.queue_bind('one', 'logs') - связывает точку обмена с очередью, one - это имя очереди, logs - это имя точки доступа

	Связи могут осуществляться с помощью роутинга

	channel.queue_bind(routing_key='black') - связывает очередь с сообщениями у которых роут black

Multiple bindings (составные связи)

	Нужны для того чтобы связать точку обмена с несколькими очередями

	Реализуются с помощью такой конструкции:

		new_task

			severity = sys.argv[1] if len(sys.argv) > 1 else 'info'
			channel.basic_publish(
				exchange='direct_logs',
                routing_key=severity,
                body=message
            )

		worker

			severities = sys.argv[1:]
			if not severities:
			    sys.stderr.write("Usage: %s [info] [warning] [error]\n" % sys.argv[0])
			    sys.exit(1)

			for severity in severities:
			    channel.queue_bind(
			    	exchange='direct_logs',
			        queue=queue_name,
			        routing_key=severity
			    )

Паттерны

	round-robin (поставщик отправляет сообщения по очереди каждому поставщику, смотреть очереди задач)

	publish-subscribe (поставщик отправляет одно сообщение нескольким подписчикам)

Очереди задач

	Основная цель не выполнять задачу сразу и не ждать пока уже начатая задача завершится.

	Программа-обработчик (worker.py), работающая в фоновом режиме, примет задачу на обработку, и через какое-то время выполнит её.

	Запускаем 3 консоли. Две из них будут вызывать worker.py, который является подписчиком и одна консоль запустит поставщика.

	Таким образом 2 подписчика будут ждать задачи из очереди.

	Преимущество очереди задач в том, что можно выполнять работу паралельно несколькими программами.

	Когда поставщик отправляет например пять сообщений подряд, то два воркера будут получать эти сообщения по очереди, то есть первое сообщение попадёт в первый воркер, второе сообщение попадёт во второй воркер, третье сообщение попадёт снова в первый воркер и т.д.

	Такой подход к распределению задач называется round-robin

Подтверждение выполнения сообщений

	Может возникнуть ситуация, когда поставщик отправил сообщение, подписчик начал его выполнять, но произошла ошибка и задача не выполнилась до конца.

	В таких случаях нужно подтверждение, что сообщение не только доставленно, но и выполненно.

	RabbitMQ поддерживает подтверждение сообщений. Подтверждение (ack) отправляется подписчиком для информирования RabbitMQ о том, что полученное сообщение было обработано и RabbitMQ может его удалить.

	Если подписчик прекратил работу и не отправил подтверждение, RabbitMQ поймет, что сообщение не было обработано, и передаст его другому подписчику.

Устойчивость сообщений и очередей

	По умолчанию при остановке или падении сервера RabbitMQ все очереди и сообщения теряются, но это поведение можно изменить.

	Для того чтобы сообщения оставались в очереди после перезапуска сервера, необходимо сделать как очереди, так и сообщения устойчивыми.

	channel.queue_declare(queue='hello', durable=True) - позволяет сделать очереди устойчивыми (эта команда не отработает если очередь уже созданна, поэтому лучше создать новую)

	channel.basic_publish(exchange='',
		routing_key="task_queue",
		body=message,
		properties=pika.BasicProperties(
			delivery_mode = 2, - этот параметр позволяет сделать сообщения устойчивыми
		)
    )

    Устойчивость сообщения не гарантирует, что оно не будет потеряно, потому что есть небольшой промежуток времени, когда RabbitMQ подтвердил принятие сообщения, но еще не записал его на диск.

    Если нужна более высокая надёжность, можно оборачивать сообщения в транзакции.

Равномерное распределение сообщений

	Если первый подписчик имеет более простые задачи, чем второй, то большую часть времени он будет свободен.

	Чтобы изменить такое поведение, мы можем использовать метод basic_qos с опцией prefetch_count=1. 

	После установки данной опции подписчик не получит новое сообщение, до тех пор пока не обработает и не подтвердит предыдущее. 

	И RabbitMQ передаст сообщение первому освободившемуся подписчику.

	channel.basic_qos(prefetch_count=1)

Размер очереди

	Если все подписчики заняты, то размер очереди может увеличиваться. Следует обращать на это внимание и, возможно, увеличить количество подписчиков.

Временные очереди

	Актуальны если нужно чтобы в очередь поступали все сообщения и эти сообщения были не устаревшими.

	Для этого нужно каждый раз при соединении с Rabbit создавать новую очередь без имени (оно сгенерируется автоматом) и каждый раз, когда подписчик отключается от Rabbit удалять очередь.

	channel.queue_declare('') - создаёт очередь без имени и когда подписчик отключается, автоматически удаляет её.

Удаленный вызов процедур

	Нужен если нам нужно что то выполнить на удалённой машине.

	Для этого используется технология RPC или удалённый вызов процедур.

	RPC будет включать в себя клиент и сервер.

	Клиент отправляет запрос и сервер отвечает на запрос.

	Чтобы получить ответ, клиент должен передать очередь для размещения результатов вместе с запросом.

Docker

	docker run -d --hostname my-rabbit --name some-rabbit rabbitmq:3-management (если использую повторно, то docker start container_name)

	http://localhost:15672 - panel

	bash

		export WORKON_HOME=~/.virtualenvs

		VIRTUALENVWRAPPER_PYTHON='/usr/bin/python3'

		source /usr/local/bin/virtualenvwrapper.sh

		workon

		workon env_name

		docker exec -it container_name bash

Нюансы

	Если поставщик и подписчики на одном сервере, то имеет смысл разруливать всё с помощью параметров подписчиков внутри callback.

	Если поставщик и подписчики на разных серверах, то имеет смысл сделать роутр, который будет всё разруливать.

	Если обращаемся с другого севера, то нужно создать нового пользователя и настроить подключение в pika:

		credentials = pika.PlainCredentials('yet', 'asdfasdf')
		parameters = pika.ConnectionParameters(
			'172.17.0.1',
			port=5672,
			credentials=credentials
		)

Задача

	Создать 3 docker контейнера (task, web, service).

	Первый посылает сообщение "создать польователя".

	Второй с именем service добавляет в почту, при сообщениии "создать пользователя". Посылает сообщение "я добавил в почту, добавь в редмайн"
	
	Второй с именем web добавляет в слак, при сообщениии "я добавил в почту, добавь в редмайн".






