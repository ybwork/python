Оглавление

	Что это

	Установка и настройка

	Команды

	Основные понятия

	Как это работает

	Общая схема

	Producer (поставщик)

	Exchange (точка обмена)

	Topic

	Queue (очередь)

	Consumer (подписчик)

	Bindings (переплёты)

	Multiple bindings (составные связи)

	Паттерны

	Очереди задач

	Подтверждение выполнения сообщений

	Устойчивость сообщений и очередей

	Равномерное распределение сообщений

	Размер очереди

	Временные очереди

	Удаленный вызов процедур

	Docker

	Fanout (пример)

	Topic (пример)

Что это

	RabbitMQ ‒ это брокер сообщений.

	Его основная цель принимать и отдавать сообщения.

	Используется если нужно доставить задачу от одного приложения в другое.

	Для использования RabbitMQ необходима библиотека.

	Для python бывают следующие библиотеки: py-amqplib, txAMQP, pika.

Установка и настройка

	wget https://packages.erlang-solutions.com/erlang-solutions_1.0_all.deb

	sudo dpkg -i erlang-solutions_1.0_all.deb

	sudo apt-get update

	sudo apt-get install erlang erlang-nox

	echo 'deb http://www.rabbitmq.com/debian/ testing main' | sudo tee /etc/apt/sources.list.d/rabbitmq.list

	wget -O- https://www.rabbitmq.com/rabbitmq-release-signing-key.asc | sudo apt-key add -

	sudo apt-get update

	sudo apt-get install rabbitmq-server

	sudo systemctl enable rabbitmq-server
	sudo systemctl start rabbitmq-server
	sudo systemctl stop rabbitmq-server

	sudo rabbitmqctl add_user admin password 
	sudo rabbitmqctl set_user_tags admin administrator
	sudo rabbitmqctl set_permissions -p / admin ".*" ".*" ".*"

	sudo rabbitmq-plugins enable rabbitmq_management

	start rabbit manage panel on http://localhost:15672

	pip install pika

Команды

	sudo rabbitmqctl status - выводит версию

	sudo rabbitmqctl list_queues - выводит список очередей

	sudo rabbitmqctl name messages_ready - выводит список выполненных задач

	sudo rabbitmqctl name messages_ready messages_unacknowledged - выводит список невыполненных задач

	sudo rabbitmqctl list_exchanges - выводит список точек обмена

	sudo rabbitmqctl list_bindings - выводит список связанных точек обмена с очередями

	sudo systemctl enable rabbitmq-server - ключает сервер

	sudo systemctl start rabbitmq-server - запускает сервер
	
	sudo systemctl stop rabbitmq-server - останавливает сервер

	sudo rabbitmqctl add_user admin password
	sudo rabbitmqctl set_user_tags admin administrator
	sudo rabbitmqctl set_permissions -p / admin ".*" ".*" ".*"

Основные понятия

	Поставщик, точка обмена, очередь, подписчик.

Как это работает

	Есть поставщик. Поставщик посылает сообщение/сигнал/задачу в точку обмена.

	Точка обмена принимает сообщение от поставщика и решает, что с ним делать. Точка обмена может отправить сообщение в очередь или удалить его.

	Очередь принимает сообщение и отправляет его дальше в подписчик. Может быть создана при вызове подписчика или при вызове поставщика, но лучше делать в подписчике.

	Подписчик слушает очередь и если там есть сообщения, обрабатывает их. Как правило подписчик находится в другом приложении, с котором осуществляется связь. Один подписчик можно запустить в любом кол-ве процессов.

Producer (поставщик)

	Программа, которая отправляет сообщения. Обозначается буквой P.

Exchange (точка обмена)

	Основная идея в модели отправки сообщений Rabbit в том, что поставщик никогда не отправляет сообщения на прямую в очередь.

	Как правила поставщик отправляет сообщения в точку обмена.

	Точка обмена в свою очередь отправляет сообщение в очередь.

	Точка обмена разруливает всю работу с сообщениями. 

	Точка обмена точно знает отправить сообщение в конкретную очередь, либо в несколько очередей, либо не отправлять никому и удалить его.

	Что делать с сообщением указывается в типе точки обмена.

	Существуют несколько типов: direct, topic, headers и fanout.

	direct - сообщения идут в ту очередь, в которую точка обмена их отправляет, это реализуется с помощью роутинга

	topic - сообщения идут в конкретно заданную точкой обмена очередь, но роут не может быть произвольным и должен состоять из списка слов разделённых точкой, слова могут быть любыми, но они должны описывать свойство сообщения, это помогает отправлять сообщения по заданным критериям, например мы может получить все логи с типом error, пришедшие из cron, и все логи пришедшие с kern.

		Логика работы topic такая же как и у direct — сообщения доходят до тех очередей, routing key которых совпадает с routing key сообщения. Но есть 2 специальные возможности для topic:

			kern.* - вместо звёздочки может быть только одно слово

			cron.# - вместо решётки может быть заменено на 0 или более слов

	headers - ...

	fanout - копирует все сообщения во все очереди, channel.exchange_declare('logs', 'fanout', False, False, False) - logs это имя точки обмена

	Если имеем один Exchange и одну очередь, то лучше задать тип direct, потому что если вдруг создадим случайно ещё одну очередь, то ничего не произойдёт.

Topic

	Это тип exchange.

Fanout

	Это тип exchange.

	Exchange отправляет одно сообщение во все очереди.

Queue (очередь)

	Находится внутри обменника, то есть находится внтури RabbitMQ

	Сообщения хранятся в очередях

	Любое кол-во поставщиков могут отправлять сообщения в очередь

	Любое кол-во подписчиков могут получать сообщения из одной очереди

	Очереди создаются и в файлах поставщиках и в файлах подписчиках. Это нужно потому что мы не знаем какой файл сработает раньше. При этом каждая очередь с одинаковым названием будет созданна только единожды

Consumer (подписчик)

	Программа принимающая сообщения

	Находится в состоянии ожидания сообщений

Bindings (переплёты)

	Нужны для того чтобы точка обмена отправляла сообщение в очередь

	channel.queue_bind('one', 'logs') - связывает точку обмена с очередью, one - это имя очереди, logs - это имя точки доступа

	Связи могут осуществляться с помощью роутинга

	channel.queue_bind(routing_key='black') - связывает очередь с сообщениями у которых роут black

Multiple bindings (составные связи)

	Нужны для того чтобы связать точку обмена с несколькими очередями

	Реализуются с помощью такой конструкции:

		new_task

			severity = sys.argv[1] if len(sys.argv) > 1 else 'info'
			channel.basic_publish(
				exchange='direct_logs',
                routing_key=severity,
                body=message
            )

		worker

			severities = sys.argv[1:]
			if not severities:
			    sys.stderr.write("Usage: %s [info] [warning] [error]\n" % sys.argv[0])
			    sys.exit(1)

			for severity in severities:
			    channel.queue_bind(
			    	exchange='direct_logs',
			        queue=queue_name,
			        routing_key=severity
			    )

Паттерны

	round-robin (поставщик отправляет сообщения по очереди каждому поставщику, смотреть очереди задач)

	publish-subscribe (поставщик отправляет одно сообщение нескольким подписчикам)

Очереди задач

	Основная цель не выполнять задачу сразу и не ждать пока уже начатая задача завершится.

	Программа-обработчик (worker.py), работающая в фоновом режиме, примет задачу на обработку, и через какое-то время выполнит её.

	Запускаем 3 консоли. Две из них будут вызывать worker.py, который является подписчиком и одна консоль запустит поставщика.

	Таким образом 2 подписчика будут ждать задачи из очереди.

	Преимущество очереди задач в том, что можно выполнять работу паралельно несколькими программами.

	Когда поставщик отправляет например пять сообщений подряд, то два воркера будут получать эти сообщения по очереди, то есть первое сообщение попадёт в первый воркер, второе сообщение попадёт во второй воркер, третье сообщение попадёт снова в первый воркер и т.д.

	Такой подход к распределению задач называется round-robin

Подтверждение выполнения сообщений

	Может возникнуть ситуация, когда поставщик отправил сообщение, подписчик начал его выполнять, но произошла ошибка и задача не выполнилась до конца.

	В таких случаях нужно подтверждение, что сообщение не только доставленно, но и выполненно.

	RabbitMQ поддерживает подтверждение сообщений. Подтверждение (ack) отправляется подписчиком для информирования RabbitMQ о том, что полученное сообщение было обработано и RabbitMQ может его удалить.

	Если подписчик прекратил работу и не отправил подтверждение, RabbitMQ поймет, что сообщение не было обработано, и передаст его другому подписчику.

Устойчивость сообщений и очередей

	По умолчанию при остановке или падении сервера RabbitMQ все очереди и сообщения теряются, но это поведение можно изменить.

	Для того чтобы сообщения оставались в очереди после перезапуска сервера, необходимо сделать как очереди, так и сообщения устойчивыми.

	channel.queue_declare(queue='hello', durable=True) - позволяет сделать очереди устойчивыми (эта команда не отработает если очередь уже созданна, поэтому лучше создать новую)

	channel.basic_publish(exchange='',
		routing_key="task_queue",
		body=message,
		properties=pika.BasicProperties(
			delivery_mode = 2, - этот параметр позволяет сделать сообщения устойчивыми
		)
    )

    Устойчивость сообщения не гарантирует, что оно не будет потеряно, потому что есть небольшой промежуток времени, когда RabbitMQ подтвердил принятие сообщения, но еще не записал его на диск.

    Если нужна более высокая надёжность, можно оборачивать сообщения в транзакции.

Равномерное распределение сообщений

	Если первый подписчик имеет более простые задачи, чем второй, то большую часть времени он будет свободен.

	Чтобы изменить такое поведение, мы можем использовать метод basic_qos с опцией prefetch_count=1. 

	После установки данной опции подписчик не получит новое сообщение, до тех пор пока не обработает и не подтвердит предыдущее. 

	И RabbitMQ передаст сообщение первому освободившемуся подписчику.

	channel.basic_qos(prefetch_count=1)

Размер очереди

	Если все подписчики заняты, то размер очереди может увеличиваться. Следует обращать на это внимание и, возможно, увеличить количество подписчиков.

Временные очереди

	Актуальны если нужно чтобы в очередь поступали все сообщения и эти сообщения были не устаревшими.

	Для этого нужно каждый раз при соединении с Rabbit создавать новую очередь без имени (оно сгенерируется автоматом) и каждый раз, когда подписчик отключается от Rabbit удалять очередь.

	channel.queue_declare('') - создаёт очередь без имени и когда подписчик отключается, автоматически удаляет её.

Удаленный вызов процедур

	Нужен если нам нужно что то выполнить на удалённой машине.

	Для этого используется технология RPC или удалённый вызов процедур.

	RPC будет включать в себя клиент и сервер.

	Клиент отправляет запрос и сервер отвечает на запрос.

	Чтобы получить ответ, клиент должен передать очередь для размещения результатов вместе с запросом.

Docker

	docker run -d --hostname my-rabbit --name some-rabbit rabbitmq:3-management (если использую повторно, то docker start container_name)

	http://localhost:15672 - panel

	bash

		export WORKON_HOME=~/.virtualenvs

		VIRTUALENVWRAPPER_PYTHON='/usr/bin/python3'

		source /usr/local/bin/virtualenvwrapper.sh

		workon

		workon env_name

		docker exec -it container_name bash

Fanout (пример)

	task.py

		import pika
		import sys

		connection = pika.BlockingConnection(pika.ConnectionParameters(host='127.0.0.1'))
		channel = connection.channel()

		channel.exchange_declare(
			exchange='accounts',
			exchange_type='fanout'
		)

		message = sys.argv[1]

		channel.basic_publish(
			exchange='accounts',
			routing_key='',
			body=message
		)

		print('Sent {}'.format(message))

		connection.close()

	worker.py

		import pika
		import sys

		connection = pika.BlockingConnection(pika.ConnectionParameters(host='127.0.0.1'))
		channel = connection.channel()

		channel.exchange_declare(
		    exchange='accounts',
		    exchange_type='fanout'
		)

		queue_name = sys.argv[1]

		channel.queue_declare(queue=queue_name)

		channel.queue_bind(
		    exchange='accounts',
		    queue=queue_name
		)


		def callback(ch, method, properties, body):
		    print(body)


		channel.basic_consume(
		    callback,
		    queue=queue_name,
		    no_ack=True
		)

		channel.start_consuming()

Topic (пример)

	task.py

	worker.py

Задача

	Создать обработчики для каждой задачи или для группы задач. (Список адресатов и само сообщение)

	Запуск одной командой

	Декомпозиция

		руководитель сказал - учётку создали

		сервис центр - инфо пользователя и веб - создание аккаунтов

		создание аккаунтов - инфо веб

		инфо веб - инфо руководителя, остальные группы пользователей - добавление сотрудника в группу

	Описание

		Создаём поставщика, который отправляет сигнал "завести нового пользователя".

		Создаём обработчик, который принял сигнал "появился новый пользователь" и создал учётку.

		-------------

		После создания учётки, обработчик посылает новый сигнал "пользователь заведён".

		Создаём три обработчика. 1-ый отправляет смс пользователю, 2-ой отправляет почту веб сектору, 3-ий создаёт учётки в 3 системах (gitlab, redmine, confluence).

		Обработчики

		Обработчик, который отвечает за рассылку запускаем в 2-х процессах.

		Обработчик, который отвечает за создание аккаунтов запускаем в 3-х процессах.

		-------------

		После создания аккаунта в одном из сервисов, отправляем новый сигнал для веб-сектора "пользователь добавлен"

		В качестве обработчика будет работать, тот который отправляет по почте, поэтом просто запускаем его в новом процессе.

		-------------

		После информирования веб сектора, создаём сигнал "финальные действия".

		Создаём один новый обработчик, который добавляет пользователя в группу.

		Для информирование оставшихся секторов используем уже существующий обработчик. Открываем его в 2-х процессах.

Варианты решения

	

	

