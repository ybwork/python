Оглавление

	Что это

	Установка и настройка

	Команды

	Основные понятия

	Как это работает

	Общая схема

	Producer (поставщик)

	Exchange (точка обмена)

	Topic

	Queue (очередь)

	Consumer (подписчик)

	Bindings (переплёты)

	Multiple bindings (составные связи)

	Паттерны

	Очереди задач

	Подтверждение выполнения сообщений

	Устойчивость сообщений и очередей

	Равномерное распределение сообщений

	Размер очереди

	Временные очереди

	Удаленный вызов процедур

	Docker

	Нюансы

Что это

	RabbitMQ ‒ это брокер сообщений.

	Его основная цель принимать и отдавать сообщения.

	Используется если нужно доставить задачу от одного приложения в другое.

	Для использования RabbitMQ необходима библиотека.

	Для python бывают следующие библиотеки: py-amqplib, txAMQP, pika.

Установка и настройка

	wget https://packages.erlang-solutions.com/erlang-solutions_1.0_all.deb

	sudo dpkg -i erlang-solutions_1.0_all.deb

	sudo apt-get update

	sudo apt-get install erlang erlang-nox

	echo 'deb http://www.rabbitmq.com/debian/ testing main' | sudo tee /etc/apt/sources.list.d/rabbitmq.list

	wget -O- https://www.rabbitmq.com/rabbitmq-release-signing-key.asc | sudo apt-key add -

	sudo apt-get update

	sudo apt-get install rabbitmq-server

	sudo systemctl enable rabbitmq-server
	sudo systemctl start rabbitmq-server
	sudo systemctl stop rabbitmq-server

	sudo rabbitmqctl add_user admin password 
	sudo rabbitmqctl set_user_tags admin administrator
	sudo rabbitmqctl set_permissions -p / admin ".*" ".*" ".*"

	sudo rabbitmq-plugins enable rabbitmq_management

	start rabbit manage panel on http://localhost:15672

	pip install pika

Команды

	sudo rabbitmqctl status - выводит версию

	sudo rabbitmqctl list_queues - выводит список очередей

	sudo rabbitmqctl name messages_ready - выводит список выполненных задач

	sudo rabbitmqctl name messages_ready messages_unacknowledged - выводит список невыполненных задач

	sudo rabbitmqctl list_exchanges - выводит список точек обмена

	sudo rabbitmqctl list_bindings - выводит список связанных точек обмена с очередями

	sudo systemctl enable rabbitmq-server - ключает сервер

	sudo systemctl start rabbitmq-server - запускает сервер
	
	sudo systemctl stop rabbitmq-server - останавливает сервер

	sudo rabbitmqctl add_user admin password
	sudo rabbitmqctl set_user_tags admin administrator
	sudo rabbitmqctl set_permissions -p / admin ".*" ".*" ".*"

Основные понятия

	Поставщик, точка обмена, очередь, подписчик.

Как это работает

	Есть поставщик. Поставщик посылает сообщение/сигнал/задачу в точку обмена.

	Точка обмена принимает сообщение от поставщика и решает, что с ним делать. Точка обмена может отправить сообщение в очередь или удалить его.

	Очередь принимает сообщение и отправляет его дальше в подписчик. Может быть создана при вызове подписчика или при вызове поставщика, но лучше делать в подписчике.

	Подписчик слушает очередь и если там есть сообщения, обрабатывает их. Как правило подписчик находится в другом приложении, с котором осуществляется связь. Один подписчик можно запустить в любом кол-ве процессов.

	Когда возникает потребность выполнять какие то задачи последовательно можно использовать одну очередь, но это плохая идея, потому что если все подписчики заняты, то размер очереди будет расти или если будут появлятся новые задачи, то будет расти кол-во поставщиков. 

	Правильным решением будет связка в которую будут приходить отчёты о завершении задачи, а обработчик этой связки будет в зависимости от выполненной задачи отправлять новую. Это реализуется с помощью exchange + queue + consumer (здесь генерация новых задач в зависимости от выполнения предыдущих)

	Rabbit только доставляет задачи. Он ничего не знает о том выполнилось задачи или нет.

	В реализации не мешать логику событий с логикой реализации.

Producer (поставщик)

	Программа, которая отправляет сообщения. Обозначается буквой P.

Exchange (точка обмена)

	Основная идея в модели отправки сообщений Rabbit в том, что поставщик никогда не отправляет сообщения на прямую в очередь.

	Как правила поставщик отправляет сообщения в точку обмена.

	Точка обмена в свою очередь отправляет сообщение в очередь.

	Точка обмена разруливает всю работу с сообщениями. 

	Точка обмена точно знает отправить сообщение в конкретную очередь, либо в несколько очередей, либо не отправлять никому и удалить его.

	Что делать с сообщением указывается в типе точки обмена.

	Существуют несколько типов: direct, topic, headers и fanout.

	direct - сообщения идут в ту очередь, в которую точка обмена их отправляет, это реализуется с помощью роутинга

	topic - сообщения идут в конкретно заданную точкой обмена очередь, но роут не может быть произвольным и должен состоять из списка слов разделённых точкой, слова могут быть любыми, но они должны описывать свойство сообщения, это помогает отправлять сообщения по заданным критериям, например мы может получить все логи с типом error, пришедшие из cron, и все логи пришедшие с kern.

		Логика работы topic такая же как и у direct — сообщения доходят до тех очередей, routing key которых совпадает с routing key сообщения. Но есть 2 специальные возможности для topic:

			kern.* - вместо звёздочки может быть только одно слово

			cron.# - вместо решётки может быть заменено на 0 или более слов

	headers - ...

	fanout - копирует все сообщения во все очереди, channel.exchange_declare('logs', 'fanout', False, False, False) - logs это имя точки обмена

	Если имеем один Exchange и одну очередь, то лучше задать тип direct, потому что если вдруг создадим случайно ещё одну очередь, то ничего не произойдёт.

Topic

	Это тип exchange.

Fanout

	Это тип exchange.

	Exchange отправляет одно сообщение во все очереди.

Queue (очередь)

	Находится внутри обменника, то есть находится внтури RabbitMQ

	Сообщения хранятся в очередях

	Любое кол-во поставщиков могут отправлять сообщения в очередь

	Любое кол-во подписчиков могут получать сообщения из одной очереди

	Очереди создаются и в файлах поставщиках и в файлах подписчиках. Это нужно потому что мы не знаем какой файл сработает раньше. При этом каждая очередь с одинаковым названием будет созданна только единожды.

Consumer (подписчик)

	Программа принимающая сообщения

	Находится в состоянии ожидания сообщений

Bindings (переплёты)

	Нужны для того чтобы точка обмена отправляла сообщение в очередь

	channel.queue_bind('one', 'logs') - связывает точку обмена с очередью, one - это имя очереди, logs - это имя точки доступа

	Связи могут осуществляться с помощью роутинга

	channel.queue_bind(routing_key='black') - связывает очередь с сообщениями у которых роут black

Multiple bindings (составные связи)

	Нужны для того чтобы связать точку обмена с несколькими очередями

	Реализуются с помощью такой конструкции:

		new_task

			severity = sys.argv[1] if len(sys.argv) > 1 else 'info'
			channel.basic_publish(
				exchange='direct_logs',
                routing_key=severity,
                body=message
            )

		worker

			severities = sys.argv[1:]
			if not severities:
			    sys.stderr.write("Usage: %s [info] [warning] [error]\n" % sys.argv[0])
			    sys.exit(1)

			for severity in severities:
			    channel.queue_bind(
			    	exchange='direct_logs',
			        queue=queue_name,
			        routing_key=severity
			    )

Паттерны

	round-robin (поставщик отправляет сообщения по очереди каждому поставщику, смотреть очереди задач)

	publish-subscribe (поставщик отправляет одно сообщение нескольким подписчикам)

Очереди задач

	Основная цель не выполнять задачу сразу и не ждать пока уже начатая задача завершится.

	Программа-обработчик (worker.py), работающая в фоновом режиме, примет задачу на обработку, и через какое-то время выполнит её.

	Запускаем 3 консоли. Две из них будут вызывать worker.py, который является подписчиком и одна консоль запустит поставщика.

	Таким образом 2 подписчика будут ждать задачи из очереди.

	Преимущество очереди задач в том, что можно выполнять работу паралельно несколькими программами.

	Когда поставщик отправляет например пять сообщений подряд, то два воркера будут получать эти сообщения по очереди, то есть первое сообщение попадёт в первый воркер, второе сообщение попадёт во второй воркер, третье сообщение попадёт снова в первый воркер и т.д.

	Такой подход к распределению задач называется round-robin

Подтверждение выполнения сообщений

	Может возникнуть ситуация, когда поставщик отправил сообщение, подписчик начал его выполнять, но произошла ошибка и задача не выполнилась до конца.

	В таких случаях нужно подтверждение, что сообщение не только доставленно, но и выполненно.

	RabbitMQ поддерживает подтверждение сообщений. Подтверждение (ack) отправляется подписчиком для информирования RabbitMQ о том, что полученное сообщение было обработано и RabbitMQ может его удалить.

	Если подписчик прекратил работу и не отправил подтверждение, RabbitMQ поймет, что сообщение не было обработано, и передаст его другому подписчику.

Устойчивость сообщений и очередей

	По умолчанию при остановке или падении сервера RabbitMQ все очереди и сообщения теряются, но это поведение можно изменить.

	Для того чтобы сообщения оставались в очереди после перезапуска сервера, необходимо сделать как очереди, так и сообщения устойчивыми.

	channel.queue_declare(queue='hello', durable=True) - позволяет сделать очереди устойчивыми (эта команда не отработает если очередь уже созданна, поэтому лучше создать новую)

	channel.basic_publish(exchange='',
		routing_key="task_queue",
		body=message,
		properties=pika.BasicProperties(
			delivery_mode = 2, - этот параметр позволяет сделать сообщения устойчивыми
		)
    )

    Устойчивость сообщения не гарантирует, что оно не будет потеряно, потому что есть небольшой промежуток времени, когда RabbitMQ подтвердил принятие сообщения, но еще не записал его на диск.

    Если нужна более высокая надёжность, можно оборачивать сообщения в транзакции.

Равномерное распределение сообщений

	Если первый подписчик имеет более простые задачи, чем второй, то большую часть времени он будет свободен.

	Чтобы изменить такое поведение, мы можем использовать метод basic_qos с опцией prefetch_count=1. 

	После установки данной опции подписчик не получит новое сообщение, до тех пор пока не обработает и не подтвердит предыдущее. 

	И RabbitMQ передаст сообщение первому освободившемуся подписчику.

	channel.basic_qos(prefetch_count=1)

Размер очереди

	Если все подписчики заняты, то размер очереди может увеличиваться. Следует обращать на это внимание и, возможно, увеличить количество подписчиков.

Временные очереди

	Актуальны если нужно чтобы в очередь поступали все сообщения и эти сообщения были не устаревшими.

	Для этого нужно каждый раз при соединении с Rabbit создавать новую очередь без имени (оно сгенерируется автоматом) и каждый раз, когда подписчик отключается от Rabbit удалять очередь.

	channel.queue_declare('') - создаёт очередь без имени и когда подписчик отключается, автоматически удаляет её.

Удаленный вызов процедур

	Нужен если нам нужно что то выполнить на удалённой машине.

	Для этого используется технология RPC или удалённый вызов процедур.

	RPC будет включать в себя клиент и сервер.

	Клиент отправляет запрос и сервер отвечает на запрос.

	Чтобы получить ответ, клиент должен передать очередь для размещения результатов вместе с запросом.

Docker

	docker run -d --hostname my-rabbit --name some-rabbit rabbitmq:3-management (если использую повторно, то docker start container_name)

	http://localhost:15672 - panel

	bash

		export WORKON_HOME=~/.virtualenvs

		VIRTUALENVWRAPPER_PYTHON='/usr/bin/python3'

		source /usr/local/bin/virtualenvwrapper.sh

		workon

		workon env_name

		docker exec -it container_name bash

Нюансы

	Если поставщик и подписчики на одном сервере, то имеет смысл разруливать всё с помощью параметров подписчиков внутри callback.

	Если поставщик и подписчики на разных серверах, то имеет смысл сделать роутр, который будет всё разруливать.

	Если обращаемся с другого севера, то нужно создать нового пользователя и настроить подключение в pika:

		credentials = pika.PlainCredentials('yet', 'asdfasdf')
		parameters = pika.ConnectionParameters(
			'172.17.0.1',
			port=5672,
			credentials=credentials
		)

Задача

	Создать контейнер task

		Волюм, Питон

	Создать контейнер web

		Волюм, Питон

	Создать контейнер service

		Волюм, Питон

	Создать в контейнере task

		файл task.py, который является поставщиком

		посылает задачу create_user

		файл router.py, который всё разруливает

			если create_user, то пошли add_user_to_mail

			если added_user_to_mail, то пошли add_user_to_redmine

	Создать в контейнере service

		файл service.py, который является подписчиком

		иксченьдж direct 

		роутинг кей add_user_to_mail

		в callback принт "добавлен в почту" и новое событие "added_user_to_mail"

	Создать в контейнере web

		файл web.py, который является подписчиком

		иксченьдж direct

		роутинг кей create_user

		в callback принт "добавлен в редмайн" и новое событие "added_to_redmine"

	Первый посылает сообщение "создать польователя"

	Второй с именем "сектор веб" "добавляет в слак", при сообщениии "создать пользователя"
		когда пришло "добавь в редмайн", добавляем

	Третий с именем "сектор сервис" "добавляет в почту", при сообщениии "создать пользователя"
		посылает сообщение "я добавил в почту, добавь в редмайн"


	-----------------------

	docker pull ubuntu

	docker run -i -t -v ~/rabbit/task_with_docker/task:/home --name task ubuntu

		exit

	docker ps -l -> contaner_id

	docker start container_id

	------------------------------

	apt-get install -y python3-pip

	pip3 install pika





