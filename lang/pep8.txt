Оглавление

	Что это

	Отступы

	Максимальная длина строки

	Кодировка исходного файла

	Импорты

	Пробелы в выражениях и инструкциях

	Составные инструкции

	Комментарии

	Соглашения по именованию

	Проектирование наследования

	Общие рекомендации

Что это

	Это стандарт, который описывает, как писать код на python.

	Был создан на основе рекомендаций Гуидо ван Россума.

	Ключевая идея Гуидо такова: код читается намного больше раз, чем пишется.

	Рекомендации направлены на то, чтобы улучшить читаемость кода и сделать его согласованным между большим числом проектов.

	Но важно помнить, что иногда это руководство неприменимо, и понимать, когда можно отойти от рекомендаций.

	Когда вы сомневаетесь, просто посмотрите на другие примеры и решите, какой выглядит лучше.

Отступы

	Используйте 4 пробела на каждый уровень отступа.

	Пробелы - самый предпочтительный метод отступов.

	Python 3 запрещает смешивание табуляции и пробелов в отступах.

	Python 2 пытается преобразовать табуляцию в пробелы.

	В функциях и длинных конструкциях делает такие отступы:

		foo = long_function_name(var_one, var_two,
                         		 var_three, var_four)

        # здесь важны отступы аргументов от названия функции
        def long_function_name(
		        var_one, var_two, var_three,
		        var_four):

		my_list = [
		    1, 2, 3,
		    4, 5, 6,
		]

		result = some_function_that_takes_arguments(
		    'a', 'b', 'c',
		    'd', 'e', 'f',
		)

Максимальная длина строки

	Не должна превышать 79 символов.

	Предпочтительный способ переноса длинных строк является использование круглых, квадратных и фигурных скобок.

	Это предпочтительнее использования обратной косой черты для продолжения строки.

	Косая черта приемлема с менеджером контекста и assert.

Пустые строки

	Для первого метода в классе отступ должен быть в 2 пустые строки.

	Пример:

		class A():


			def make():
				pass

	Определения методов внутри класса разделяются одной пустой строкой.

		class A():


			def make():
				pass

			def read():
				pass

	Используйте пустые строки в функциях, чтобы указать логические разделы.

Кодировка исходного файла

	В python 3 кодировка должна быть UTF-8.

	В python 2 кодировка должна быть ASCII.

	Если в python 2 будут использоваться русские символы, то нужно явно указывать кодировку. Обычно это делает в начале файла, а строки потом пишутся так:

		u'Привет' 

Импорты

	Каждый импорт должен быть на отдельной строке.

	В то же время, можно писать так:

		from subprocess import Popen, PIPE

	Импорты всегда помещаются в начале файла, сразу после комментариев к модулю и строк документации, и перед объявлением констант.

	Импорты должны быть сгруппированы в следующем порядке:

		- импорты из стандартной библиотеки

		- импорты сторонних библиотек

		- импорты модулей текущего проекта

	Вставляйте пустую строку между каждой группой импортов.

	Рекомендуется абсолютное импортирование, так как оно обычно более читаемо и ведет себя лучше.

		import mypkg.sibling
		from mypkg import sibling

	Тем не менее, явный относительный импорт является приемлемой альтернативой абсолютному импорту, особенно при работе со сложными пакетами.

		from . import sibling

	Когда вы импортируете класс из модуля, вполне можно писать вот так:

		from myclass import MyClass

	Если такое написание вызывает конфликт имен, тогда пишите:

		import myclass
		import foo.bar.yourclass

	Шаблоны импортов (from import *) следует избегать, так как они делают неясным то, какие имена присутствуют в глобальном пространстве имён.

Пробелы в выражениях и инструкциях

	Не ставить пробелы внутри круглых и квадратных скобок.

		spam(ham[1], {eggs: 2}) - правильно

		spam( ham[ 1 ], { eggs: 2 } ) - неправильно

	Не ставить пробелы перед запятой, точкой с запятой или двоеточием.

		if x == 4: print(x, y); x, y = y, x - правильно

		if x == 4 : print(x , y) ; x , y = y , x - неправильно

	Не ставить пробелы перед открывающей скобкой, после которой начинается список аргументов при вызове функции и после которой следует индекс или срез.

		spam(1), dict['key'] - правильно

		spam (1), dict ['key'] - неправильно

	Не ставить более одного пробела вокруг любого из операторов, для того, чтобы выровнять его с другим.

		x = 1
		y = 2
		long_variable = 3

		Неправильно:

			x             = 1
			y             = 2
			long_variable = 3

	Пробел между оператором равно не используется только при передаче аргумента функции по умолчанию.

		def make(password=None):
			pass

Составные инструкции

	Не использовать несколько команд в одной строке.

		if foo == 'blah': do_blah_thing()
		do_one(); do_two(); do_three()

	Иногда можно писать тело циклов while, for или ветку if в той же строке, если команда короткая, но если команд несколько, никогда так не пишите.

		if foo == 'blah': do_blah_thing()

		for x in lst: total += x

		while t < 10: t = delay()

комментарии

	Комментарии, противоречащие коду, хуже, чем отсутствие комментариев.

	Всегда исправляйте комментарии, если меняете код!

	Комментарии должны являться законченными предложениями.

	Если комментарий — фраза или предложение, первое слово должно быть написано с большой буквы, если только это не имя переменной, которая начинается с маленькой буквы.

	Если комментарий короткий, можно опустить точку в конце предложения.

	Ставьте два пробела после точки в конце предложения.

	Стараться редко использовать встрочные комметарии: x = x + 1 # Increment x

	Комментирование классов, методов, функций. Пишем после ключевых слов class и def:

		"""Return a foobang plotz says to frobnicate the 
		bizbaz first.

		Optional plotz says to frobnicate the bizbaz first.

		"""
		return True

		"""Return a foobang.

		Optional plotz says to frobnicate the bizbaz first.
		
		"""
		return True

		Очень важно, чтобы закрывающие кавычки стояли на отдельной строке и между ними и последней строкой была пустая. 

	Для однострочной документации можно оставить закрывающие кавычки на той же строке:

		"""Return a foobang."""

	Так же можно писать комментарии в стиле Django:

		"""
        Constructor. Called in the URLconf; can contain helpful extra
        keyword arguments, and other things.
        """
        return True

Соглашения по именованию

	Никогда не используйте символы l (маленькая латинская буква «эль»), O (заглавная латинская буква «о») или I (заглавная латинская буква «ай») как однобуквенные идентификаторы, потому что в некоторых шрифтах эти символы неотличимы от цифры один и нуля.

	Модули должны иметь короткие имена, состоящие из маленьких букв. Можно использовать символы подчеркивания, если это улучшает читабельность.

	То же самое относится и к именам пакетов, однако в именах пакетов не рекомендуется использовать символ подчёркивания.

	Имена функций должны состоять из маленьких букв, а слова разделяться символами подчеркивания.

		def create_user():
			pass

	Если имя аргумента конфликтует с зарезервированным ключевым словом python, обычно лучше добавить в конец имени символ подчеркивания, чем исказить написание слова или использовать аббревиатуру. Таким образом, class_ лучше, чем clss. (Возможно, хорошим вариантом будет подобрать синоним).

	Константы обычно объявляются на уровне модуля и записываются только заглавными буквами, а слова разделяются символами подчеркивания.

		MAX_OVERFLOW

	Имена классов обычно пишется в формате CamelCase.

		class ProductCard:
			pass

Проектирование наследования

	Обязательно решите, каким должен быть метод и атрибут класса - публичный или непубличный.

	Если вы сомневаетесь, выберите непубличный. Потом будет проще сделать его публичным, чем наоборот.

Общие рекомендации

	Всегда используйте выражение def, а не присваивание лямбда-выражения к имени.

		def f(x): return 2*x - правильно

		f = lambda x: 2*x - неправильно

	Наследуйте свой класс исключения от Exception, а не от BaseException.

	Когда вы генерируете исключение, пишите raise ValueError('message')

	Когда код перехватывает исключения, перехватывайте конкретные ошибки вместо простого выражения except.

	Используйте строковые методы вместо модуля string, потому что они быстрее.

	Пользуйтесь ''.startswith() и ''.endswith() вместо обработки срезов строк.

		if foo.startswith('bar'):
			pass

	Сравнение типов объектов нужно делать с помощью isinstance().

		if isinstance(obj, int):
			pass

	Не сравнивайте логические типы с True и False с помощью ==

		if greeting: - правильно

		if greeting == True: - неправильно

		if greeting is True: - совсем неправильно





