Оглавление

	История
	
	О языке

	Интерпретатор

	Кэширование (файлы .pyc)

	Установка
	
	Синтаксис

	Ключевые слова

	Числа
	
	Строки

	Списки (list)

	Кортежи (tuple)

	Словари (dict)

	Множества (set)

	Сравнение последовательностей (списков, кортежей, словарей, множеств, замороженных множеств)

	Структуры данных:

	Стек

	Очередь

	Условные операторы if, else, elif

	while

	for

	Приемы использования цикла

	Функции

	lambda функции

	Замыкания

	Рекурсия

	Функции map, filter, reduce, enumerate, zip

	Итерируемые

	Итераторы

	Генераторы

	Декораторы

	Экранированные последовательности

	ООП

	Полиморфизм

	Перегрузка операторов
 
	Исключения

	Встроенные ошибки

	Менеджеры контекста

	Регулярные выражения

	Метаклассы

	Магические методы

	Многопоточность

	Работа с файлами

	Модуль

	Краткий обзор стандартной библиотеки

	Пакет

	Стандартная библиотека

	Виртуальное окружение

	Среда разработки IDLE

	Полезные конструкции

	Модуль re

	Модуль copy

	Модуль StringIO

История

	Создал голандец Гвидо ван Россум в 1991 году.

О языке

	Это язык общего назначения.

	Python поддерживает объектно-ориентированное, функциональное, структурное, императивное и аспектно-ориентированное.

	Основные черты языка это динамическая типизация, автоматическое управление памятью, поддержка многопоточных вычислений.

	Python это интерпретируемый язык программирования, то есть нтерпретатор на ходу исполняет текстовый файл с кодом.

	Эталонной реализацией Python является интерпретатор CPython.

	В Python всё объект.

Интерпретатор

	Интерпретатор - это программа, которая построчно анализирует, обработывает и выполняет исходный код другой программы.

	Простой интерпретатор анализирует и тут же выполняет программу покомандно. 

		Достоинством такого подхода является мгновенная реакция. Недостаток - такой интерпретатор обнаруживает ошибки в тексте программы только при попытке выполнения команды (или строки) с ошибкой.

	Интерпретатор компилирующего типа - это система из компилятора, переводящего исходный код программы в промежуточное представление, и интерпретатора, который выполняет полученный промежуточный код (так называемая виртуальная машина).

		Достоинством таких систем является большее быстродействие выполнения программ. Недостатки - большее требование к ресурсам и требование на корректность исходного кода.

	Алгоритм работы простого интерпретатора

		прочитать инструкцию

		проанализировать инструкцию и определить соответствующие действия

		выполнить соответствующие действия

		если не достигнуто условие завершения программы, прочитать следующую инструкцию и перейти к пункту 2

Кэширование (файлы .pyc)

	это кэш питона, который улучшает скорость работы

	.pyc - это байт-код, который будет выполнять виртуальная машина интепретатора

	виртуальная машина читает байт код из файла .pyc и переводить его в машинный код, который выполняет компьютер

	мы запускаем файл

	интерпретатор проверяет есть ли файл .pyc с таким же именем

	если есть

		то берет дату запущенного файла и дату .pyc

		если даты совпадают, то выполняет файл .pyc

		если нет, то перекомпелирует .pyc и выполняет его

	если нет

		то интерпретирует запущенный файл и создает файл .pyc с таким же именем

		а потом выполняет .pyc 

Установка

	sudo apt-get update

	sudo apt-get -y upgrade

	sudo apt-get install -y python3-pip

	python3 -V

Синтаксис

	Конец строки является концом инструкции.

	Вложенные инструкции объединяются в блоки по величине отступов. Для отступов лучше использовать 4 пробела.

	Иногда возможно записать несколько инструкций в одной строке, разделяя их точкой с запятой.

	Допустимо записывать одну инструкцию в нескольких строках. Достаточно ее заключить в пару круглых, квадратных или фигурных скобок.

Ключевые слова

	False - ложь

	True - правда

	None - "пустой" объект

	with / as - менеджер контекста

	assert условие - возбуждает исключение, если условие ложно

	break - выход из цикла

	class - пользовательский тип, состоящий из методов и атрибутов

	continue - переход на следующую итерацию цикла

	def - определение функции

	del - удаление объекта

	elif - в противном случае, если

	else - см. for/else или if/else

	raise - возбудить исключение

	try - выполнить инструкции, перехватывая исключения

	except - перехватить исключение

	finally - выполняет инструкции независимо от того, было ли исключение или нет

	for - цикл

	from - импорт нескольких функций из модуля

	global - позволяет сделать значение переменной, присвоенное ей внутри функции, доступным и за пределами этой функции

	if - если

	import - импорт модуля

	in - проверка на вхождение

	is - ссылаются ли 2 объекта на одно и то же место в памяти

	lambda - определение анонимной функции

	nonlocal - позволяет сделать значение переменной, присвоенное ей внутри функции, доступным в объемлющей инструкции

	not - логическое НЕ

	or - логическое ИЛИ

	and - логическое И

	pass - ничего не делающая конструкция

	return - вернуть результат

	while - цикл while

	yield - определение функции-генератора

Числа

	Бывают целые, вещественные, комплексные.

	Целые называются int, вещественные float, комплексные complex.

	Вещественные числа дают неточный результат при округлении, поэтому лучше использовать встроенный модуль decimal. Ключевым компонентом для работы с числами в этом модуле является класс Decimal. При это с Decimal нельзя смешивать float, но можно int.

	Комплексное число — это выражение вида a + bi, где a, b — действительные числа, а i — так называемая мнимая единица. Коплексные числа нельзя сравнить.

	Для сложных операций над числами используется модель math.

	Для работы с комплексными числами используется также модуль cmath.

	a = int('19')
	b = 1

	float('1.23')
	f = 12.9

	d = Decimal('0.1')
	d + 2

	c = complex(1, 2) # (1+2j)

	Функции:

		abs(12.9 - 150) - позволяет получить модуль числа, то есть отбрасывает знак и получает абсолютную велечину (должно быть -137.1 а получается 137.1)

		bin(19) - преобразует в двоичную строку ('0b10011')

		oct(19) - преобразует в восьмеричную строку ('0b10011')

		hex(19) - преобразует в шестнадцатеричную  строку ('0b10011')

		round(12.9) - округляет число в меньшую или большую сторону (13)

Строки

	Не изменяемы.

	Все функции и методы могут лишь создавать новую строку.

	У строки очень медленно работает оператор прибавления, потому что она не изменяемая и интерпретатор удаляет обе строки и создаёт новую, поэтому лучше собрать куски строки в список, а потом сделать join.

	Существует возможность использовать два варианта кавычек. Это позволяет не использовать экранирование.

	При использовании сырой строки механизм экранирования отключается.

	Строки в тойных кавычках можно использовать для записи многострочных блоков текста. Внутри такой строки возможно присутствие кавычек и апострофов.

	c = '''это очень большая
	строка, многострочный
	блок текста'''

	# сырая строка
	r'test' 

	'test' + 'new'
	'test' * 3

	t = 'test'
	# взятие значения по индексу (t)
	t[0]

	a = 'testimo'
	"""
	срез, начало не будет включенно и не имеет никакого отношения к индексам,
	т.е. 5 это пятый символ начиная сначала (mo 
	"""
	a[5:2]
	# срез с шагом 2 ('tsi') т.е. берутся все символы от 1 до 6, но каждый второй
	a[0:6:2]

	Функции:

		'hello {}'.format('Ilya') - подставляет значение на место фигурных скобок

		'{0} - {1}'.format('index', 1)

		'{text} - {number}'.format(text='index', number=1)

		'%s - %d' % ('text', 1)

		len('test') - определяет длинну строки

		'test'.split(',') - разбивает строчку по символу, при этом если между строками ничего нет, то будет пустая строка

		parts = [i for i in 'test']
		''.join(parts) - собирает элементы листа в строку, хавает список списков
		'\n'.join - джоин с переносом между строками

		rstrip(), lstrip(), strip() - удалют пробелы в строке (справа, слева, все)

		'aga4'.isalpha() - проверяет все ли символы являются буквами

		'3434bcg'.isdigits() - проверяет все ли символы являются цифрами

Списки (list)

	Список - это коллекция объектов произвольных типов.

	Список можно изменять.

	Если вставлять элемент в список сначала, то это медленно. Если в конец, то быстро.

	Со списками можно делать операции извлечения, вставки, удаления, слияния, среза.

	Есть такое понятие, как список списков. Это матрица.

	a = list('test')

	b = ['a', 'b', 1]

	a[START:STOP:STEP]
	a[1:4:2]

	Функции

		b.append('g') - добавляет элемент в конец списка

		b.extend(a) - расширяет список, добавляя в конец все элементы другого списка

		b.insert('c', 0) - вставляет значение на место индекса, который указан вторым параметром 

		b.remove('t') - удаляет первый элемент в списке, имеющий значение 't'

		b.pop(0) - удаляет указанный элемент и возвращает его, если индекс не указан, удаляется последний элемент

		b.count('e') - возвращает количество элементов со значением 'e'

		b.reverse() - разворачивает список и элементы идут в обратном порядке

		b.copy() - копирует список

		b.clear() - очищает список

		def my_func(e):
		  return len(e)

		cars = ['Ford', 'Mitsubishi', 'BMW', 'VW']
		
		cars.sort(key=my_func) - сортирует список на основе функции my_func

	Генераторы списков (list comprehensions)

		c = [i for i in 'test']

		squares = list(map(lambda x: x**2, range(10)))

		squares = [x**2 for x in range(10)]

		b = [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]

	Вложенные генераторы списков (nested list comprehensions)

		Начальное выражение в генераторе списка может быть любым произвольным выражением, включающим другой генератор списка.

		Нужны например для создания матрицы.

		matrix = [
			[1, 2, 3, 4],
			[5, 6, 7, 8],
			[9, 10, 11, 12],
		]

		matrix = [[row[i] for row in matrix] for i in range(4)]

	Распаковка списков аргументов

		Происходит обратная ситуация, когда аргументы уже в списке или кортеже, но должны быть распакованы при вызове функции, требующей отдельных позиционных аргументов. Например, встроенная функция range().

		args = [3, 6]
		# вызов с аргументами, распакованными из списка
		list(range(*args))

Кортежи (tuple)

	Кортеж - это неизменяемый список.

	Имеет меньший размер чем список.

	Можно использовать в качестве ключа для словаря.

	a = tuple('name')

	# если не поставить запятую, то интерпретатор не поймёт, что это кортеж и тип данных будет строка
	b = ('a',)

	c = 'a',

	Функции:

		a.reverse() - разворачивает кортеж и элементы идут в обратном порядке

		a.copy() - копирует кортеж

		a.clear() - очищает кортеж

		b.count('e') - считает кол-во элементов (в данном случае кол-во буквы 'e') в кортеже

Словари (dictionaries)

	Словари - это неупорядочная коллекция произвольных объектов с доступом по ключу. 

	Иногда их называют ассоциативный массив или хэш-таблица.

	Это изменяемый тип данных.

	При изменении значения словаря оно меняется, но при этом новая пара ключ-значение не создаётся.

	Перебор словаря может идти не в том порядке, как в нём лежат элементы. Это исправляет функция order dict из модуля collections.

	a = dict(name='ilya', surname='kaduk')

	b = {'name': 'ilya', 'surname': 'kaduk'}

	# создание словаря из ключей со значениями 100
	c = dict.fromkeys(['a', 'b'], 100)

	# создание с помощью генератора со значениями от 0 до 6
	d = {a: a for a in range(7)}

	b['name']

	# проверка наличия значения в словаре		
	if 'jack' in data

	del b['name']

	# возвращает пары (ключ, значение)
	for key, value in data.items():

	Функции:

		d.clear() - очищает словарь

		d.copy() - копирует словарь

		d.keys() - возвращает ключи словаря

		d.values() - возвращает значения словаря

		d.pop('name', default) - удаляет ключ и возвращает значение. Если ключа нет, возвращает default (по умолчанию бросает исключение).

		d.popitem() - удаляет и возвращает пару (ключ, значение), если словарь пуст, бросает исключение KeyError, помнить что словарь неупорядочен

		# возвращает пары (ключ, значение)
		d.items()

		# возвращает значение ключа. Если его нет, то создает ключ с значением default (по умолчанию None).
		d.setdefault('phone', 111)

		d['key'] = 'value' - добавление нового элемента в словарь

		d.get('key', 'default value if not key') - берет значение по ключу, а если его нет, то возвращает значение второго аргумента

Множества (set)

	Это контейнер, содержащий не повторяющиеся элементы в случайном порядке.

	Изменяемый тип данных.

	Не может быть ключом словаря.

	Множества удобно использовать для удаления повторяющихся элементов.

	a = set()

	a = set('hello')

	a = {'a', 'b', 'c', 'd'}

	a = {i for i in range(10)}

	words = ['hello', 'daddy', 'hello', 'mum']
	set(words) - преобразовали к сету и удалили повторяющиеся элементы

	# принадлежить ли элемент 'a' множеству a
	if 'a' in a:

	Операции над множествами

		a = {1, 2, 3}
		b = {3, 4, 5}

		# разность множеств, выбирает элементы, которых нет в вычитаемом (то есть в b)
		a - b

		# объединяет множества, выбирает элементы, которые встречаются хотя бы в одном из множеств
		a | b

		# пересечение, выбирает элементы, которые встречаются в обоих множествах
		a & b

		# симетрическая разность, выбирает только уникальные элементы
		a ^ b

	Функции:

		len(a) - считает длинну множества

		a.copy() - копирует множество

		a.union(b) - объединение множеств

		a.add('f') - добавляет элемент в множество

		a.remove('f') - KeyError, если такого элемента не существует

		a.discard('f') - удаляет элемент, если он находится в множестве

		a.pop('f') - удаляет первый элемент из множества. Так как множества не упорядочены, нельзя точно сказать, какой элемент будет первым

Замороженные множества (frozenset)

	Это контейнер, содержащий не повторяющиеся элементы в случайном порядке.

	Неизменяемый тип данных.

	b = frozenset('qwerty')

	Функции:

		len(b) - считает длинну множества

		b.copy() - копирует множество

Сравнение последовательностей (списков, кортежей, словарей, множеств, замороженных множеств)

	Сначала сравниваются первые два элемента, если они разные, то они и определяют результат сравнения; если они равны, сравниваются следующие два элемента и т.д.

	Если два сравниваемых элемента сами являются последовательностями одного типа, то сравнение осуществляется рекурсивно.

	Если все элементы последовательностей равны, то последовательности считаются равными.

	Если одна последовательность совпадает с началом другой, более короткая последовательность считается меньшей.

	Обратите внимание, что сравнение объектов различных типов с помощью < или > является законным при условии, что объекты имеют соответствующие методы сравнения.

	# потому что 4 больше, чем 3
	(1, 2, 3) < (1, 2, 4)

	# потому что 4 больше, чем 3
	(1, 2, 3, 4) < (1, 2, 4)

	# потому что левая часть короче правой
	(1, 2) < (1, 2, -1)

Структуры данных

	Структуры данных - это способы хранить и организовывать данные.

	Структуры данных позволяют производить 4 основных типа действий: доступ, поиск, вставку и удаление.

	Структуры данных реализованы с помощью алгоритмов, алгоритмы — с помощью структур данных.

	Алгоритм — последовательность совершаемых действий.

Стек

	Это структура данных в которой последний вошедший элемент выходит первым. (последний вошёл - первый вышел)

	Стек может переполниться.

	stack = [3, 4, 5]

	stack.append(6)

	stack.pop()

Очередь

	Это структура данных в которой первый вошедший элемент выходит первым.

	Списки не эффективны для реализации очереди, потому что извлечение с помощью pop() из начала списка происходит медленно из-за того, что все другие элементы должны быть сдвинуты на один.

	Для реализации очереди лучше использовать функцию deque из встроенного модуля collections

	queue = deque(["Eric", "John", "Michael"])

	# вставляет в конец очереди
	queue.append("Terry")

	# Первый прибывший теперь покинул
	queue.popleft()

Условные операторы if, else, elif

	Условные операторы выбирают, какое действие следует выполнить, в зависимости от значения переменных в момент проверки условия.

	Числа равные 0, пустые объекты и значение None это False.

	if a == b:
	    print('good')
	elif a < b:
	    print('bad')
	else:
	    print('normal')

	if (a == 1 and b == 2 and
	    c == 3 and d == 4):
	      print('spam' * 3)

	if x > y: print(x)

	# a > b это условие
	x = 10 if a > b else 11

while

	Выполняет тело цикла до тех пор, пока условие цикла истинно.

	Работает медленно.

	i = 5
	while i < 15:
	    print(i)
	    i = i + 2

	    if i == 9:
			break # выходит из цикла

		if i == 10:
			continue # заканчивает текущую ветку исполнения и переходит к новой итерации цикла
	else:
		print('all worked') # сработает если выход из цикла произошел без помощи break

for

	Этот цикл проходится по любому итерируемому объекту и во время каждого прохода выполняет тело цикла.

	Работает быстрее while.

	for i in 'hello world':
		print(i)

		if i == 'c':
			break # выходит из цикла

		if i == 'o':
			continue # заканчивает текущую ветку исполнения и переходит к новой итерации цикла
	else:
		print('all worked')	# сработает если выход из цикла произошел без помощи break

	for user in users:
		print(user)

	[i for i in data]

	{i for i in range(10)}

	for key, value in data.items():
		print(key, value)

Приемы использования цикла

	# Когда цикл проходит по словарям, ключ и связанное значение могут быть извлечены одновременно с помощью метода items()

	knights = {'gallahad': 'the pure', 'robin': 'the brave'}
	for key, value in knights.items():
		print(key, value)

	# Когда цикл проходит через последовательность, позиционный индекс и связанное значение могут быть извлечены одновременно с помощью функции enumerate()

	for index, value in enumerate(['tic', 'tac', 'toe']):
		print(index, value)

	# При прохождении цикла через две и более последовательности одновременно, записи могут быть объединены в пары с помощью функции zip()

	questions = ['name', 'quest', 'favorite color']
	answers = ['lancelot', 'the holy grail', 'blue']

	for q, a in zip(questions, answers):
		print('What is your {0}?  It is {1}.'.format(q, a))

	# Для перебора последовательности в обратном направлении, сначала указывают последовательность в прямом направлении и затем вызывают функцию reversed()

	for i in reversed(range(1, 10, 2)):
		print(i)

	# Для цикла по последовательности в отсортированном порядке, используйте функцию sorted(), которая возвращает новый отсортированный список, оставляя исходный неизменным

	basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
	for fruit in sorted(set(basket)):
		print(fruit)

	# Иногда заманчиво изменить список, пока вы перебираете его в цикле; однако вместо этого обычно проще и безопаснее создать новый список

	import math

	raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]

	filtered_data = []

	for value in raw_data:
		if not math.isnan(value):
			filtered_data.append(value)

Функции

	Функция в python - объект, который может принимать аргументы и возвращать значение.

	Именованные аргументы должны идти позже чем порядковые.

	Нельзя создавать функции с одинаковыми именами.

	Если функция ничего не возвращает, то она возвращает объект None.

	Если передаём изменяемые аргументы: list, dict, set в функцию и изменяем их, то их значения меняются не только внтури функции, но и снаружи. 

	Если передаём не изменяемые аргументы: tuple, str, float, complex, bool, int, frozenset, то значения меняются только внутри функции и создаётся новый объект.

	def all():
	    return 'all users'

	def calculate(x, y):
	    return x + y

	def get():
		pass

	# *args используется для передачи произвольного числа неименованных аргументов функции	
	def set(*args):
		return args

	# **kwargs позволяет вам передавать произвольное число именованных аргументов в функцию
	def unset(**kwargs):
		return kwargs

	def make(**kwargs):
		# метод get берет значение по ключу, а если его нет, то возвращает второй аргумент
		return kwargs.get('key', 'default value if not key')

	all()

	calculate(1, 2)

	# вернёт None
	get() 

	set(1, 2, 3)

	kwargs = {"arg3": 3, "arg2": "two", "arg1": 5}
	unset(**kwargs)

Lambda функции

	Лямбда функции - это функции анонимные функции или функции без имени.

	Анонимные функции могут содержать лишь одно выражение.

	Выполняются быстрее обычных.

	Лямбда функции позволяют передавать функцию другой функции в одной строчке кода.

	Не рекомендуется использовать функцию map вместе с лямбда.

	Используются, когда нужно использовать функцию единожды и при вызове функций, которая принимает функцию в качестве аргумента.

	Pep8 не рекомендует присваивать меременным lambda функции для повторного использования.

	Для этого есть обычная конструкция с def.

	Лучше не использовать lambda функцию, как обертку над другой функцией. Пример lambda items: min(items).

	lambda x: return x + 1

	func = lambda x: return x + 1
	func(1)

	(lambda x, y: x + y)(1, 2)

	def make(lambda name: name.strip()):
		return name

Замыкание

	Замыкание - это функция, в теле которой присутствуют ссылки на переменные, объявленные вне тела этой функции и не являющиеся ее аргументами.

	В Питоне замкнутые переменные доступны только для чтения. 

	Чтобы обойти такое ограничение, нужно замыкать переменные в изменяемые переменные, например, в список. 

	Сами замкнутые переменные нельзя будет перезаписывать, а вот содержимое контейнера - пожалуйста.

	def make_adder(x):
	    def adder(y):
	        return x + y # захват переменной x из внешнего контекста
	    return adder

	make_adder = lambda x: (
	    lambda n: x + n
	)

	f = make_adder(10)
	f(5) # 15

Рекурсия

	Это фукнция, которая вызвает саму себя.

	Обязательно нужно оставливать рекурсию, потому что она будет продолжаться бесконечно, пока не сожрёт всю память компьютера.

	Может использоваться, когда например нужно обойти вложенные каталоги. 

	def factorial(n):
	    if n == 0:
	        return 1
	    else:
	        return n * factorial(n - 1)

	print(factorial(5))

Функции map, filter, reduce, enumerate, zip

	Это функции для работы с итерируемыми.

	map - берёт какую то функцию и применяет для каждого итерируемого, возвращает новый объект, не рекомендуется использовать функцию map вместе с Лямбда.

	def func(x):
		return x + x

	map(func, [1, 2, 3])
	print(list(map(func, [1, 2, 3]))) >>> [2, 4, 6]

	filter - возвращает новый набор данных, отфильтрованный по какому то параметру.

	a = [1, -4, 6, 8, -10]
	def func(x):
		if x > 0:
			return 1
		else:
			return 0
	b = filter(func, a)
	b = list(b)
	print(b) # [1, 6, 8]

	reduce - применяет переданную функцию сначала к первым двум элементам, потом к результату первых двух элементов и третьему, потом к резльтату первых двух, третьего и четвёртого элемета и т.д.

	v = [0, 1, 2, 3, 4]
	r = reduce(lambda x, y: x + y, v)
	print(r) # 10


	enumerate - нумерует каждое итерируемое и возращает новый, пронумерованный объект типа enumerate.

	choices = ['pizza', 'pasta', 'salad', 'nachos']
	list(enumerate(choices)) # [(0, 'pizza'), (1, 'pasta'), (2, 'salad'), (3, 'nachos')]

	zip - позволяет пройтись одновременно по нескольким итерируемым объектам, создает объект-итератор, из которого при каждом обороте цикла извлекается кортеж, состоящий из двух элементов. Первый берется из списка a, второй - из b.

	list(zip([1, 2], [5, 7])) # [(1, 5), (2, 7)]

Итерируемые

	Итерируемые - это набор объектов, которые можно по очереди извлекать.

	Итерируемым объектом является любая коллекция: список, кортеж, словарь, множество, замороженное множество.

Итератор

    Итератор - это объект, который позволяет двигаться по итерируемым и получать очередной элемент.

    Если мы хотим получить все элементы итерируемого, то мы создаем итератор и вызываем у него функцию next пока не закончятся элементы.

    Когда элементы заканчиваются выбрасывается исключение StopIteration.

    Итератор должен быть итерируемым и возвращать самого себя чтобы его можно было использовать с for.

	items = [1, 2, 3]
	item = iter(items)
	next(item) >>> 1
	next(item) >>> 2
	next(item) >>> 3

Генератор

	Генератор - функция, которая генерирует значения.

	Могут истощаться, то есть если один раз вызвали функцию генератор и прошлись по всем элементам, то при втором вызове она вернёт пустой список.

	Для решения проблемы истощения нужно обернуть генератор в список.

	def generator():
		for i in range(3):
			# наличие ключевого слова yield в функции говорит, что это функция генератор при этом return в конце функции не доступен
			yield i

Декораторы

	Декораторы — это обёртки, которые дают возможность изменить поведение функции, не изменяя её код.

	def new_decorator(function_to_decorate):
		def original_function():
			function_to_decorate()
			print('new code')
		return original_function

	def make():
		print('make function')

	test = new_decorator(make)
	test()

	@new_decorator
	def create():
		print('create function')

	create()

	# передача аргументов в декорируемую функцию
	def decorator(function_to_decorate):
		def wrapper(arg1, arg2):
			function_to_decorate(arg1, arg2)
			print('new code')
		return wrapper

	# можно передавать аргументы и методом классов, но не забывать про self
	def wrapper(self, arg1, arg2):

Экранированные последовательности

	Экранированные последовательности - это служебные символы, которые сложно ввести с клавиатуры и которые выполняют определенные команды.

	Например перевод строки осуществляется с помощью символа \n

	\n - перевод строки

	\a - звонок

	\b - забой

	\f - перевод страницы

	\r - возврат каретки

	\t - горизонтальная табуляция

	\v - вертикальная табуляция

ООП

	ООП - объектное ориентированное программирование.

	Основными состовляющими являются классы, объекты, методы, атрибуты (св-ва).

	Класс это модель какой то сущности.

	Объект это экземпляр класса.

	Python имеет неявную или утиную типизацию. Это когда нам важно, что делает объект, а не что хранит.

	В этом нам помогают методы класса.

	Методы описывают действия сущности (например компьютер умеет включаться, выключаться).

	У каждого метода класса должен быть обязательный аргумент self в который передаётся экземпляр текущего класса. Это позволяет иметь доступ к другим методам и свойствам класса внутри метода.

	Атрибуты (св-ва) хранят какие то дополнительные характеристики сущности. Например тип корпуса, размер оперативной памяти и т.д. 

	Нет возможности заранее перечислить какие атрибуты будут в классе. Они создаются на лету в момент выполнения конструктора или метода. Смотря где определены.

	Основные постулаты ООП это наследование, инкапсуляция, полиморфизм.

	Наследование - это возможность получить в дочернем классе все атрибуты и методы класса родителя.

	Инкапсуляция - это ограничение доступа к составляющим объект компонентам (методам или атрибутам).

	Полиморфизм - разное поведение одного и того же метода в разных классах.

	class Animal:
		# это конструктор класса, он срабатывает автоматически при создании экземпляра класса
		def __init__(self):
			self.type = 'type'
			self.speed = 200

		def eat(self, eat):
			return eat

		# делает метод класса статическим и при его вызове не создаётся экземпляр класса
		@staticmethod
		def sleep():
			return 'sleep'

	В Python отсутствует встроенная поддержка абстрактных классов, поэтому для этой цели используется модуль abc.

		Абстрактным называется класс, который содержит один и более абстрактных методов.

		На основе абстрактного класса не может быть создан экземпляр.

		От абстрактного класса нужно унаследоваться, реализовать все его абстрактные методы и только тогда можно создать экземпляр такого класса.
		
		from abc import ABC, abstractmethod
		
		# абстрактный класс
		class ChessPiece(ABC):
		    def draw(self):
		        print('draw')
		 
		    # абстрактный метод (необходимо переопределять для каждого подкласса)
		    @abstractmethod
		    def move(self):
		        pass

		class Queen(ChessPiece):
			# переопределили абстрактный метод базового класса
		    def move(self):
		        print('move')

		Обратите внимание, абстрактный метод может быть реализован сразу в абстрактном классе, однако, декоратор abstractmethod, обяжет программистов, реализующих подкласс либо реализовать собственную версию абстрактного метода, либо дополнить существующую. 

		В таком случае, мы можем переопределять метод как в обычном наследовании и вызывать родительский метод при помощи super().

			class Basic(ABC):
			    @abstractmethod
			    def hello(self):
			        print('hello')
			 
			 
			class Advanced(Basic):
			    def hello(self):
			        super().hello()
			        print('advanced hello')


	В python отсутствует встроенная поддержка интерфейсов.


	# Наследование
	class Dog(Animal):
		pass


	# Множественное наследование
	class A(B, C):
		pass


	class D:
		def make_material(self):
			return 'make_material'

	class F(D):
		def create(self):
			# позволяет обратиться к методу класса родителя
			material = super().make_material()
			return 'create' + material

	class G:
		# защищённый метод, который доступен в классе родителе и его наследниках
		def _show(self):
			pass

		# приватный метод, который доступен только в классе родителе
		def __set(self):
			pass

		# данные модификаторы действуют на уровне соглашения, потому что доступ к этим методам и св-ва возможен.

	Сеттеры

		class Person:
		    def __init__(self, name):
		        self.__name = name
		        self.__age = 1
		 	
		 	# для создания свойства-геттера над свойством ставится аннотация @property
		 	# хорошо использовать для создания свойств только для чтения
		    @property
		    def age(self):
		        return self.__age
		 	
		 	# для создания свойства-сеттера над свойством устанавливается аннотация имя_свойства_геттера.setter
		    @age.setter
		    def age(self, age):
		    	self.__age = age
	     
	user = User()
	# Обращение к св-ву экземпляра класса
	user.name = 'Mike'

	# Обращение к св-ву класса
	User.name

	Когда определение класса введено, создается новое пространство имен и используется в качестве локальной области видимости - поэтому все присваивания локальным переменным происходят в этом новом пространстве имен.

Полиморфизм

	Полиморфизм как один из ключевых элементов ООП существует независимо от наследования.

	Разные классы могут иметь метод с одинаковым названием, но разным поведением.

	Однако одинаковое название метода позволит не запутать программу, сделать код более ясным.

	В Python среди прочего полиморфизм находит отражение в методах перегрузки операторов.

Перегрузка операторов

	Перегрузка операторов - это когда мы можем создать в классе наследнике метод с таким же названием, что и в классе родителе, но работать они будут по разному.

	Является одим из способов реализации полиморфизма.

	class A:
	    def say(self):
	        print('a')

	class B(A):
	    def say(self, name):
	        print('Hi, I am {}'.format(name))

	a = A()
	b = B()

	b.__class__.__bases__[0].say(b) - обращаемся к методу say класса A

Исключения

	Исключения - это тип данных необходимый для сообщения об ошибках.

	При ошибке интерпретатор генерирует исключение и это тоже объект.

	Исключения можно выбрасывать с помощью ключевого слова raise.

	Исключение можно перехватывать с помощью try/except.

	Делать ошибки своего типа это хорошая практика, потому что таким образом мы их изолируем от системных ошибок. Обычно все классы-исключения создаются в начале модуля. Собственные классы исключений лучше заканчивать словом Error.

	Есть два подхода обработки ошибок:

		Перед тем как прыгать, нужно посмотреть.

			Пишем код в функции, а потом оборачиваем её вызов в if. Если все хорошо, то идём дальше, если нет, то выбрасываем исключение.

		Проще попросить прощения, чем разрешения.

			Пишем всё что мы хотим сделать, а потом перехватываем все возможные исключения. Питонисты за этот способ.

def get_arg(a):
	if a == 0: 
		# выбрасываем исключение
		raise ValueError()

	try:
		get_arg(0)
	except ValueError as e:
		# выполнится если было перехваченно исключение и выведет сообщение об ошибке
		print(e.message)
	else:
		# выполняется в том случае если исключения не было
		print('all rigth')
	finally:
		# выполняется в любом случае
	    print('need show')

	# создание собственного исключения
	class MyError(Exception): 
		pass

	Внутри кастомного класса исключения можно использовать две функции:

	__init__ - для создания исключения

	__str__ - для вывода на экран

	Но можно просто отнаследоваться от базового класса исключения и завершить свой класс оператором pass.

	try:
	    return self._connection.stat(name)
	except IOError:
	    raise - пустой raise выбрасывает последнее сработавшее исключение

	# позволяет получить доступ к трейсбэку
	import traceback
	try:
	    return self._connection.stat(name)
	except IOError:
		traceback.format_exc()

Встроенные ошибки

	IndentationError - неправильные отступы

	TabError - смешивание в отступах табуляции и пробелов

	StopIteration - порождается встроенной функцией next, если в итераторе больше нет элементов

	ArithmeticError - арифметическая ошибка

	ZeroDivisionError - деление на ноль

	AttributeError - объект не имеет данного атрибута (значения или метода)

	EOFError - функция наткнулась на конец файла и не смогла прочитать то, что хотела

	ImportError - не удалось импортирование модуля или его атрибута

	LookupError - некорректный индекс или ключ

	IndexError - индекс не входит в диапазон элементов

	KeyError - несуществующий ключ (в словаре, множестве или другом объекте)

	NameError - не найдено переменной с таким именем

	OSError - ошибка, связанная с системой

	PermissionError - не хватает прав доступа

	TimeoutError - закончилось время ожидания

	RuntimeError - возникает, когда исключение не попадает ни под одну из других категорий

	NotImplementedError - возникает, когда абстрактные методы класса требуют переопределения в дочерних классах

	SyntaxError - синтаксическая ошибка

	TypeError - операция применена к объекту несоответствующего типа

	ValueError - функция получает аргумент правильного типа, но некорректного значения

	UnicodeError - ошибка, связанная с кодированием / раскодированием unicode в строках

Менеджер контекста

	Менеджер контекста - это объект, который создает контекст выполнения внутри себя.

	Что значит контекст выполнения?

	Нужен для гарантии того, что критические функции выполнятся в любом случае. 

	Самый распространённый пример использования этой конструкции - открытие файлов и выполнение транзакции.

	# в этом случае файл в любом случае будет закрыт
	with open('newfile.txt', 'w', encoding='utf-8') as g: 
	    d = int(input())

	with transaction.atomic():
		do_something()

Регулярные выражения

	Регулярное выражение - это последовательность символов для поиска, замены или разбиения текста в строке.

	Символы представляют собой маску по которой осуществляется поиск, замена и т.д.

	Базовые символы:

		. - один любой символ, кроме новой строки \n.

		? - 0 или 1 вхождение шаблона слева

		+ - 1 и более вхождений шаблона слева

		* - 0 и более вхождений шаблона слева

		\w - любая цифра или буква

		\W - все, кроме буквы или цифры

		\d - любая цифра [0-9]

		\D - все, кроме цифры

		\s - любой пробельный символ

		\S - любой непробельный символ

		\b - граница слова

		[..] - один из символов в скобках

		[^..] - любой символ, кроме тех, что в скобках

		\ - экранирование специальных символов

		\. - означает точку

		\+ - означает знак «плюс»

		^ - начало строки 

		$ - конец строки

		{n,m} - от n до m вхождений

		{,m} - от 0 до m вхождений

		a|b	- соответствует a или b

		() - группирует выражение и возвращает найденный текст

		\t - символ табуляции

		\name - символ новой строки

		\r - символ возврата каретки

	В Python для работы с регулярными выражениями есть модуль re.

	Пример: re.findall(r'^\w+', 'AV is largest Analytics community of India')

Метаклассы

	Это объект создающий другие объекты.

	В django работа с базой данный реализованна с помощью метаклассов.

	type(name, base, attrs) - самый главный метакласс, name - имя класса, bases - классы родителей, attrs - атрибуты

	Класс является объектом для метакласса. 

	Перед тем как создастся класс он попадёт в функцию type()

	Выгода метаклассов в том, что мы можем что то сделать до создания экземпляра класса. В django так сделана работа с БД. То есть в классе модель мы определяем поля нашей базы и они создаются до создания экземпляра класса модели.

	class TestClass(object):
		pass

	TestClass = type('TestClass', (), {}) # функция type позволяет создать классы на ходу

Магические методы

	Магические методы - это методы, которые вызываются не напрямую, а встроенными функциями или операторами python

	__new__  - управляет созданием экземпляра, должен возвращать экземпляр класса для его последующей его передачи методу __init__

	__init__ - конструктор класса, который срабатывает при создании экземпляра класса (объекта)

	__del__ - вызывается при удалении объекта сборщиком мусора

	__str__ - возвращает строковое представление объекта

	__getattr__ - вызывается, когда атрибут экземпляра класса не найден

	__setattr__ -  вызывается, когда происходит назначение атрибута ?

	__delattr__ - вызывается, когда происходит удаление атрибута ?

	__hash__ - получение хэш-суммы объекта, например, для добавления в словарь

	__call__ - вызов экземпляра класса как функции

	__len__ - длина объекта

Многопоточность

	Процесс – это часть виртуальной памяти и ресурсов, которую ОС выделяет для выполнения программы. Если открыть несколько экземпляров одного приложения, под каждый система выделит по процессу. 

	В современных браузерах за каждую вкладку может отвечать отдельный процесс.

	Тяжёлый процесс делят на потоки, которые занимают меньше ресурсов и скорее доносят код до вычислителя.

	У каждого приложения есть как минимум один процесс, а у каждого процесса минимум один поток, который называют главным и из которого при необходимости запускают новые.

	Потоки используют память, выделенную под процесс, а процессы требуют себе отдельное место в памяти. Поэтому потоки создаются и завершаются быстрее.

	Процессы работают каждый со своими данными — обмениваться чем-то они могут только через механизм межпроцессного взаимодействия. Потоки обращаются к данным и ресурсам друг друга напрямую: что изменил один  —  сразу доступно всем.

	Если вам нужно как можно быстрее обработать большой объём данных, разбейте его на куски, которые можно обрабатывать отдельными потоками, а затем соберите результат воедино.

	Многопоточность — это когда процесс приложения разбит на потоки, которые параллельно — в одну единицу времени — обрабатываются процессором.

	Вычислительная нагрузка распределяется между двумя или более ядрами, так что интерфейс и другие компоненты программы не замедляют работу друг друга.

	Многопоточные приложения можно запускать и на одноядерных процессорах, но тогда  потоки выполняются по очереди: первый поработал, его состояние сохранили — дали поработать второму, сохранили — вернулись к первому или запустили третий.

	Представьте, что несколько потоков пытаются одновременно изменить одну и ту же область данных. Чьи изменения будут в итоге приняты, а чьи  —  отменены? Чтобы работа с общими ресурсами не приводила к путанице, потокам нужно координировать свои действия. Для этого они обмениваются информацией с помощью сигналов. Каждый поток сообщает другим, что он сейчас делает и каких изменений ждать. Этот процесс называется синхронизацией.

	Основные средства синхронизации:

		Взаимоисключение - флажок, переходящий к потоку, который в данный момент имеет право работать с общими ресурсами. Исключает доступ остальных потоков к занятому участку памяти. Мьютексов в приложении может быть несколько, и они могут разделяться между процессами. Есть подвох: mutex заставляет приложение каждый раз обращаться к ядру операционной системы, что накладно.

		Семафор  —  позволяет вам ограничить число потоков, имеющих доступ к ресурсу в конкретный момент. Так вы снизите нагрузку на процессор при выполнении кода, где есть узкие места. Проблема в том, что оптимальное число потоков зависит от машины пользователя.

		Событие  —  вы определяете условие, при наступлении которого управление передаётся нужному потоку.

	Организовать параллельные вычисления в Python без внешних библиотек можно с помощью модулей:

		threading (для управления потоками)

		queue (для работы с очередями)

		multiprocessing (для управления процессами)

Работа с файлами

	f = open('text.txt', 'r') - функция open позволяет открыть файл

	Второй аргумент функции open это режим в котором будет открыть файл.

	Режимы открытия файла:

		'r' - открытие на чтение (является значением по умолчанию)

		'w' - открытие на запись, содержимое файла удаляется, если файла не существует, создается новый

		'x' - открытие на запись, если файла не существует, иначе исключение

		'a' - открытие на дозапись, информация добавляется в конец файла

		'b' - открытие в двоичном режиме

		't' - открытие в текстовом режиме (является значением по умолчанию)

		'+' - открытие на чтение и запись

	Режимы могут быть объединены, то есть, к примеру, 'rb' - чтение в двоичном режиме. 

	По умолчанию режим равен 'rt'.

	Есть несколько способов чтения из файла:

		Первый - прочитать файл целиком с помощью метода read

			f.read(1) - читает кол-во символов переданное в аргументе

			f.read() - читает весь файл целиком

		Второй - прочитать файл построчно, воспользовавшись циклом for

			f = open('text.txt')
			for line in f:
				line

	Запись в файл осуществляется с помощью метода write.

		for name in names:
			f.write(name)

	После окончания работы с файлом его обязательно нужно закрыть с помощью метода close или воспользоваться менеджером контектса, который сделает все автоматически.

		f.close()

	В python уже давно придумали средства, такие как pickle или json, позволяющие сохранять в файле сложные структуры.

Модуль

	Модуль - это любой файл с программой.

	Каждая программа может импортировать модуль и получить доступ к его классам, функциям и объектам.

	Подключить модуль можно с помощью инструкции import.

		import os

	После импортирования модуля его название становится переменной, через которую можно получить доступ к атрибутам модуля.

	Если указанный атрибут модуля не будет найден, то возбудится исключение AttributeError.

	Если не удастся найти модуль для импортирования, то возбудится исключение ImportError.

	Для модуля можно создать псевдоним с помощью ключевого слова as.

		import math as ai

	Подключить определенные атрибуты модуля можно с помощью инструкции from.

		from math import e, ceil

	Можно подкючить все переменные из модуля.

		from random import *

	Следует заметить, что не все атрибуты будут импортированы. Если в модуле определена переменная __all__

	Модуль нельзя именовать также, как и ключевое слово.

	Пути поиска модулей указаны в переменной sys.path. 

	В него включены текущая директория (то есть модуль можно оставить в папке с основной программой), а также директории, в которых установлен python.

	При импортировании модуля его код выполняется полностью, то есть, если программа что-то печатает, то при её импортировании это будет напечатано.

	Этого можно избежать, если проверять, запущен ли файл как программа, или импортирован.

	Если файл запущен, как программа, то его __name__ будет равен '__main__'.

	Тогда мы оборачиваем вызовы всех функций в функцию main и вызываем её только в том случае, если файл запущен, как программа.

		def one():
			pass

		def two():
			pass

		def main():
			one()
			two()

		if __name__ == '__main__':
			main()

Краткий обзор стандартной библиотеки

	Модуль os

		Предоставляет множество функций для взаимодействия с операционной системой.

			os.chdir('/server/accesslogs') - изменяет текущую рабочую директорию

			os.system('mkdir today') - запускает команду mkdir

	Модуль shutil

		Для ежедневных задач по управлению файлами и каталогами (более простой нежели os)

			shutil.copyfile('data.db', 'archive.db')

			shutil.move('/build/executables', 'installdir')

	Модуль glob

		Для создания списков файлов по шаблону из найденных в каталоге.

			glob.glob('*.py')

Пакет

	Пакет - это коллекция модулей.

	С помощью пространства имен пакеты решают проблему одинаковых глобальных переменных.

	Например есть пакеты A и B.

	Внутри каждого пакета есть модуль app.

	Внутри каждого модуля есть глобальная переменная name.

	В случае импорта этих пакетов одновременно, конфликта не будет, потому что namespace переменной name из модуля A будет A.app.name, а переменной name из модуля B будет B.app.name.

	Внутри корневой директории пакета должен находиться __init__.py

	__init__.py требуются для того, чтобы Python понял, что директория является пакетом.

	Так же __init__.py позволяет загружать пакет с помощью конструкции from/import

	В самом простом случае __init__.py может просто быть пустым файлом, но он также может выполнять инициализирующий код для пакета или устанавливать переменную __all__.

Стандартная библиотека

	import os - предоставляет множество функций для взаимодействия с операционной системой

		Обязательно используйте стиль import os вместо from os import *. 

		Это сохранит os.open() от перекрытия встроенной функции open()

		Для ежедневных задач по управлению файлами и каталогами лучше подойдет модуль shutil 

	import glob - функцию для создания списков файлов по шаблону из найденных в каталоге

	import sys - позволяет работать с аргументами командной строки

		Модуль sys также имеет атрибуты для stdin (стандартный ввод), stdout (стандартный вывод) и stderr (стандартный вывод ошибок).

		Самый очевидный способ завершить сценарий заключается в использовании sys.exit()

	import re - служит для работы с регулярными выражениями

		Когда необходимы только простые возможности, методы строк являются предпочтительными, поскольку они являются более удобными для чтения и отладки

		'tea in too'.replace('too', 'two') >>> 'tea in two'

	import math - предоставляет доступ к базовым функциям библиотеки C для математики с плавающей точкой

	import random - предоставляет инструменты для создания случайного выбора

	import statistics - вычисляет основные статистические свойства (среднее, медиану, расхождение и т. д.) числовых данных

	import urllib.request - позволяет получить доступ в Интернет и работает с интернет-протоколами

	import smtplib - позволяет отправлять почту

	import datetime - нужен для работы с датой, временем и часовыми поясами

	import zlib - позволяет архивировать и сжимать данные

	import timeit - для измерения производительности работы кода

	import doctest - для сканирования модуля и проверки тестов, встроенных в строки документации программы

	import unittest - для тестирования классов, методов, функций

	import reprlib - альтернатива функции repr()

	import pprint - предлагает более тонкий контроль над выводом как встроенных, так и пользовательских объектов таким образом, что интерпретатор выводит их в более читаемом виде

	import textwrap - форматирует абзацы текста, чтобы соответствовать заданной ширине экрана

	import locale - обращается к базе данных определенных культур (стран)

	import string - для работы с текстом

	import struct - функции pack() и unpack() для работы с форматами бинарных записей переменной длины

	import threading, zipfile - для работы с многопоточностью (позволяет выполнять задачи в фоновом режиме)

	import logging - предлагает гибкую систему логирования

	import weakref, gc - предоставляет инструменты для отслеживания объектов, не создавая ссылку в памяти. Позволяет собирать мусор.

	import array - предоставляет объект array(), который подобен списку, хранящему только однородные данные, и сохраняет их более компактно

	import collections - предоставляет объект deque(), который, как список, более быстро добавляет и извлекает с левой стороны, но медленнее осуществляет поиск в середине

	import bisect - для манипулирования упорядоченными списками

	import heapq - предоставляет функции для реализации куч, основанных на обычных списках

	import decimal - предлагает тип данных Decimal

Виртуальное окружение

	Это изолированное дерево директорий, которое содержит инсталляцию Python нужной версии.

	Виртуальное окружение позволяет разным приложениям работать со своими уникальные версиями модулей.

	Модуль, используемый для создания и управления виртуальными средами, называется venv.

	Чтобы создать виртуальную среду, выберите каталог для ее размещения и запустите модуль venv как скрипт:

		python3 -m venv tutorial-env

	Это создаст каталог tutorial-env, если он не существует, и также создаст директории внутри него, содержащие копию интерпретатора Python, стандартную библиотеку и различные вспомогательные файлы.

	Создав виртуальную среду, вы можете ее активировать и деактивировать.

Среда разработки IDLE

	IDLE - среда разработки на языке Python, поставляемая вместе с дистрибутивом

	python/python3 - вызывает среду разработки (вводить в терминале)

Полезные конструкции

	sys.argv[1:] - позволяет получить аргументы из командной строки при вызове скрипта

	time.sleep(3) - приостанавливает выполнение программы на заданное количество секунд

	dir(obj) - возвращает атрибуты объекта

Модуль re

	Для работы с регулярными выражениями.

	re.match(pattern, string) - ищет по заданному шаблону в начале строки

	result = re.метод(pattern, string)
	result.group(0) - используется для вывода результата во всех методах

	re.search(pattern, string) - ищет по всей строке, но возвращает только первое найденное совпадение

	re.findall(pattern, string) - ищет по всей строке и возвращает список всех найденных совпадений

	re.split(pattern, string, [maxsplit=0]) - разделяет строку по заданному шаблону

	re.sub(pattern, repl, string) - ищет шаблон в строке и заменяет его на указанную подстроку

	re.compile(pattern, repl, string) - позволяет собрать регулярное выражение в отдельный объект, который может быть использован в других методах, как паттерн

		pattern = re.compile('AV')

		pattern.findall('AV Analytics Vidhya AV')

Модуль copy

	Операция присваивания не копирует объект, он лишь создаёт ссылку на объект. 

	Для изменяемых коллекций бывает нужна копия, которую можно изменить, не изменяя оригинал.

	Для этого и нужен модуль copy.

	copy.copy(x) - возвращает поверхностную копию x.

	copy.deepcopy(x) - возвращает полную копию x.

	copy.error - возникает, если объект невозможно скопировать.

	Разница между обычным и глубоким копированием заметна, только при копировании составных объектов, состоящих из изменяемых объектов.

	Например список списков.

	При поверхностном копировании изменения в новом объекте затронут старый.

		test_1 = [1, 2, 3, [1, 2, 3]]

		test_copy = copy.copy(test_1)

		print(test_1, test_copy)

		>>> [1, 2, 3, [1, 2, 3]] [1, 2, 3, [1, 2, 3]]

		test_copy[3].append(4)

		print(test_1, test_copy)

		>>> [1, 2, 3, [1, 2, 3, 4]] [1, 2, 3, [1, 2, 3, 4]]

	При глубоком копировании изменения в новом объекте не произойдут.

		test_1 = [1, 2, 3, [1, 2, 3]]

		test_deepcopy = copy.deepcopy(test_1)

		test_deepcopy[3].append(4)

		print(test_1, test_deepcopy)

		>>> [1, 2, 3, [1, 2, 3]] [1, 2, 3, [1, 2, 3, 4]]

Модуль StringIO

	Позволяет работать со строкой как с файловым объектом. 

	Все операции с файловым объектом производится в оперативной памяти.

	Не нужно открывать и закрывать при работе.

